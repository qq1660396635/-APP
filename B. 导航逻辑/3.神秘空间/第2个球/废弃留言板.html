<!DOCTYPE html> 
<html lang="zh-CN"> 
<head>
<meta charset="UTF-8"> 
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>å¤§æ¥¼å¼ç•™è¨€æ¿- æ£•æœ¨å³¡è°·</title> 
<style>
* {
margin: 0; padding: 0; box-sizing: border-box;
}
body {
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; background: #ffffff; color: #333; cursor: crosshair; touch-action: none;
}
#canvas-container {
width: 100vw; height: 100vh; position: relative;
}
/* è¿·ä½ æ§åˆ¶é¢æ¿*/
#mini-controls {
position: absolute; top: 20px; right: 20px; z-index: 100; background: rgba(255, 255, 255, 0.95); padding: 15px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1); backdrop-filter: blur(10px); width: 200px; transition: all 0.3s ease;
}
#mini-controls.collapsed {
width: 50px; height: 50px; padding: 0; overflow: hidden;
}
#mini-controls:hover {
transform: scale(1.02); box-shadow: 0 6px 30px rgba(0, 0, 0, 0.15);
}
.control-header {
display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;
}
.control-header h4 {
font-size: 14px; color: #666; margin: 0;
}
.toggle-btn {
background: none; border: none; font-size: 18px; cursor: pointer; color: #667eea; transition: transform 0.3s ease;
}
.toggle-btn:hover {
transform: scale(1.2);
}
#mini-controls.collapsed .control-content {
display: none;
}
.mini-btn {
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; margin: 2px; transition: all 0.3s ease; width: calc(50% - 4px);
}
.mini-btn:hover {
transform: translateY(-2px); box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}
/* ç§»åŠ¨æ§åˆ¶*/
#movement-controls {
position: absolute; bottom: 30px; left: 30px; z-index: 100; background: rgba(255, 255, 255, 0.9); padding: 15px; border-radius: 15px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1); backdrop-filter: blur(10px);
}
/* ä¿®å¤æŒ‰é’®å¸ƒå±€ - ä¸‰è¡Œå¸ƒå±€ */
.move-pad {
display: grid; 
grid-template-columns: 50px 50px 50px; 
grid-template-rows: 50px 50px 50px; 
gap: 5px;
}
.move-btn {
background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%); 
border: 2px solid #ddd; 
border-radius: 10px; 
cursor: pointer; 
font-size: 20px; 
color: #666;
transition: all 0.2s ease; 
display: flex; 
align-items: center; 
justify-content: center; 
user-select: none;
}
.move-btn:hover {
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
color: white; transform: scale(1.1);
}
.move-btn:active, .move-btn.active {
background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
color: white; transform: scale(0.95);
}
/* ä¸‰è¡Œå¸ƒå±€å®šä½ */
.move-btn.up { grid-column: 2; grid-row: 1; }
.move-btn.left { grid-column: 1; grid-row: 2; }
.move-btn.right { grid-column: 3; grid-row: 2; }
.move-btn.down { grid-column: 2; grid-row: 3; }
/* è§¦æ‘¸ç§»åŠ¨åŒºåŸŸ*/
#touch-move-area {
position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%); width: 150px; height: 150px; background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 50%; z-index: 90; display: none;
}
#touch-move-area.show {
display: block;
}
#touch-move-area::before {
content: '';
position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 60px; height: 60px; background: rgba(102, 126, 234, 0.3); border-radius: 50%;
}
#touch-move-area::after {
content: 'ğŸ‘†'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px;
}
/* è§¦æ‘¸æŒ‡ç¤ºå™¨*/
#touch-indicator {
position: absolute; top: 60px; left: 50%; transform: translateX(-50%); background: rgba(102, 126, 234, 0.9); color: white; padding: 8px 16px; border-radius: 20px; font-size: 12px; z-index: 50; display: none; animation: fadeInOut 2s ease;
}
#touch-indicator.show {
display: block;
}
/* æç¤ºä¿¡æ¯*/
#help-text {
position: absolute; top: 20px; left: 50%;
transform: translateX(-50%); background: rgba(255, 255, 255, 0.9); padding: 10px 20px; border-radius: 20px; font-size: 14px; color: #666; z-index: 50; animation: fadeInOut 8s ease;
}
@keyframes fadeInOut {
0%, 100% { opacity: 0; } 10%, 90% { opacity: 1; }
}
/* ç•™è¨€ç¼–è¾‘æ¨¡æ€æ¡†*/
#message-input-modal {
display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #ffffff 0%, #f8f8f8 100%); padding: 30px; border-radius: 20px; z-index: 1000; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.8);
}
#message-input-modal.active {
display: block; animation: modalFadeIn 0.3s ease;
}
@keyframes modalFadeIn {
from { opacity: 0; transform: translate(-50%, -45%); } to { opacity: 1; transform: translate(-50%, -50%); }
}
#message-input {
width: 300px; padding: 15px;
font-size: 16px; border: 2px solid #667eea; border-radius: 10px; background: rgba(255, 255, 255, 0.9); color: #333; margin-bottom: 15px; transition: all 0.3s ease;
}
#message-input:focus {
outline: none; border-color: #764ba2; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}
.modal-buttons {
display: flex; gap: 10px;
}
/* åŠ è½½åŠ¨ç”»*/
#loading {
position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; color: #667eea; animation: pulse 1.5s infinite;
}
@keyframes pulse {
0%, 100% { opacity: 1; } 50% { opacity: 0.5; }
}
/* ç§»åŠ¨çŠ¶æ€æŒ‡ç¤ºå™¨*/
#movement-indicator {
position: absolute; bottom: 30px; right: 30px; background: rgba(255, 255, 255, 0.9); padding: 10px 15px; border-radius: 10px;
font-size: 12px; color: #666; z-index: 100;
}
/* ç§»åŠ¨æ§åˆ¶æ¨¡å¼åˆ‡æ¢*/
#control-mode {
position: absolute; bottom: 200px; left: 30px; z-index: 100; background: rgba(255, 255, 255, 0.9); padding: 10px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
}
.mode-btn {
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 12px; margin: 2px; transition: all 0.3s ease;
}
.mode-btn.active {
background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
}
</style> 
</head> 
<body>
<div id="canvas-container">
<div id="loading">æ­£åœ¨åŠ è½½æ£•æœ¨å³¡è°·...</div> 
<div id="help-text">ğŸ®æ–¹å‘é”®/WASD ç§»åŠ¨| é¼ æ ‡æ‹–æ‹½æ—‹è½¬| è§¦å±æ»‘åŠ¨æ—‹è½¬| ç‚¹å‡»çª—æˆ·ç¼–è¾‘</div>
<div id="touch-indicator">ğŸ‘†æ»‘åŠ¨æ—‹è½¬è§†è§’</div>
<!-- è§¦æ‘¸ç§»åŠ¨åŒºåŸŸ-->
<div id="touch-move-area"></div> 
</div>
<!-- è¿·ä½ æ§åˆ¶é¢æ¿--> 
<div id="mini-controls">
<div class="control-header">
<h4 id="control-title">ğŸ¯å¿«æ·æ“ä½œ</h4> 
<button class="toggle-btn" onclick="toggleControls()">â—€</button>
</div> 
<div class="control-content">
<button class="mini-btn" onclick="clearAllMessages()"> æ¸…ç©ºæ‰€æœ‰ </button>
<button class="mini-btn" onclick="clearBuilding('left')">æ¸…ç©ºå·¦ä¾§ </button>
<button class="mini-btn" onclick="clearBuilding('right')">æ¸…ç©ºå³ä¾§ </button>
<button class="mini-btn" onclick="resetPosition()"> é‡ç½®ä½ç½® </button>
</div> 
</div>
<!-- ç§»åŠ¨æ§åˆ¶æ¨¡å¼åˆ‡æ¢--> 
<div id="control-mode">
<button class="mode-btn active" onclick="setControlMode('button')">æŒ‰é’®æ§åˆ¶</button>
<button class="mode-btn" onclick="setControlMode('touch')">è§¦æ‘¸æ§åˆ¶</button>
</div>
<!-- ç§»åŠ¨æ§åˆ¶ - ä¸‰è¡Œå¸ƒå±€--> 
<div id="movement-controls">
<div class="move-pad">
<button class="move-btn up" data-direction="forward">â†‘</button>
<button class="move-btn left" data-direction="left">â†</button> 
<button class="move-btn right" data-direction="right">â†’</button>
<button class="move-btn down" data-direction="backward">â†“</button>
</div>
</div>
<!-- ç§»åŠ¨çŠ¶æ€æŒ‡ç¤ºå™¨-->
<div id="movement-indicator">
ä½ç½®: <span id="position-text">X: 0, Z: 0</span> 
</div>
<!-- ç•™è¨€ç¼–è¾‘æ¨¡æ€æ¡†--> 
<div id="message-input-modal">
<h3 style="margin-bottom: 15px; color: #667eea;">âœï¸ç¼–è¾‘ç•™è¨€</h3> 
<input type="text" id="message-input" placeholder="è¾“å…¥ä½ çš„ç•™è¨€..." maxlength="20">
<div class="modal-buttons">
<button class="mini-btn" onclick="saveMessage()" style="width: auto; padding: 10px 20px;">ä¿å­˜</button>
<button class="mini-btn" onclick="closeModal()" style="width: auto; padding: 10px 20px; background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);">å–æ¶ˆ</button>
</div> 
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script >
<script>
// å…¨å±€å˜é‡ 
let scene, camera, renderer; 
let buildings = []; 
let messageBoards = []; 
let raycaster, mouse; 
let selectedBoard = null; 
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let velocity = new THREE.Vector3(); 
let direction = new THREE.Vector3();
// è§¦æ‘¸æ§åˆ¶å˜é‡ 
let touchStartX = 0; 
let touchStartY = 0; 
let isTouching = false;
let isTouchMoving = false; 
let touchMoveStartX = 0; 
let touchMoveStartY = 0; 
let cameraRotationX = 0; 
let cameraRotationY = 0;
// é¼ æ ‡æ§åˆ¶å˜é‡ 
let isMouseDown = false; 
let mouseX = 0; 
let mouseY = 0;
// æ§åˆ¶æ¨¡å¼ 
let controlMode = 'button';
// ç¢°æ’æ£€æµ‹ç›¸å…³ 
let playerRadius = 0.2; 
let buildingBounds = [];
// æ´»è·ƒæ–¹å‘è·Ÿè¸ªï¼ˆä¿®å¤å¤šæŒ‰é’®åŒæ—¶æŒ‰ä¸‹ï¼‰
let activeDirections = new Set();
// é…ç½®å‚æ•° 
const CONFIG = {
buildingWidth: 1.2, 
buildingDepth: 0.3, 
buildingHeight: 2.8, 
floors: 4, 
windowsPerFloor: 7, 
windowSize: 0.15, 
roomWidth: 12, 
roomDepth: 6, 
roomHeight: 3.5, 
alleyWidth: 2, 
moveSpeed: 0.05, // å¢åŠ ç§»åŠ¨é€Ÿåº¦
rotationSpeed: 0.003 
};
// åˆå§‹åŒ–åœºæ™¯ 
function init() {
// åˆ›å»ºåœºæ™¯ 
scene = new THREE.Scene(); 
scene.background = new THREE.Color(0xf8f8f8); 
scene.fog = new THREE.Fog(0xf8f8f8, 5, 15);
// åˆ›å»ºç›¸æœº 
camera = new THREE.PerspectiveCamera(
75, window.innerWidth / window.innerHeight, 0.1, 1000 
); 
camera.position.set(0, 1.0, 3);
// åˆ›å»ºæ¸²æŸ“å™¨ 
renderer = new THREE.WebGLRenderer({ antialias: true }); 
renderer.setSize(window.innerWidth, window.innerHeight); 
renderer.shadowMap.enabled = true; 
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.getElementById('canvas-container').appendChild(renderer.domElement);
// åˆ›å»ºå…‰æº 
createLights();
// åˆ›å»ºåœ°æ¿å’Œå¤©èŠ±æ¿ 
createFloorAndCeiling();
// åˆ›å»ºå¤§æ¥¼ 
createBuildings();
// åˆ›å»ºäº¤äº’ 
raycaster = new THREE.Raycaster(); 
mouse = new THREE.Vector2();
// æ·»åŠ äº‹ä»¶ç›‘å¬ 
window.addEventListener('resize', onWindowResize); 
renderer.domElement.addEventListener('click', onMouseClick); 
document.addEventListener('keydown', onKeyDown); 
document.addEventListener('keyup', onKeyUp);
// é¼ æ ‡æ§åˆ¶äº‹ä»¶ 
setupMouseControls();
// è§¦æ‘¸æ§åˆ¶äº‹ä»¶ 
setupTouchControls();
// ç§»åŠ¨æ§åˆ¶æŒ‰é’®äº‹ä»¶ 
setupMovementControls();
// æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡ 
if (isMobileDevice()) {
document.getElementById('control-mode').style.display = 'block';
}
// éšè—åŠ è½½æç¤º
setTimeout(() => {
document.getElementById('loading').style.display = 'none'; 
}, 1000);
// å¼€å§‹åŠ¨ç”»å¾ªç¯ 
animate();
}
// æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡ 
function isMobileDevice() {
return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
}
// è®¾ç½®æ§åˆ¶æ¨¡å¼ 
function setControlMode(mode) {
controlMode = mode; 
const buttons = document.querySelectorAll('.mode-btn'); 
buttons.forEach(btn => btn.classList.remove('active'));
if (mode === 'button') {
buttons[0].classList.add('active'); 
document.getElementById('movement-controls').style.display = 'block';
document.getElementById('touch-move-area').classList.remove('show');
} else {
buttons[1].classList.add('active'); 
document.getElementById('movement-controls').style.display = 'none';
document.getElementById('touch-move-area').classList.add('show');
}
}
// è®¾ç½®é¼ æ ‡æ§åˆ¶ 
function setupMouseControls() {
renderer.domElement.addEventListener('mousedown', (event) => {
if (event.target === renderer.domElement) {
isMouseDown = true; 
mouseX = event.clientX; 
mouseY = event.clientY;
}
});
renderer.domElement.addEventListener('mousemove', (event) => {
if (isMouseDown) {
const deltaX = event.clientX - mouseX; 
const deltaY = event.clientY - mouseY;
// æ—‹è½¬ç›¸æœº 
cameraRotationY -= deltaX * CONFIG.rotationSpeed; 
cameraRotationX -= deltaY * CONFIG.rotationSpeed;
// é™åˆ¶å‚ç›´æ—‹è½¬è§’åº¦ 
cameraRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotationX));
// åº”ç”¨æ—‹è½¬ 
camera.rotation.order = 'YXZ'; 
camera.rotation.y = cameraRotationY; 
camera.rotation.x = cameraRotationX;
mouseX = event.clientX; 
mouseY = event.clientY;
}
});
renderer.domElement.addEventListener('mouseup', () => {
isMouseDown = false; 
});
renderer.domElement.addEventListener('mouseleave', () => {
isMouseDown = false; 
});
}
// è®¾ç½®è§¦æ‘¸æ§åˆ¶ 
function setupTouchControls() {
const canvas = renderer.domElement;
const controlsArea = document.getElementById('movement-controls');
const moveArea = document.getElementById('touch-move-area');
    
canvas.addEventListener('touchstart', (event) => {
if (event.touches.length === 1) {
const touch = event.touches[0];
touchStartX = touch.clientX;
touchStartY = touch.clientY;
isTouching = true;
            
// æ£€æŸ¥æ˜¯å¦åœ¨æ§åˆ¶åŒºåŸŸå†…
const controlsRect = controlsArea.getBoundingClientRect();
if (touch.clientX >= controlsRect.left && 
touch.clientX <= controlsRect.right &&
touch.clientY >= controlsRect.top && 
touch.clientY <= controlsRect.bottom) {
return; // å¦‚æœåœ¨æ§åˆ¶åŒºåŸŸï¼Œä¸å¤„ç†æ—‹è½¬
}
            
// æ£€æŸ¥æ˜¯å¦åœ¨è§¦æ‘¸ç§»åŠ¨åŒºåŸŸå†…
const rect = moveArea.getBoundingClientRect();
if (controlMode === 'touch' &&
touch.clientX >= rect.left && touch.clientX <= rect.right &&
touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
isTouchMoving = true;
touchMoveStartX = touch.clientX;
touchMoveStartY = touch.clientY;
} else {
// æ˜¾ç¤ºæ—‹è½¬æç¤º 
const indicator = document.getElementById('touch-indicator');
indicator.textContent = 'ğŸ‘†æ»‘åŠ¨æ—‹è½¬è§†è§’'; 
indicator.classList.add('show'); 
setTimeout(() => {
indicator.classList.remove('show'); 
}, 2000);
}
}
});
    
canvas.addEventListener('touchmove', (event) => {
if (event.touches.length === 1 && isTouching) {
event.preventDefault(); 
const touch = event.touches[0];
            
if (isTouchMoving) {
// è§¦æ‘¸ç§»åŠ¨æ§åˆ¶ 
const deltaX = touch.clientX - touchMoveStartX; 
const deltaY = touch.clientY - touchMoveStartY;
// æ ¹æ®è§¦æ‘¸ä½ç½®è®¾ç½®ç§»åŠ¨æ–¹å‘ 
moveForward = deltaY < -20; 
moveBackward = deltaY > 20; 
moveLeft = deltaX < -20; 
moveRight = deltaX > 20; 
} else {
// è§¦æ‘¸æ—‹è½¬æ§åˆ¶ 
const deltaX = touch.clientX - touchStartX; 
const deltaY = touch.clientY - touchStartY;
cameraRotationY -= deltaX * CONFIG.rotationSpeed; 
cameraRotationX -= deltaY * CONFIG.rotationSpeed;
cameraRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotationX));
camera.rotation.order = 'YXZ'; 
camera.rotation.y = cameraRotationY; 
camera.rotation.x = cameraRotationX;
touchStartX = touch.clientX; 
touchStartY = touch.clientY;
}
}
});
    
canvas.addEventListener('touchend', () => {
isTouching = false;
isTouchMoving = false;
// åœæ­¢æ‰€æœ‰ç§»åŠ¨ 
moveForward = false; 
moveBackward = false; 
moveLeft = false; 
moveRight = false;
});
}
// åˆ›å»ºå…‰æº 
function createLights() {
// é¡¶éƒ¨æ¡å½¢ç¯ 
for (let i = 0; i < 5; i++) {
const light = new THREE.DirectionalLight(0xffffff, 0.5); 
light.position.set((i - 2) * 2.5, 3.4, 0); 
light.castShadow = true; 
light.shadow.camera.near = 0.1; 
light.shadow.camera.far = 10; 
light.shadow.camera.left = -6; 
light.shadow.camera.right = 6; 
light.shadow.camera.top = 6; 
light.shadow.camera.bottom = -6; 
scene.add(light);
// ç¯å…·æ¨¡å‹ 
const lightGeometry = new THREE.BoxGeometry(2, 0.05, 0.5); 
const lightMaterial = new THREE.MeshBasicMaterial({
color: 0xffffff, 
emissive: 0xffffff, 
emissiveIntensity: 0.8
}); 
const lightMesh = new THREE.Mesh(lightGeometry, lightMaterial);
lightMesh.position.copy(light.position); 
scene.add(lightMesh);
}
// ç¯å¢ƒå…‰ 
const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); 
scene.add(ambientLight);
}
// åˆ›å»ºåœ°æ¿å’Œå¤©èŠ±æ¿ 
function createFloorAndCeiling() {
// ç™½è‰²åœ°æ¿ 
const floorGeometry = new THREE.PlaneGeometry(CONFIG.roomWidth, CONFIG.roomDepth);
const floorMaterial = new THREE.MeshStandardMaterial({
color: 0xffffff, 
roughness: 0.3, 
metalness: 0.1
}); 
const floor = new THREE.Mesh(floorGeometry, floorMaterial); 
floor.rotation.x = -Math.PI / 2; 
floor.position.y = 0; 
floor.receiveShadow = true; 
scene.add(floor);
// ç™½è‰²å¤©èŠ±æ¿ 
const ceilingGeometry = new THREE.PlaneGeometry(CONFIG.roomWidth, CONFIG.roomDepth);
const ceilingMaterial = new THREE.MeshStandardMaterial({
color: 0xffffff, 
roughness: 0.2, 
metalness: 0.0, 
emissive: 0xffffff, 
emissiveIntensity: 0.1 
}); 
const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial); 
ceiling.rotation.x = Math.PI / 2; 
ceiling.position.y = CONFIG.roomHeight; 
scene.add(ceiling);
// æ£•è‰²çº¹ç†å¢™å£ 
createWalls();
}
// åˆ›å»ºæ£•è‰²çº¹ç†å¢™å£ 
function createWalls() {
const canvas = document.createElement('canvas'); 
canvas.width = 512; 
canvas.height = 512; 
const context = canvas.getContext('2d');
// ç»˜åˆ¶æœ¨çº¹ 
const gradient = context.createLinearGradient(0, 0, 512, 0); 
gradient.addColorStop(0, '#8B4513'); 
gradient.addColorStop(0.3, '#A0522D'); 
gradient.addColorStop(0.6, '#8B4513'); 
gradient.addColorStop(1, '#654321'); 
context.fillStyle = gradient; 
context.fillRect(0, 0, 512, 512);
// æ·»åŠ æœ¨çº¹ç»†èŠ‚ 
for (let i = 0; i < 50; i++) {
context.strokeStyle = `rgba(101, 67, 33, ${Math.random() * 0.3})`;
context.lineWidth = Math.random() * 2; 
context.beginPath(); 
context.moveTo(0, Math.random() * 512); 
context.lineTo(512, Math.random() * 512); 
context.stroke();
}
// æ·»åŠ æœ¨èŠ‚ 
for (let i = 0; i < 10; i++) {
const x = Math.random() * 512; 
const y = Math.random() * 512; 
const radius = Math.random() * 20 + 5; 
context.fillStyle = `rgba(139, 69, 19, ${Math.random() * 0.5})`;
context.beginPath();
context.arc(x, y, radius, 0, Math.PI * 2); 
context.fill();
}
const woodTexture = new THREE.CanvasTexture(canvas); 
woodTexture.wrapS = THREE.RepeatWrapping; 
woodTexture.wrapT = THREE.RepeatWrapping; 
woodTexture.repeat.set(2, 2);
const wallMaterial = new THREE.MeshStandardMaterial({
map: woodTexture, 
roughness: 0.8, 
metalness: 0.1 
});
// å‰å¢™ 
const frontWall = new THREE.Mesh(
new THREE.PlaneGeometry(CONFIG.roomWidth, CONFIG.roomHeight),
wallMaterial
); 
frontWall.position.z = -CONFIG.roomDepth / 2; 
frontWall.receiveShadow = true; 
scene.add(frontWall);
// åå¢™ 
const backWall = new THREE.Mesh(
new THREE.PlaneGeometry(CONFIG.roomWidth, CONFIG.roomHeight),
wallMaterial
); 
backWall.position.z = CONFIG.roomDepth / 2; 
backWall.rotation.y = Math.PI; 
backWall.receiveShadow = true; 
scene.add(backWall);
// å·¦å¢™ 
const leftWall = new THREE.Mesh(
new THREE.PlaneGeometry(CONFIG.roomDepth, CONFIG.roomHeight),
wallMaterial
); 
leftWall.position.x = -CONFIG.roomWidth / 2; 
leftWall.rotation.y = Math.PI / 2;
leftWall.receiveShadow = true; 
scene.add(leftWall);
// å³å¢™ 
const rightWall = new THREE.Mesh(
new THREE.PlaneGeometry(CONFIG.roomDepth, CONFIG.roomHeight),
wallMaterial
); 
rightWall.position.x = CONFIG.roomWidth / 2; 
rightWall.rotation.y = -Math.PI / 2; 
rightWall.receiveShadow = true; 
scene.add(rightWall);
}
// åˆ›å»ºå¤§æ¥¼ 
function createBuildings() {
// å·¦ä¾§å¤§æ¥¼ 
for (let i = 0; i < 3; i++) {
createBuilding('left', i);
}
// å³ä¾§å¤§æ¥¼ 
for (let i = 0; i < 3; i++) {
createBuilding('right', i);
}
}
// åˆ›å»ºå•ä¸ªå¤§æ¥¼ 
function createBuilding(side, index) {
const group = new THREE.Group();
// è®¡ç®—ä½ç½® 
const x = side === 'left'
?
-CONFIG.alleyWidth / 2 - CONFIG.buildingDepth / 2 - (index * 1.5)
: CONFIG.alleyWidth / 2 + CONFIG.buildingDepth / 2 + (index * 1.5);
// åˆ›å»ºæ¥¼ä½“ 
const buildingGeometry = new THREE.BoxGeometry(
CONFIG.buildingDepth, 
CONFIG.buildingHeight, 
CONFIG.buildingWidth
); 
const buildingMaterial = new THREE.MeshStandardMaterial({
color: 0xe0e0e0, 
roughness: 0.7, 
metalness: 0.1
}); 
const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
building.castShadow = true; 
building.receiveShadow = true; 
group.add(building);
// åˆ›å»ºæ¥¼å±‚å’Œçª—æˆ· 
for (let floor = 0; floor < CONFIG.floors; floor++) {
const floorY = -CONFIG.buildingHeight / 2 + (floor + 0.5) * (CONFIG.buildingHeight / CONFIG.floors);
// æ¥¼å±‚åˆ†éš”çº¿ 
const floorLine = new THREE.Mesh(
new THREE.BoxGeometry(CONFIG.buildingDepth + 0.01, 0.02, CONFIG.buildingWidth),
new THREE.MeshStandardMaterial({ color: 0xcccccc })
); 
floorLine.position.y = floorY + CONFIG.buildingHeight / (CONFIG.floors * 2);
group.add(floorLine);
// åˆ›å»ºçª—æˆ· 
for (let window = 0; window < CONFIG.windowsPerFloor; window++) {
const windowZ = -CONFIG.buildingWidth / 2 + (window + 0.5) * (CONFIG.buildingWidth / CONFIG.windowsPerFloor);
createMessageBoard(group, side, index, floor, window, x, floorY, windowZ);
}
}
group.position.x = x; 
scene.add(group); 
buildings.push(group);
// æ·»åŠ ç¢°æ’è¾¹ç•Œ 
buildingBounds.push({
minX: x - CONFIG.buildingDepth / 2 - playerRadius,
maxX: x + CONFIG.buildingDepth / 2 + playerRadius, 
minZ: -CONFIG.buildingWidth / 2 - playerRadius, 
maxZ: CONFIG.buildingWidth / 2 + playerRadius 
});
}
// åˆ›å»ºç•™è¨€æ¿ 
function createMessageBoard(group, side, buildingIndex, floor, windowIndex, x, y, z) {
// åˆ›å»ºçª—æ¡† 
const frameGeometry = new THREE.BoxGeometry(
0.02, 
CONFIG.windowSize, 
CONFIG.windowSize
); 
const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 }); 
const frame = new THREE.Mesh(frameGeometry, frameMaterial); 
frame.position.set(
side === 'left' ?
CONFIG.buildingDepth / 2 + 0.01 : -CONFIG.buildingDepth / 2 - 0.01,
y, 
z
); 
group.add(frame);
// åˆ›å»ºç•™è¨€æ¿ 
const boardGeometry = new THREE.PlaneGeometry(CONFIG.windowSize * 0.9, CONFIG.windowSize * 0.9);
const canvas = document.createElement('canvas'); 
canvas.width = 256; 
canvas.height = 256; 
const context = canvas.getContext('2d');
// åˆå§‹åŒ–ç”»å¸ƒ 
context.fillStyle = '#ffffff'; 
context.fillRect(0, 0, 256, 256); 
context.strokeStyle = '#333333'; 
context.lineWidth = 8; 
context.strokeRect(0, 0, 256, 256);
// åŠ è½½å·²ä¿å­˜çš„ç•™è¨€ 
const key = `building_${side}_${buildingIndex}_${floor}_${windowIndex}`;
const savedMessage = localStorage.getItem(key); 
if (savedMessage) {
drawText(context, savedMessage);
}
const texture = new THREE.CanvasTexture(canvas); 
texture.needsUpdate = true;
const boardMaterial = new THREE.MeshBasicMaterial({
map: texture, 
side: THREE.DoubleSide
}); 
const board = new THREE.Mesh(boardGeometry, boardMaterial); 
board.position.copy(frame.position);
// è°ƒæ•´æœå‘ 
if (side === 'left') {
board.rotation.y = -Math.PI / 2; 
} else {
board.rotation.y = Math.PI / 2;
}
board.userData = {
side, 
buildingIndex, 
floor, 
windowIndex, 
canvas, 
context, 
texture, 
key 
}; 
group.add(board); 
messageBoards.push(board);
}
// ç»˜åˆ¶æ–‡å­— 
function drawText(context, text) {
// æ¸…ç©ºç”»å¸ƒ 
context.fillStyle = '#ffffff'; 
context.fillRect(0, 0, 256, 256); 
context.strokeStyle = '#333333'; 
context.lineWidth = 8;
context.strokeRect(0, 0, 256, 256);
// ç»˜åˆ¶æ–‡å­— 
context.fillStyle = '#333333'; 
context.font = 'bold 36px Arial'; 
context.textAlign = 'center'; 
context.textBaseline = 'middle';
// è‡ªåŠ¨æ¢è¡Œ 
const maxWidth = 220; 
const lineHeight = 40; 
const words = text.split(''); 
let line = ''; 
let y = 128;
for (let n = 0; n < words.length; n++) {
const testLine = line + words[n]; 
const metrics = context.measureText(testLine); 
const testWidth = metrics.width;
if (testWidth > maxWidth && n > 0) {
context.fillText(line, 128, y); 
line = words[n]; 
y += lineHeight; 
} else {
line = testLine;
}
} 
context.fillText(line, 128, y);
}
// ç¢°æ’æ£€æµ‹ 
function checkCollision(newPosition) {
// æ£€æŸ¥æˆ¿é—´è¾¹ç•Œ 
const halfWidth = CONFIG.roomWidth / 2 - playerRadius; 
const halfDepth = CONFIG.roomDepth / 2 - playerRadius;
if (newPosition.x < -halfWidth || newPosition.x > halfWidth) return true;
if (newPosition.z < -halfDepth || newPosition.z > halfDepth) return true;
// æ£€æŸ¥å»ºç­‘ç‰©ç¢°æ’ 
for (let bound of buildingBounds) {
if (newPosition.x > bound.minX && newPosition.x < bound.maxX &&
newPosition.z > bound.minZ && newPosition.z < bound.maxZ) {
return true;
}
}
return false;
}
// ä¿®å¤çš„ç§»åŠ¨æ§åˆ¶è®¾ç½®
function setupMovementControls() {
const moveButtons = document.querySelectorAll('.move-btn');
    
moveButtons.forEach(btn => {
// é¼ æ ‡äº‹ä»¶
btn.addEventListener('mousedown', (e) => {
e.preventDefault();
const direction = e.currentTarget.dataset.direction;
activeDirections.add(direction);
updateMovementState();
btn.classList.add('active');
});
        
btn.addEventListener('mouseup', (e) => {
e.preventDefault();
const direction = e.currentTarget.dataset.direction;
activeDirections.delete(direction);
updateMovementState();
btn.classList.remove('active');
});
        
btn.addEventListener('mouseleave', (e) => {
const direction = e.currentTarget.dataset.direction;
activeDirections.delete(direction);
updateMovementState();
btn.classList.remove('active');
});
        
// è§¦æ‘¸äº‹ä»¶ï¼ˆä¿®å¤ç‰ˆï¼‰
btn.addEventListener('touchstart', (e) => {
e.preventDefault();
e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
const direction = e.currentTarget.dataset.direction;
activeDirections.add(direction);
updateMovementState();
btn.classList.add('active');
});
        
btn.addEventListener('touchend', (e) => {
e.preventDefault();
e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
const direction = e.currentTarget.dataset.direction;
activeDirections.delete(direction);
updateMovementState();
btn.classList.remove('active');
});
        
btn.addEventListener('touchcancel', (e) => {
e.preventDefault();
e.stopPropagation();
activeDirections.clear();
updateMovementState();
moveButtons.forEach(b => b.classList.remove('active'));
});
});
    
// æ›´æ–°ç§»åŠ¨çŠ¶æ€
function updateMovementState() {
moveForward = activeDirections.has('forward');
moveBackward = activeDirections.has('backward');
moveLeft = activeDirections.has('left');
moveRight = activeDirections.has('right');
}
}
// é”®ç›˜äº‹ä»¶ 
function onKeyDown(event) {
switch (event.code) {
case 'ArrowUp': 
case 'KeyW':
moveForward = true; 
activeDirections.add('forward');
break; 
case 'ArrowDown': 
case 'KeyS':
moveBackward = true; 
activeDirections.add('backward');
break; 
case 'ArrowLeft': 
case 'KeyA':
moveLeft = true; 
activeDirections.add('left');
break; 
case 'ArrowRight': 
case 'KeyD':
moveRight = true; 
activeDirections.add('right');
break; 
case 'Enter':
if(document.getElementById('message-input-modal').classList.contains('active')) {
saveMessage(); 
} 
break;
case 'Escape':
closeModal(); 
break;
}
}
function onKeyUp(event) {
switch (event.code) {
case 'ArrowUp': 
case 'KeyW':
moveForward = false; 
activeDirections.delete('forward');
break; 
case 'ArrowDown': 
case 'KeyS':
moveBackward = false; 
activeDirections.delete('backward');
break; 
case 'ArrowLeft': 
case 'KeyA':
moveLeft = false; 
activeDirections.delete('left');
break; 
case 'ArrowRight': 
case 'KeyD':
moveRight = false; 
activeDirections.delete('right');
break;
}
}
// ä¿®å¤çš„æ›´æ–°ç§»åŠ¨å‡½æ•°
function updateMovement() {
velocity.x -= velocity.x * 10.0 * 0.016; 
velocity.z -= velocity.z * 10.0 * 0.016;

// è·å–ç›¸æœºæ–¹å‘
const forwardVector = new THREE.Vector3(); 
camera.getWorldDirection(forwardVector); 
forwardVector.y = 0; // ä¿æŒæ°´å¹³ç§»åŠ¨ 
forwardVector.normalize();

const rightVector = new THREE.Vector3(); 
rightVector.crossVectors(forwardVector, new THREE.Vector3(0, 1, 0));

direction.set(0, 0, 0);

// ä¿®å¤æ–¹å‘è®¡ç®—é€»è¾‘
if (moveForward) {
direction.add(forwardVector);
}
if (moveBackward) {
direction.add(forwardVector.clone().multiplyScalar(-1));
}
if (moveLeft) {
direction.add(rightVector.clone().multiplyScalar(-1));
}
if (moveRight) {
direction.add(rightVector);
}

// å½’ä¸€åŒ–æ–¹å‘å‘é‡
if (direction.length() > 0) {
direction.normalize();
velocity.x -= direction.x * CONFIG.moveSpeed; 
velocity.z -= direction.z * CONFIG.moveSpeed;
}

// è®¡ç®—æ–°ä½ç½®
const newPosition = camera.position.clone(); 
newPosition.x += velocity.x; 
newPosition.z += velocity.z;

// ç¢°æ’æ£€æµ‹
if (!checkCollision(newPosition)) {
camera.position.x = newPosition.x; 
camera.position.z = newPosition.z;
}

// æ›´æ–°ä½ç½®æ˜¾ç¤º
document.getElementById('position-text').textContent = 
`X: ${camera.position.x.toFixed(1)}, Z: ${camera.position.z.toFixed(1)}`;
}
// é¼ æ ‡ç‚¹å‡»äº‹ä»¶ 
function onMouseClick(event) {
// å¦‚æœæ­£åœ¨æ‹–æ‹½æˆ–è§¦æ‘¸ï¼Œä¸è§¦å‘ç‚¹å‡» 
if (isMouseDown || isTouching) return;
mouse.x = (event.clientX / window.innerWidth) * 2 - 1; 
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera); 
const intersects = raycaster.intersectObjects(messageBoards);
if (intersects.length > 0) {
selectedBoard = intersects[0].object;
if (event.shiftKey) {
clearSingleMessage(selectedBoard);
} else {
openModal(selectedBoard);
}
}
}
// æ‰“å¼€ç¼–è¾‘æ¨¡æ€æ¡† 
function openModal(board) {
const modal = document.getElementById('message-input-modal'); 
const input = document.getElementById('message-input');
const currentMessage = localStorage.getItem(board.userData.key) || '';
input.value = currentMessage;
modal.classList.add('active'); 
input.focus();
}
// å…³é—­æ¨¡æ€æ¡† 
function closeModal() {
document.getElementById('message-input-modal').classList.remove('active');
selectedBoard = null;
}
// ä¿å­˜ç•™è¨€ 
function saveMessage() {
if (!selectedBoard) return;
const input = document.getElementById('message-input'); 
const text = input.value.trim();
if (text) {
localStorage.setItem(selectedBoard.userData.key, text); 
drawText(selectedBoard.userData.context, text); 
selectedBoard.userData.texture.needsUpdate = true; 
} else {
clearSingleMessage(selectedBoard);
}
closeModal();
}
// æ¸…é™¤å•ä¸ªç•™è¨€ 
function clearSingleMessage(board) {
localStorage.removeItem(board.userData.key); 
drawText(board.userData.context, ''); 
board.userData.texture.needsUpdate = true;
}
// æ¸…é™¤æ‰€æœ‰ç•™è¨€ 
function clearAllMessages() {
if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰ç•™è¨€å—ï¼Ÿ')) {
messageBoards.forEach(board => {
clearSingleMessage(board); 
});
}
}
// æ¸…é™¤å¤§æ¥¼ç•™è¨€ 
function clearBuilding(side) {
if (confirm(`ç¡®å®šè¦æ¸…é™¤${side === 'left' ? 'å·¦ä¾§' : 'å³ä¾§'}å¤§æ¥¼çš„æ‰€æœ‰ç•™è¨€å—ï¼Ÿ`)) {
messageBoards.forEach(board => {
if (board.userData.side === side) {
clearSingleMessage(board); 
}
});
}
}
// é‡ç½®ä½ç½® 
function resetPosition() {
camera.position.set(0, 1.0, 3); 
camera.rotation.set(0, 0, 0); 
cameraRotationX = 0; 
cameraRotationY = 0; 
velocity.set(0, 0, 0);
}
// åˆ‡æ¢æ§åˆ¶é¢æ¿ 
function toggleControls() {
const controls = document.getElementById('mini-controls'); 
const toggleBtn = controls.querySelector('.toggle-btn'); 
const title = document.getElementById('control-title');
controls.classList.toggle('collapsed');
if (controls.classList.contains('collapsed')) {
toggleBtn.textContent = 'â–¶'; 
title.style.display = 'none'; 
} else {
toggleBtn.textContent = 'â—€'; 
title.style.display = 'block';
}
}
// çª—å£å¤§å°è°ƒæ•´ 
function onWindowResize() {
camera.aspect = window.innerWidth / window.innerHeight; 
camera.updateProjectionMatrix(); 
renderer.setSize(window.innerWidth, window.innerHeight);
}
// åŠ¨ç”»å¾ªç¯ 
function animate() {
requestAnimationFrame(animate);
// æ›´æ–°ç§»åŠ¨ 
updateMovement();
// è®©ç•™è¨€æ¿å§‹ç»ˆé¢å‘ç›¸æœº 
messageBoards.forEach(board => {
board.lookAt(camera.position); 
});
// æ¸²æŸ“åœºæ™¯ 
renderer.render(scene, camera);
}
// å¯åŠ¨åº”ç”¨ 
init(); 
</script> 
</body> 
</html>
