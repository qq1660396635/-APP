<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D ç¥ç§˜ç©ºé—´å¯¼èˆª</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
            position: relative;
            touch-action: none;
        }

        #particleCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #threeCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 20px;
            z-index: 1000;
            text-shadow: 0 0 20px #00ffff;
            text-align: center;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 30px;
            color: #fff;
            z-index: 100;
            border: 1px solid rgba(0, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            font-size: 14px;
        }

        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, rgba(0, 100, 200, 0.95), rgba(200, 0, 255, 0.95));
            color: #fff;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 18px;
            z-index: 1000;
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            animation: popIn 0.5s ease forwards;
        }

        @keyframes popIn {
            to {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            z-index: 100;
            pointer-events: none;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 10px #00ffff;
        }

        .crosshair::before {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        .crosshair::after {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .touch-controls {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 200;
        }

        .touch-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid rgba(0, 255, 255, 0.8);
            color: #fff;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-btn:active {
            background: rgba(0, 255, 255, 0.5);
            transform: scale(0.95);
        }

        .button-hint {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            text-align: center;
        }

        .tap-indicator {
            position: fixed;
            width: 60px;
            height: 60px;
            border: 3px solid rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 300;
            animation: tapRipple 0.6s ease-out;
        }

        @keyframes tapRipple {
            from {
                transform: translate(-50%, -50%) scale(0);
                opacity: 1;
            }
            to {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }

        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 768px) {
            .controls {
                font-size: 12px;
                padding: 10px 20px;
            }
            
            .touch-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }

        /* ä¿åº•æ¨¡å¼æ ·å¼ */
        .fallback-mode {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 9999;
            padding: 20px;
            overflow-y: auto;
        }

        .fallback-header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .fallback-header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.3);
        }

        .fallback-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .fallback-button {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 20px;
            text-decoration: none;
            color: #333;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .fallback-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.25);
        }

        .fallback-icon {
            font-size: 2.5rem;
            margin-bottom: 12px;
        }

        .fallback-name {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .fallback-status {
            font-size: 0.85rem;
            color: #666;
        }

        .fallback-disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .fallback-disabled:hover {
            transform: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.15);
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        æ­£åœ¨åŠ è½½ç¥ç§˜ç©ºé—´<br>
        <span style="font-size: 14px;">è¯·ç¨å€™...</span>
    </div>
    
    <!-- ç²’å­èƒŒæ™¯ç”»å¸ƒ -->
    <canvas id="particleCanvas"></canvas>
    
    <!-- Three.js 3Dåœºæ™¯ç”»å¸ƒ -->
    <canvas id="threeCanvas"></canvas>
    
    <div class="crosshair"></div>
    
    <div class="button-hint">
        ğŸ‘† ç‚¹å‡»æŒ‰é’®å–ç‰© | ğŸ‘ˆğŸ‘‰ æ»‘åŠ¨æ—‹è½¬ | ğŸ® ä½¿ç”¨ä¸‹æ–¹æŒ‰é’®è½¬å‘
    </div>
    
    <div class="touch-controls">
        <button class="touch-btn" id="leftBtn">â—€</button>
        <button class="touch-btn" id="rightBtn">â–¶</button>
    </div>
    
    <div class="controls">
        ç‚¹å‡»å¢™å£ä¸Šçš„æŒ‰é’®æ”¶é›†ç‰©å“
    </div>

    <!-- ä¿åº•æ¨¡å¼ -->
    <div class="fallback-mode" id="fallbackMode">
        <div class="fallback-header">
            <h1>ğŸ› ï¸ å·¥å…·å¯¼èˆª</h1>
            <p>3DåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨ç®€æ´æ¨¡å¼</p>
        </div>
        <div class="fallback-grid" id="fallbackGrid"></div>
    </div>

    <script>
        // CDNåŠ è½½æ£€æµ‹
        let threeJSLoaded = false;
        let configLoaded = false;
        let fallbackTimeout;
        
        // å°è¯•åŠ è½½Three.js
        const threeScript = document.createElement('script');
        threeScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
        threeScript.onload = () => {
            threeJSLoaded = true;
            checkResourcesLoaded();
        };
        threeScript.onerror = () => {
            console.error('Three.js CDNåŠ è½½å¤±è´¥');
            checkResourcesLoaded();
        };
        document.head.appendChild(threeScript);
        
        // å°è¯•åŠ è½½é…ç½®æ–‡ä»¶
        const configScript = document.createElement('script');
        configScript.src = 'nav-config.js';
        configScript.onload = () => {
            configLoaded = true;
            checkResourcesLoaded();
        };
        configScript.onerror = () => {
            console.error('é…ç½®æ–‡ä»¶åŠ è½½å¤±è´¥');
            checkResourcesLoaded();
        };
        document.head.appendChild(configScript);
        
        // è®¾ç½®10ç§’è¶…æ—¶
        fallbackTimeout = setTimeout(() => {
            if (!threeJSLoaded || !configLoaded) {
                console.log('CDNåŠ è½½è¶…æ—¶ï¼Œåˆ‡æ¢åˆ°ä¿åº•æ¨¡å¼');
                activateFallbackMode();
            }
        }, 10000);
        
        // æ£€æŸ¥èµ„æºæ˜¯å¦åŠ è½½å®Œæˆ
        function checkResourcesLoaded() {
            if (threeJSLoaded && configLoaded) {
                clearTimeout(fallbackTimeout);
                init3DMode();
            }
        }
        
        // æ¿€æ´»ä¿åº•æ¨¡å¼
        function activateFallbackMode() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('particleCanvas').style.display = 'none';
            document.getElementById('threeCanvas').style.display = 'none';
            document.querySelector('.crosshair').style.display = 'none';
            document.querySelector('.button-hint').style.display = 'none';
            document.querySelector('.touch-controls').style.display = 'none';
            document.querySelector('.controls').style.display = 'none';
            
            const fallbackMode = document.getElementById('fallbackMode');
            fallbackMode.style.display = 'block';
            
            // å¦‚æœé…ç½®æ–‡ä»¶åŠ è½½æˆåŠŸï¼Œä½¿ç”¨é…ç½®æ•°æ®
            if (window.navConfig) {
                renderFallbackButtons();
            } else {
                // ä½¿ç”¨å†…ç½®é»˜è®¤æ•°æ®
                renderDefaultFallbackButtons();
            }
        }
        
        // æ¸²æŸ“ä¿åº•æ¨¡å¼æŒ‰é’®
        function renderFallbackButtons() {
            const grid = document.getElementById('fallbackGrid');
            const allButtons = window.navConfig.getAllButtons();
            
            grid.innerHTML = allButtons.map(button => {
                if (button.path === null) {
                    return `
                        <div class="fallback-button fallback-disabled">
                            <div class="fallback-icon">${button.icon}</div>
                            <div class="fallback-name">${button.name}</div>
                            <div class="fallback-status">åŠŸèƒ½å¼€å‘ä¸­</div>
                        </div>
                    `;
                } else {
                    return `
                        <a href="${button.path}" class="fallback-button">
                            <div class="fallback-icon">${button.icon}</div>
                            <div class="fallback-name">${button.name}</div>
                            <div class="fallback-status">ç‚¹å‡»è¿›å…¥</div>
                        </a>
                    `;
                }
            }).join('');
        }
        
        // æ¸²æŸ“é»˜è®¤ä¿åº•æŒ‰é’®ï¼ˆé…ç½®æ–‡ä»¶åŠ è½½å¤±è´¥æ—¶ï¼‰
        function renderDefaultFallbackButtons() {
            const grid = document.getElementById('fallbackGrid');
            const defaultButtons = [
                { name: 'ä½™é¢ä¿®æ”¹å™¨', path: '3.ç¥ç§˜ç©ºé—´/9_ä½™é¢ä¿®æ”¹å™¨.html', icon: 'ğŸ’°' },
                { name: 'æ¸¸æˆåŠ é€Ÿå™¨', path: '3.ç¥ç§˜ç©ºé—´/10_æ¸¸æˆåŠ é€Ÿå™¨.html', icon: 'ğŸš€' },
                { name: 'æ•°æ®ä¿®æ”¹', path: '3.ç¥ç§˜ç©ºé—´/11_æ•°æ®ä¿®æ”¹.html', icon: 'ğŸ“Š' },
                { name: 'è´¦å·ç®¡ç†', path: '3.ç¥ç§˜ç©ºé—´/12_è´¦å·ç®¡ç†.html', icon: 'ğŸ‘¤' },
                { name: 'VIPç‰¹æƒ', path: '3.ç¥ç§˜ç©ºé—´/13_VIPç‰¹æƒ.html', icon: 'ğŸ‘‘' },
                { name: 'ç ´è§£å·¥å…·', path: '3.ç¥ç§˜ç©ºé—´/14_ç ´è§£å·¥å…·.html', icon: 'ğŸ”“' },
                { name: 'è„šæœ¬ä¸­å¿ƒ', path: '3.ç¥ç§˜ç©ºé—´/15_è„šæœ¬ä¸­å¿ƒ.html', icon: 'ğŸ“œ' },
                { name: 'èµ„æºä¸‹è½½', path: '3.ç¥ç§˜ç©ºé—´/16_èµ„æºä¸‹è½½.html', icon: 'â¬‡ï¸' }
            ];
            
            grid.innerHTML = defaultButtons.map(button => `
                <a href="${button.path}" class="fallback-button">
                    <div class="fallback-icon">${button.icon}</div>
                    <div class="fallback-name">${button.name}</div>
                    <div class="fallback-status">ç‚¹å‡»è¿›å…¥</div>
                </a>
            `).join('');
        }
        
        // ==================== 3Dæ¨¡å¼ ====================
        function init3DMode() {
            // éšè—åŠ è½½æç¤º
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 1000);
            
            // ==================== ç²’å­èƒŒæ™¯ç³»ç»Ÿ ====================
            const particleCanvas = document.getElementById('particleCanvas');
            const particleCtx = particleCanvas.getContext('2d');
            
            function resizeParticleCanvas() {
                particleCanvas.width = window.innerWidth;
                particleCanvas.height = window.innerHeight;
            }
            
            resizeParticleCanvas();
            window.addEventListener('resize', resizeParticleCanvas);
            
            const particles = [];
            const particleCount = 150;
            
            class Particle {
                constructor() {
                    this.reset();
                }
                
                reset() {
                    this.x = Math.random() * particleCanvas.width;
                    this.y = Math.random() * particleCanvas.height;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                    this.radius = Math.random() * 2 + 0.5;
                    this.alpha = Math.random() * 0.5 + 0.2;
                    this.color = `hsl(${Math.random() * 60 + 200}, 70%, 70%)`;
                }
                
                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    if (this.x < 0 || this.x > particleCanvas.width) this.vx *= -1;
                    if (this.y < 0 || this.y > particleCanvas.height) this.vy *= -1;
                    
                    this.alpha -= 0.002;
                    if (this.alpha <= 0) {
                        this.reset();
                    }
                }
                
                draw() {
                    particleCtx.beginPath();
                    particleCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    particleCtx.fillStyle = this.color;
                    particleCtx.globalAlpha = this.alpha;
                    particleCtx.fill();
                    particleCtx.globalAlpha = 1;
                }
            }
            
            // åˆå§‹åŒ–ç²’å­
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }
            
            function animateParticles() {
                particleCtx.fillStyle = 'rgba(12, 12, 24, 0.1)';
                particleCtx.fillRect(0, 0, particleCanvas.width, particleCanvas.height);
                
                // ç»˜åˆ¶è¿æ¥çº¿
                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 100) {
                            particleCtx.beginPath();
                            particleCtx.strokeStyle = `rgba(100, 150, 255, ${0.2 * (1 - distance / 100)})`;
                            particleCtx.lineWidth = 0.5;
                            particleCtx.moveTo(particles[i].x, particles[i].y);
                            particleCtx.lineTo(particles[j].x, particles[j].y);
                            particleCtx.stroke();
                        }
                    }
                }
                
                // æ›´æ–°å’Œç»˜åˆ¶ç²’å­
                particles.forEach(particle => {
                    particle.update();
                    particle.draw();
                });
                
                requestAnimationFrame(animateParticles);
            }
            
            animateParticles();
            
            // ==================== Three.js 3Dåœºæ™¯ ====================
            let scene, camera, renderer;
            let walls = [];
            let buttons = [];
            let raycaster, mouse;
            let targetRotation = 0;
            let currentRotation = 0;
            let isTransitioning = false;
            let touchStartX = 0;
            let touchStartY = 0;

            function initThreeJS() {
                // åˆ›å»ºåœºæ™¯
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x000033, 10, 50);

                // åˆ›å»ºç›¸æœº
                camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                camera.position.set(0, 0, 8);

                // åˆ›å»ºæ¸²æŸ“å™¨
                renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('threeCanvas'),
                    antialias: true,
                    alpha: true 
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.setClearColor(0x000000, 0);

                // æ·»åŠ ç¯å…‰
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                scene.add(ambientLight);

                const pointLight = new THREE.PointLight(0xffffff, 1, 100);
                pointLight.position.set(0, 10, 0);
                pointLight.castShadow = true;
                scene.add(pointLight);

                // åˆ›å»ºæˆ¿é—´
                createRoom();

                // åˆ›å»ºæŒ‰é’®
                createButtons();

                // åˆå§‹åŒ–å°„çº¿æŠ•å°„å™¨
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();

                // ç§»åŠ¨ç«¯äº‹ä»¶ç›‘å¬
                setupMobileControls();

                // çª—å£è°ƒæ•´
                window.addEventListener('resize', onWindowResize);

                // å¼€å§‹åŠ¨ç”»
                animate3D();
            }

            function createRoom() {
                const wallGeometry = new THREE.PlaneGeometry(20, 15);
                
                // åˆ›å»ºæè´¨
                const createWallMaterial = (color) => new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.1,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });

                // å·¦å¢™
                const leftWall = new THREE.Mesh(
                    wallGeometry, 
                    createWallMaterial(0x1a0033)
                );
                leftWall.position.set(-10, 0, 0);
                leftWall.rotation.y = Math.PI / 2;
                leftWall.receiveShadow = true;
                scene.add(leftWall);
                walls.push({ mesh: leftWall, side: 'left' });

                // å‰å¢™
                const frontWall = new THREE.Mesh(
                    wallGeometry, 
                    createWallMaterial(0x001a33)
                );
                frontWall.position.set(0, 0, -10);
                frontWall.receiveShadow = true;
                scene.add(frontWall);
                walls.push({ mesh: frontWall, side: 'front' });

                // å³å¢™
                const rightWall = new THREE.Mesh(
                    wallGeometry, 
                    createWallMaterial(0x1a0033)
                );
                rightWall.position.set(10, 0, 0);
                rightWall.rotation.y = -Math.PI / 2;
                rightWall.receiveShadow = true;
                scene.add(rightWall);
                walls.push({ mesh: rightWall, side: 'right' });

                // åœ°æ¿
                const floorGeometry = new THREE.PlaneGeometry(20, 20);
                const floorMaterial = new THREE.MeshPhongMaterial({
                    color: 0x0a0a0a,
                    emissive: 0x0a0a0a,
                    emissiveIntensity: 0.1,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -7.5;
                floor.receiveShadow = true;
                scene.add(floor);

                // å¤©èŠ±æ¿
                const ceiling = new THREE.Mesh(floorGeometry, floorMaterial);
                ceiling.rotation.x = Math.PI / 2;
                ceiling.position.y = 7.5;
                scene.add(ceiling);

                // æ·»åŠ ç½‘æ ¼çº¿
                const gridHelper = new THREE.GridHelper(20, 20, 0x00ffff, 0x333333);
                gridHelper.position.y = -7.49;
                scene.add(gridHelper);
            }

            function createButtons() {
                walls.forEach(wall => {
                    const buttonData = window.navConfig.getButtonsByWall(wall.side);
                    buttonData.forEach((data, index) => {
                        const button = createInteractiveButton(data, wall.side, index);
                        scene.add(button);
                        buttons.push({
                            mesh: button,
                            data: data,
                            side: wall.side,
                            collected: false  // æ¯æ¬¡åŠ è½½é‡ç½®
                        });
                    });
                });
            }

            function createInteractiveButton(data, side, index) {
                const group = new THREE.Group();

                // æŒ‰é’®åŸºåº§
                const baseGeometry = new THREE.BoxGeometry(1.5, 0.3, 1.5);
                const baseMaterial = new THREE.MeshPhongMaterial({
                    color: 0x333333,
                    emissive: 0x111111,
                    emissiveIntensity: 0.5
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.castShadow = true;
                group.add(base);

                // æŒ‰é’®æ ¸å¿ƒ - æ ¹æ®å¼€å‘çŠ¶æ€å†³å®šé¢œè‰²
                const coreGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const coreColor = data.path === null ? 0x666666 : data.color;
                const coreMaterial = new THREE.MeshPhongMaterial({
                    color: coreColor,
                    emissive: coreColor,
                    emissiveIntensity: data.path === null ? 0.2 : 0.8,
                    transparent: true,
                    opacity: 0.8
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.position.y = 0.5;
                core.castShadow = true;
                group.add(core);

                // å…‰ç¯æ•ˆæœ
                const ringGeometry = new THREE.TorusGeometry(0.8, 0.1, 8, 20);
                const ringMaterial = new THREE.MeshPhongMaterial({
                    color: coreColor,
                    emissive: coreColor,
                    emissiveIntensity: data.path === null ? 0.3 : 1,
                    transparent: true,
                    opacity: data.path === null ? 0.3 : 0.6
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.y = 0.5;
                ring.rotation.x = Math.PI / 2;
                group.add(ring);

                // è®¾ç½®ä½ç½®
                const positions = getButtonPositions(side, index);
                group.position.set(positions.x, positions.y, positions.z);

                // æ·»åŠ è‡ªå®šä¹‰å±æ€§
                group.userData = {
                    core: core,
                    ring: ring,
                    base: base,
                    originalY: positions.y,
                    data: data
                };

                return group;
            }

            function getButtonPositions(side, index) {
                const positions = {
                    left: [
                        { x: -9.5, y: 3, z: -4 },   // 1
                        { x: -9.5, y: 3, z: 0 },    // 2
                        { x: -9.5, y: 3, z: 4 },    // 3
                        { x: -9.5, y: 1, z: -2 },   // 4
                        { x: -9.5, y: 1, z: 2 },    // 5
                        { x: -9.5, y: -1, z: -4 },  // 6
                        { x: -9.5, y: -1, z: 0 },   // 7
                        { x: -9.5, y: -1, z: 4 }    // 8
                    ],
                    front: [
                        { x: -4, y: 3, z: -9.5 },   // 1
                        { x: 0, y: 3, z: -9.5 },    // 2
                        { x: 4, y: 3, z: -9.5 },    // 3
                        { x: -2, y: 1, z: -9.5 },   // 4
                        { x: 2, y: 1, z: -9.5 },    // 5
                        { x: -4, y: -1, z: -9.5 },  // 6
                        { x: 0, y: -1, z: -9.5 },   // 7
                        { x: 4, y: -1, z: -9.5 }    // 8
                    ],
                    right: [
                        { x: 9.5, y: 3, z: -4 },    // 1
                        { x: 9.5, y: 3, z: 0 },     // 2
                        { x: 9.5, y: 3, z: 4 },     // 3
                        { x: 9.5, y: 1, z: -2 },    // 4
                        { x: 9.5, y: 1, z: 2 },     // 5
                        { x: 9.5, y: -1, z: -4 },   // 6
                        { x: 9.5, y: -1, z: 0 },    // 7
                        { x: 9.5, y: -1, z: 4 }     // 8
                    ]
                };

                return positions[side][index];
            }

            function setupMobileControls() {
                // è§¦æ‘¸å¼€å§‹
                document.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    
                    // æ˜¾ç¤ºè§¦æ‘¸æŒ‡ç¤ºå™¨
                    showTapIndicator(touch.clientX, touch.clientY);
                });

                // è§¦æ‘¸ç§»åŠ¨
                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!isTransitioning) {
                        const touch = e.touches[0];
                        const deltaX = touch.clientX - touchStartX;
                        
                        // æ ¹æ®æ»‘åŠ¨è·ç¦»æ—‹è½¬
                        targetRotation += deltaX * 0.01;
                        touchStartX = touch.clientX;
                    }
                });

                // è§¦æ‘¸ç»“æŸ - æ£€æµ‹ç‚¹å‡»
                document.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    const deltaX = Math.abs(touch.clientX - touchStartX);
                    const deltaY = Math.abs(touch.clientY - touchStartY);
                    
                    // å¦‚æœæ»‘åŠ¨è·ç¦»å¾ˆå°ï¼Œè§†ä¸ºç‚¹å‡»
                    if (deltaX < 10 && deltaY < 10) {
                        handleTouchClick(touch.clientX, touch.clientY);
                    }
                });

                // æ–¹å‘æŒ‰é’®æ§åˆ¶
                document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    rotateLeft();
                });

                document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    rotateRight();
                });

                // é¼ æ ‡äº‹ä»¶ï¼ˆæ¡Œé¢ç«¯å…¼å®¹ï¼‰
                document.addEventListener('mousemove', (e) => {
                    if (!isTransitioning) {
                        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                        targetRotation = mouse.x * Math.PI / 6;
                    }
                });

                document.addEventListener('click', (e) => {
                    handleMouseClick(e.clientX, e.clientY);
                });
            }

            function handleTouchClick(x, y) {
                // å°†è§¦æ‘¸åæ ‡è½¬æ¢ä¸ºæ ‡å‡†åŒ–è®¾å¤‡åæ ‡
                mouse.x = (x / window.innerWidth) * 2 - 1;
                mouse.y = -(y / window.innerHeight) * 2 + 1;
                
                checkButtonIntersection();
            }

            function handleMouseClick(x, y) {
                mouse.x = (x / window.innerWidth) * 2 - 1;
                mouse.y = -(y / window.innerHeight) * 2 + 1;
                
                checkButtonIntersection();
            }

            function checkButtonIntersection() {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(buttons.map(b => b.mesh), true);

                if (intersects.length > 0) {
                    const clickedObject = intersects[0].object.parent || intersects[0].object;
                    const button = buttons.find(b => b.mesh === clickedObject);
                    
                    if (button && !button.collected) {
                        collectButton(button);
                    }
                }
            }

            function rotateLeft() {
                if (!isTransitioning) {
                    isTransitioning = true;
                    targetRotation -= Math.PI / 2;
                    setTimeout(() => isTransitioning = false, 500);
                }
            }

            function rotateRight() {
                if (!isTransitioning) {
                    isTransitioning = true;
                    targetRotation += Math.PI / 2;
                    setTimeout(() => isTransitioning = false, 500);
                }
            }

            function collectButton(button) {
                button.collected = true;
                const group = button.mesh;
                const data = group.userData.data;

                // å–ç‰©åŠ¨ç”»
                const duration = 1500;
                const startTime = Date.now();
                const startPos = group.position.clone();
                const endPos = new THREE.Vector3(0, 2, 5);

                function animateCollection() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    
                    // ç§»åŠ¨åˆ°ç›¸æœºå‰
                    group.position.lerpVectors(startPos, endPos, easeProgress);
                    
                    // æ—‹è½¬å’Œç¼©æ”¾
                    group.rotation.y += 0.1;
                    const scale = 1 + Math.sin(progress * Math.PI) * 0.5;
                    group.scale.set(scale, scale, scale);
                    
                    // å‘å…‰æ•ˆæœå¢å¼º
                    group.userData.core.material.emissiveIntensity = 2;
                    group.userData.ring.material.emissiveIntensity = 2;

                    if (progress < 1) {
                        requestAnimationFrame(animateCollection);
                    } else {
                        // æ£€æŸ¥æ˜¯å¦æœ‰è·¯å¾„
                        if (data.path !== null) {
                            // æ˜¾ç¤ºæç¤º
                            showNotification(`æ­£åœ¨è·³è½¬åˆ° ${data.name}...`);
                            
                            // å»¶è¿Ÿè·³è½¬
                            setTimeout(() => {
                                window.location.href = data.path;
                            }, 1000);
                        } else {
                            // æ˜¾ç¤ºå¼€å‘ä¸­æç¤º
                            showNotification(`${data.name} åŠŸèƒ½æ­£åœ¨å¼€å‘ä¸­ï¼`);
                        }
                        
                        // ç§»é™¤æŒ‰é’®
                        scene.remove(group);
                        
                        // æ·»åŠ ç²’å­æ•ˆæœ
                        createCollectEffect(endPos, data.color);
                    }
                }

                animateCollection();
            }

            function createCollectEffect(position, color) {
                const particleCount = 50;
                const particles = new THREE.Group();

                for (let i = 0; i < particleCount; i++) {
                    const geometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const material = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 1
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    
                    particle.position.copy(position);
                    particle.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        Math.random() * 0.2,
                        (Math.random() - 0.5) * 0.2
                    );
                    
                    particles.add(particle);
                }

                scene.add(particles);

                // åŠ¨ç”»ç²’å­
                let opacity = 1;
                function animateParticles() {
                    opacity -= 0.02;
                    
                    particles.children.forEach(particle => {
                        particle.position.add(particle.velocity);
                        particle.velocity.y -= 0.01;
                        particle.material.opacity = opacity;
                    });

                    if (opacity > 0) {
                        requestAnimationFrame(animateParticles);
                    } else {
                        scene.remove(particles);
                    }
                }

                animateParticles();
            }

            function showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.animation = 'popIn 0.5s ease reverse';
                    setTimeout(() => notification.remove(), 500);
                }, 2000);
            }

            function showTapIndicator(x, y) {
                const indicator = document.createElement('div');
                indicator.className = 'tap-indicator';
                indicator.style.left = x + 'px';
                indicator.style.top = y + 'px';
                document.body.appendChild(indicator);

                setTimeout(() => indicator.remove(), 600);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                resizeParticleCanvas();
            }

            function animate3D() {
                requestAnimationFrame(animate3D);

                // å¹³æ»‘æ—‹è½¬
                currentRotation += (targetRotation - currentRotation) * 0.1;
                
                // æ›´æ–°ç›¸æœºä½ç½®
                const radius = 8;
                camera.position.x = Math.sin(currentRotation) * radius;
                camera.position.z = Math.cos(currentRotation) * radius;
                camera.lookAt(0, 0, 0);

                // æŒ‰é’®åŠ¨ç”»
                buttons.forEach(button => {
                    if (!button.collected) {
                        const group = button.mesh;
                        const data = group.userData;
                        
                        // æ‚¬æµ®åŠ¨ç”»
                        data.core.position.y = 0.5 + Math.sin(Date.now() * 0.002) * 0.1;
                        data.ring.rotation.z += 0.02;
                        
                        // å‘å…‰è„‰åŠ¨
                        const intensity = data.data.path === null ? 0.2 : 0.8;
                        const pulseIntensity = intensity + Math.sin(Date.now() * 0.003) * 0.2;
                        data.core.material.emissiveIntensity = pulseIntensity;
                        data.ring.material.emissiveIntensity = pulseIntensity;
                    }
                });

                renderer.render(scene, camera);
            }

            // å¯åŠ¨3Dåº”ç”¨
            initThreeJS();
        }
    </script>
</body>
</html>
