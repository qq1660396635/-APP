<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#2c3e50">
    <title>æ–—å…½æ£‹ - å›½é£ç­–ç•¥æ¸¸æˆ</title>
    <link rel="manifest" href="data:application/json,{%22name%22:%22æ–—å…½æ£‹%22,%22short_name%22:%22æ–—å…½æ£‹%22,%22start_url%22:%22/%22,%22display%22:%22standalone%22,%22background_color%22:%22%23333%22,%22theme_color%22:%22%232c3e50%22}">
    <style>
        :root {
            --board-w: clamp(280px, 90vmin, 560px);
            --piece-sz: calc(var(--board-w) / 9);
            --primary: #8b7355;
            --secondary: #d4a574;
            --accent: #c0392b;
            --text: #2c3e50;
            --bg: #f5e6d3;
            --river: #6bb6d6;
            --trap: #e67e22;
            --den: #27ae60;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --primary: #a08c6d;
                --secondary: #e5b885;
                --text: #ecf0f1;
                --bg: #2c3e50;
                --river: #5499b8;
                --trap: #d35400;
                --den: #229954;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, var(--bg) 0%, var(--secondary) 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* çŠ¶æ€æ  */
        .status-bar {
            height: 32px;
            background: rgba(44, 62, 80, 0.9);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            font-size: 14px;
            backdrop-filter: blur(10px);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .timer {
            font-variant-numeric: tabular-nums;
        }

        /* ä¸»æ¸¸æˆåŒº */
        .game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 16px;
            padding-bottom: 80px;
            position: relative;
        }

        /* æ£‹ç›˜ */
        .board {
            width: var(--board-w);
            aspect-ratio: 7/9;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(9, 1fr);
            gap: 1px;
            background: var(--primary);
            padding: 2px;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .cell {
            background: var(--bg);
            border: 1px solid rgba(139, 115, 85, 0.2);
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .cell:hover {
            background: rgba(212, 165, 116, 0.2);
        }

        .cell.river {
            background: var(--river);
            border-color: var(--river);
        }

        .cell.trap {
            background: linear-gradient(45deg, var(--trap) 25%, transparent 25%, transparent 75%, var(--trap) 75%, var(--trap)),
                        linear-gradient(45deg, var(--trap) 25%, transparent 25%, transparent 75%, var(--trap) 75%, var(--trap));
            background-size: 10px 10px;
            background-position: 0 0, 5px 5px;
            opacity: 0.6;
        }

        .cell.den {
            background: var(--den);
            border: 2px solid var(--den);
        }

        .cell.valid-move {
            background: rgba(46, 204, 113, 0.3);
            animation: pulse 0.8s infinite;
        }

        .cell.can-capture {
            background: rgba(231, 76, 60, 0.3);
            animation: pulse 0.8s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        /* æ£‹å­ */
        .piece {
            position: absolute;
            width: calc(var(--piece-sz) * 0.8);
            height: calc(var(--piece-sz) * 0.8);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: calc(var(--piece-sz) * 0.4);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.12s ease;
            user-select: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .piece.red {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .piece.blue {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .piece.selected {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .piece.captured {
            animation: collapse 0.4s ease-out forwards;
        }

        @keyframes collapse {
            to {
                transform: translate(-50%, -50%) scale(0) rotate(180deg);
                opacity: 0;
            }
        }

        /* æ§åˆ¶æŒ‰é’® */
        .controls {
            position: fixed;
            bottom: 16px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        .btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            background: var(--primary);
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: scale(0.95);
        }

        /* æ–¹å‘èˆµ */
        .dpad {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            width: 176px;
            height: 176px;
            z-index: 100;
        }

        .dpad-btn {
            position: absolute;
            width: 56px;
            height: 56px;
            background: var(--primary);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.1s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .dpad-btn:active {
            background: var(--accent);
            transform: scale(0.95);
        }

        .dpad-up { top: 0; left: 60px; }
        .dpad-down { bottom: 0; left: 60px; }
        .dpad-left { left: 0; top: 60px; }
        .dpad-right { right: 0; top: 60px; }
        .dpad-center {
            top: 60px;
            left: 60px;
            background: var(--secondary);
        }

        /* é¡¶éƒ¨æŒ‰é’® */
        .top-controls {
            position: fixed;
            top: 48px;
            right: 16px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        /* æç¤ºæŒ‰é’® */
        .hint-btn {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 100;
        }

        .hint-btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }

        /* æ¸¸æˆç»“æŸé®ç½© */
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .game-over.show {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .game-over-content {
            background: var(--bg);
            padding: 32px;
            border-radius: 16px;
            text-align: center;
            color: var(--text);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .game-over h2 {
            font-size: 32px;
            margin-bottom: 16px;
        }

        .game-over button {
            margin-top: 16px;
            padding: 12px 24px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .game-over button:hover {
            background: #c0392b;
            transform: scale(1.05);
        }

        /* éŸ³æ•ˆæ§åˆ¶ */
        .sound-toggle {
            position: fixed;
            top: 48px;
            left: 16px;
            width: 40px;
            height: 40px;
            background: var(--primary);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 20px;
            cursor: pointer;
            z-index: 100;
        }

        /* å“åº”å¼é€‚é… */
        @media (max-width: 360px) {
            :root {
                --board-w: 280px;
            }
        }

        /* éœ‡åŠ¨æ•ˆæœ */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .shake {
            animation: shake 0.2s ease;
        }
    </style>
</head>
<body>
    <!-- çŠ¶æ€æ  -->
    <div class="status-bar">
        <div class="status-item">
            <span>å›åˆ: <span id="turn">1</span></span>
        </div>
        <div class="status-item">
            <span>çº¢æ–¹å¼ºåº¦: <span id="red-power">36</span></span>
        </div>
        <div class="status-item timer">
            <span id="timer">15</span>s
        </div>
    </div>

    <!-- éŸ³æ•ˆå¼€å…³ -->
    <button class="sound-toggle" id="soundToggle">ğŸ”‡</button>

    <!-- é¡¶éƒ¨æ§åˆ¶ -->
    <div class="top-controls">
        <button class="btn" id="undoBtn" title="æ‚”æ£‹">â†¶</button>
        <button class="btn" id="drawBtn" title="æ±‚å’Œ">ğŸ¤</button>
        <button class="btn" id="restartBtn" title="é‡æ–°å¼€å§‹">ğŸ”„</button>
    </div>

    <!-- æ¸¸æˆå®¹å™¨ -->
    <div class="game-container">
        <div class="board" id="board"></div>
    </div>

    <!-- æ–¹å‘èˆµ -->
    <div class="dpad">
        <button class="dpad-btn dpad-up" data-dir="up">â†‘</button>
        <button class="dpad-btn dpad-down" data-dir="down">â†“</button>
        <button class="dpad-btn dpad-left" data-dir="left">â†</button>
        <button class="dpad-btn dpad-right" data-dir="right">â†’</button>
        <button class="dpad-btn dpad-center">â—</button>
    </div>

    <!-- æç¤ºæŒ‰é’® -->
    <button class="hint-btn" id="hintBtn">ğŸ’¡ AIæç¤º (5s)</button>

    <!-- æ¸¸æˆç»“æŸé®ç½© -->
    <div class="game-over" id="gameOver">
        <div class="game-over-content">
            <h2 id="winnerText">çº¢æ–¹èƒœåˆ©ï¼</h2>
            <p id="gameStats">ç”¨æ—¶: 10å›åˆ</p>
            <button onclick="game.restart()">å†æ¥ä¸€å±€</button>
        </div>
    </div>

    <script>
// æ¸¸æˆé…ç½®
const BOARD_WIDTH = 7;
const BOARD_HEIGHT = 9;
const ANIMALS = {
    1: { name: 'é¼ ', emoji: 'ğŸ­', strength: 1 },
    2: { name: 'çŒ«', emoji: 'ğŸ±', strength: 2 },
    3: { name: 'ç‹—', emoji: 'ğŸ•', strength: 3 },
    4: { name: 'ç‹¼', emoji: 'ğŸº', strength: 4 },
    5: { name: 'è±¹', emoji: 'ğŸ†', strength: 5 },
    6: { name: 'è™', emoji: 'ğŸ…', strength: 6 },
    7: { name: 'ç‹®', emoji: 'ğŸ¦', strength: 7 },
    8: { name: 'è±¡', emoji: 'ğŸ˜', strength: 8 }
};

// åœ°å½¢å®šä¹‰
const TERRAIN = {
    RIVER: 'river',
    TRAP: 'trap',
    DEN: 'den'
};

// æ¸¸æˆç±»
class JungleChess {
    constructor() {
        this.board = [];
        this.selectedPiece = null;
        this.currentPlayer = 'red';
        this.turn = 1;
        this.moveHistory = [];
        this.soundEnabled = false;
        this.timer = null;
        this.timeLeft = 15;
        this.hintCooldown = false;
        this.init();
    }

    init() {
        this.createBoard();
        this.setupTerrain();
        this.placePieces();
        this.render();
        this.bindEvents();
        this.startTimer();
        this.loadStats();
    }

    createBoard() {
        this.board = [];
        for (let y = 0; y < BOARD_HEIGHT; y++) {
            this.board[y] = [];
            for (let x = 0; x < BOARD_WIDTH; x++) {
                this.board[y][x] = {
                    type: null,
                    piece: null,
                    owner: null
                };
            }
        }
    }

    setupTerrain() {
        // è®¾ç½®æ²³æµ (ä¸­é—´3è¡Œï¼Œç¬¬2-3åˆ—å’Œç¬¬4-5åˆ—)
        for (let y = 3; y <= 5; y++) {
            for (let x = 1; x <= 2; x++) {
                this.board[y][x].type = TERRAIN.RIVER;
            }
            for (let x = 4; x <= 5; x++) {
                this.board[y][x].type = TERRAIN.RIVER;
            }
        }

        // è®¾ç½®é™·é˜±
        // çº¢æ–¹é™·é˜±ï¼ˆåº•éƒ¨ï¼‰
        this.board[8][2].type = TERRAIN.TRAP;
        this.board[8][2].owner = 'red';
        this.board[8][4].type = TERRAIN.TRAP;
        this.board[8][4].owner = 'red';
        this.board[7][3].type = TERRAIN.TRAP;
        this.board[7][3].owner = 'red';

        // è“æ–¹é™·é˜±ï¼ˆé¡¶éƒ¨ï¼‰
        this.board[0][2].type = TERRAIN.TRAP;
        this.board[0][2].owner = 'blue';
        this.board[0][4].type = TERRAIN.TRAP;
        this.board[0][4].owner = 'blue';
        this.board[1][3].type = TERRAIN.TRAP;
        this.board[1][3].owner = 'blue';

        // è®¾ç½®å…½ç©´
        this.board[8][3].type = TERRAIN.DEN;  // çº¢æ–¹å…½ç©´ï¼ˆåº•éƒ¨ï¼‰
        this.board[8][3].owner = 'red';
        this.board[0][3].type = TERRAIN.DEN;  // è“æ–¹å…½ç©´ï¼ˆé¡¶éƒ¨ï¼‰
        this.board[0][3].owner = 'blue';
    }

    placePieces() {
        // çº¢æ–¹åˆå§‹ä½ç½®ï¼ˆåº•éƒ¨ä¸¤è¡Œï¼‰
        const redPositions = [
            {x: 0, y: 8}, {x: 1, y: 8}, {x: 2, y: 8}, {x: 4, y: 8},
            {x: 5, y: 8}, {x: 6, y: 8}, {x: 3, y: 7}, {x: 3, y: 6}
        ];
        const redPieces = this.generateRandomLayout('red');
        
        redPositions.forEach((pos, index) => {
            if (index < redPieces.length) {
                this.board[pos.y][pos.x].piece = redPieces[index];
            }
        });

        // è“æ–¹åˆå§‹ä½ç½®ï¼ˆé¡¶éƒ¨ä¸¤è¡Œï¼‰
        const bluePositions = [
            {x: 0, y: 0}, {x: 1, y: 0}, {x: 2, y: 0}, {x: 4, y: 0},
            {x: 5, y: 0}, {x: 6, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}
        ];
        const bluePieces = this.generateRandomLayout('blue');
        
        bluePositions.forEach((pos, index) => {
            if (index < bluePieces.length) {
                this.board[pos.y][pos.x].piece = bluePieces[index];
            }
        });
    }

    generateRandomLayout(player) {
        const pieces = [1, 2, 3, 4, 5, 6, 7, 8];
        // éšæœºæ‰“ä¹±ä½†ä¿æŒå¹³è¡¡
        for (let i = pieces.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
        }
        return pieces.map(strength => ({
            strength,
            player,
            ...ANIMALS[strength]
        }));
    }

    render() {
        const boardEl = document.getElementById('board');
        boardEl.innerHTML = '';

        for (let y = 0; y < BOARD_HEIGHT; y++) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.x = x;
                cell.dataset.y = y;

                // æ·»åŠ åœ°å½¢ç±»
                if (this.board[y][x].type) {
                    cell.classList.add(this.board[y][x].type);
                }

                // æ·»åŠ æ£‹å­
                const piece = this.board[y][x].piece;
                if (piece) {
                    const pieceEl = document.createElement('div');
                    pieceEl.className = `piece ${piece.player}`;
                    pieceEl.innerHTML = piece.emoji;
                    pieceEl.title = `${piece.name} (${piece.strength})`;
                    cell.appendChild(pieceEl);
                }

                boardEl.appendChild(cell);
            }
        }

        this.updateStatus();
    }

    bindEvents() {
        // æ£‹ç›˜ç‚¹å‡»äº‹ä»¶
        document.getElementById('board').addEventListener('click', (e) => {
            const cell = e.target.closest('.cell');
            if (cell) {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                this.handleCellClick(x, y);
            }
        });

        // æ–¹å‘èˆµäº‹ä»¶
        document.querySelectorAll('.dpad-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const dir = e.target.dataset.dir;
                if (dir && this.selectedPiece) {
                    this.handleDpadMove(dir);
                }
            });
        });

        // æ§åˆ¶æŒ‰é’®äº‹ä»¶
        document.getElementById('restartBtn').addEventListener('click', () => this.restart());
        document.getElementById('undoBtn').addEventListener('click', () => this.undo());
        document.getElementById('drawBtn').addEventListener('click', () => this.requestDraw());
        document.getElementById('hintBtn').addEventListener('click', () => this.showHint());
        document.getElementById('soundToggle').addEventListener('click', () => this.toggleSound());

        // è§¦æ‘¸æ»‘åŠ¨æ”¯æŒ
        let touchStartX = 0;
        let touchStartY = 0;
        
        document.getElementById('board').addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        document.getElementById('board').addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            
            if (Math.abs(dx) > 30 || Math.abs(dy) > 30) {
                if (Math.abs(dx) > Math.abs(dy)) {
                    this.handleDpadMove(dx > 0 ? 'right' : 'left');
                } else {
                    this.handleDpadMove(dy > 0 ? 'down' : 'up');
                }
            }
        });
    }

    handleCellClick(x, y) {
        const cell = this.board[y][x];
        
        if (this.selectedPiece) {
            // å°è¯•ç§»åŠ¨
            if (this.isValidMove(this.selectedPiece.x, this.selectedPiece.y, x, y)) {
                this.movePiece(this.selectedPiece.x, this.selectedPiece.y, x, y);
                this.clearSelection();
            } else if (cell.piece && cell.piece.player === this.currentPlayer) {
                // é€‰æ‹©æ–°æ£‹å­
                this.selectPiece(x, y);
            } else {
                this.clearSelection();
            }
        } else if (cell.piece && cell.piece.player === this.currentPlayer) {
            // é€‰æ‹©æ£‹å­
            this.selectPiece(x, y);
        }
    }

    selectPiece(x, y) {
        this.clearSelection();
        this.selectedPiece = { x, y };
        
        // é«˜äº®é€‰ä¸­çš„æ£‹å­
        const cells = document.querySelectorAll('.cell');
        cells.forEach(cell => {
            const cellX = parseInt(cell.dataset.x);
            const cellY = parseInt(cell.dataset.y);
            
            if (cellX === x && cellY === y) {
                const piece = cell.querySelector('.piece');
                if (piece) piece.classList.add('selected');
            }
            
            // æ˜¾ç¤ºå¯ç§»åŠ¨ä½ç½®
            if (this.isValidMove(x, y, cellX, cellY)) {
                if (this.board[cellY][cellX].piece) {
                    cell.classList.add('can-capture');
                } else {
                    cell.classList.add('valid-move');
                }
            }
        });
    }

    clearSelection() {
        this.selectedPiece = null;
        document.querySelectorAll('.piece.selected').forEach(p => p.classList.remove('selected'));
        document.querySelectorAll('.cell.valid-move, .cell.can-capture').forEach(c => {
            c.classList.remove('valid-move', 'can-capture');
        });
    }

    handleDpadMove(direction) {
        if (!this.selectedPiece) return;
        
        let newX = this.selectedPiece.x;
        let newY = this.selectedPiece.y;
        
        switch(direction) {
            case 'up': newY--; break;
            case 'down': newY++; break;
            case 'left': newX--; break;
            case 'right': newX++; break;
        }
        
        if (newX >= 0 && newX < BOARD_WIDTH && newY >= 0 && newY < BOARD_HEIGHT) {
            if (this.isValidMove(this.selectedPiece.x, this.selectedPiece.y, newX, newY)) {
                this.movePiece(this.selectedPiece.x, this.selectedPiece.y, newX, newY);
                this.clearSelection();
            }
        }
    }

    isValidMove(fromX, fromY, toX, toY) {
        // æ£€æŸ¥è¾¹ç•Œ
        if (toX < 0 || toX >= BOARD_WIDTH || toY < 0 || toY >= BOARD_HEIGHT) {
            return false;
        }

        const fromCell = this.board[fromY][fromX];
        const toCell = this.board[toY][toX];
        const piece = fromCell.piece;

        if (!piece) return false;

        // ä¸èƒ½åƒè‡ªå·±çš„æ£‹å­
        if (toCell.piece && toCell.piece.player === piece.player) {
            return false;
        }

        // ä¸èƒ½è¿›å…¥è‡ªå·±çš„å…½ç©´ï¼ˆå…³é”®ä¿®æ­£ï¼‰
        if (toCell.type === TERRAIN.DEN && toCell.owner === piece.player) {
            return false;
        }

        // æ£€æŸ¥ç§»åŠ¨è·ç¦»
        const dx = Math.abs(toX - fromX);
        const dy = Math.abs(toY - fromY);

        // ç‹®è™è·³æ²³
        if ((piece.strength === 7 || piece.strength === 6) && 
            fromCell.type !== TERRAIN.RIVER) {
            if (dx === 0 && dy > 1 && dy <= 3) {
                // å‚ç›´è·³æ²³
                const minY = Math.min(fromY, toY);
                const maxY = Math.max(fromY, toY);
                let canJump = true;
                
                for (let y = minY + 1; y < maxY; y++) {
                    if (this.board[y][fromX].type !== TERRAIN.RIVER || 
                        this.board[y][fromX].piece) {
                        canJump = false;
                        break;
                    }
                }
                
                if (canJump && this.board[toY][toX].type === TERRAIN.RIVER) {
                    return false; // ä¸èƒ½è·³åˆ°æ²³é‡Œ
                }
                
                return canJump;
            } else if (dy === 0 && dx > 1 && dx <= 3) {
                // æ°´å¹³è·³æ²³
                const minX = Math.min(fromX, toX);
                const maxX = Math.max(fromX, toX);
                let canJump = true;
                
                for (let x = minX + 1; x < maxX; x++) {
                    if (this.board[fromY][x].type !== TERRAIN.RIVER || 
                        this.board[fromY][x].piece) {
                        canJump = false;
                        break;
                    }
                }
                
                if (canJump && this.board[toY][toX].type === TERRAIN.RIVER) {
                    return false; // ä¸èƒ½è·³åˆ°æ²³é‡Œ
                }
                
                return canJump;
            }
        }

        // æ™®é€šç§»åŠ¨ï¼ˆåªèƒ½ç§»åŠ¨ä¸€æ ¼ï¼‰
        if (dx + dy !== 1) {
            return false;
        }

        // å¤§è±¡ä¸èƒ½è¿›æ²³
        if (piece.strength === 8 && toCell.type === TERRAIN.RIVER) {
            return false;
        }

        // åªæœ‰è€é¼ å¯ä»¥è¿›æ²³
        if (toCell.type === TERRAIN.RIVER && piece.strength !== 1) {
            return false;
        }

        // æ²³é‡Œçš„è€é¼ ä¸èƒ½åƒå²¸ä¸Šçš„å¤§è±¡
        if (fromCell.type === TERRAIN.RIVER && piece.strength === 1 && 
            toCell.piece && toCell.piece.strength === 8) {
            return false;
        }

        // æ£€æŸ¥åƒå­è§„åˆ™
        if (toCell.piece) {
            return this.canCapture(piece, toCell.piece, toCell);
        }

        return true;
    }

    canCapture(attacker, defender, defenderCell) {
        // åœ¨é™·é˜±ä¸­çš„æ£‹å­æˆ˜æ–—åŠ›ä¸º0
        if (defenderCell.type === TERRAIN.TRAP && defenderCell.owner !== defender.player) {
            return true;
        }

        // è€é¼ å¯ä»¥åƒå¤§è±¡
        if (attacker.strength === 1 && defender.strength === 8) {
            return true;
        }

        // å¤§è±¡ä¸èƒ½åƒè€é¼ 
        if (attacker.strength === 8 && defender.strength === 1) {
            return false;
        }

        // æ™®é€šåƒå­è§„åˆ™
        return attacker.strength >= defender.strength;
    }

    movePiece(fromX, fromY, toX, toY) {
        const fromCell = this.board[fromY][fromX];
        const toCell = this.board[toY][toX];
        const piece = fromCell.piece;

        // ä¿å­˜å†å²
        this.moveHistory.push({
            from: { x: fromX, y: fromY },
            to: { x: toX, y: toY },
            piece: piece,
            captured: toCell.piece,
            turn: this.turn
        });

        // å¤„ç†åƒå­åŠ¨ç”»
        if (toCell.piece) {
            const toCellEl = document.querySelector(`.cell[data-x="${toX}"][data-y="${toY}"]`);
            const pieceEl = toCellEl.querySelector('.piece');
            if (pieceEl) {
                pieceEl.classList.add('captured');
                this.playSound('capture');
            }
        } else {
            this.playSound('move');
        }

        // ç§»åŠ¨æ£‹å­
        toCell.piece = piece;
        fromCell.piece = null;

        // æ£€æŸ¥èƒœåˆ©æ¡ä»¶ï¼ˆä¿®æ­£ï¼šè¿›å…¥å¯¹æ–¹å…½ç©´æ‰ç®—èµ¢ï¼‰
        if (this.checkWin(toX, toY)) {
            this.endGame(this.currentPlayer);
            return;
        }

        // åˆ‡æ¢ç©å®¶
        this.currentPlayer = this.currentPlayer === 'red' ? 'blue' : 'red';
        this.turn++;
        this.resetTimer();
        
        // AIç§»åŠ¨
        if (this.currentPlayer === 'blue') {
            setTimeout(() => this.aiMove(), 500);
        }

        this.render();
    }

    checkWin(x, y) {
        const cell = this.board[y][x];
        const piece = cell.piece;
        
        // åªæœ‰è¿›å…¥å¯¹æ–¹å…½ç©´æ‰ç®—èƒœåˆ©ï¼ˆå…³é”®ä¿®æ­£ï¼‰
        if (cell.type === TERRAIN.DEN && cell.owner !== piece.player) {
            return true;
        }
        
        // æ¶ˆç­æ‰€æœ‰å¯¹æ–¹æ£‹å­ä¹Ÿç®—èƒœåˆ©
        let enemyPieces = 0;
        for (let row of this.board) {
            for (let c of row) {
                if (c.piece && c.piece.player !== piece.player) {
                    enemyPieces++;
                }
            }
        }
        return enemyPieces === 0;
    }

    aiMove() {
        const bestMove = this.minimax(3, true, -Infinity, Infinity);
        if (bestMove.move) {
            this.movePiece(bestMove.move.from.x, bestMove.move.from.y, 
                          bestMove.move.to.x, bestMove.move.to.y);
        }
    }

    minimax(depth, isMaximizing, alpha, beta) {
        if (depth === 0) {
            return { score: this.evaluateBoard() };
        }

        const player = isMaximizing ? 'blue' : 'red';
        let bestMove = null;
        let bestScore = isMaximizing ? -Infinity : Infinity;

        // è·å–æ‰€æœ‰å¯èƒ½çš„ç§»åŠ¨
        const moves = this.getAllPossibleMoves(player);

        for (let move of moves) {
            // æ¨¡æ‹Ÿç§»åŠ¨
            const originalPiece = this.board[move.to.y][move.to.x].piece;
            this.board[move.to.y][move.to.x].piece = this.board[move.from.y][move.from.x].piece;
            this.board[move.from.y][move.from.x].piece = null;

            // é€’å½’è¯„ä¼°
            const result = this.minimax(depth - 1, !isMaximizing, alpha, beta);

            // æ¢å¤æ£‹ç›˜
            this.board[move.from.y][move.from.x].piece = this.board[move.to.y][move.to.x].piece;
            this.board[move.to.y][move.to.x].piece = originalPiece;

            if (isMaximizing) {
                if (result.score > bestScore) {
                    bestScore = result.score;
                    bestMove = move;
                }
                alpha = Math.max(alpha, bestScore);
            } else {
                if (result.score < bestScore) {
                    bestScore = result.score;
                    bestMove = move;
                }
                beta = Math.min(beta, bestScore);
            }

            if (beta <= alpha) {
                break; // Alpha-betaå‰ªæ
            }
        }

        return { score: bestScore, move: bestMove };
    }

    getAllPossibleMoves(player) {
        const moves = [];
        
        for (let y = 0; y < BOARD_HEIGHT; y++) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
                const piece = this.board[y][x].piece;
                if (piece && piece.player === player) {
                    // æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„ç§»åŠ¨
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (Math.abs(dx) + Math.abs(dy) === 1) {
                                const newX = x + dx;
                                const newY = y + dy;
                                if (this.isValidMove(x, y, newX, newY)) {
                                    moves.push({
                                        from: { x, y },
                                        to: { x: newX, y: newY }
                                    });
                                }
                            }
                        }
                    }
                    
                    // æ£€æŸ¥ç‹®è™è·³æ²³
                    if (piece.strength === 7 || piece.strength === 6) {
                        // å‚ç›´è·³æ²³
                        for (let jump = 2; jump <= 3; jump++) {
                            const newY = y + (piece.player === 'blue' ? jump : -jump);
                            if (this.isValidMove(x, y, x, newY)) {
                                moves.push({
                                    from: { x, y },
                                    to: { x, y: newY }
                                });
                            }
                        }
                        // æ°´å¹³è·³æ²³
                        for (let jump = 2; jump <= 3; jump++) {
                            if (x - jump >= 0 && this.isValidMove(x, y, x - jump, y)) {
                                moves.push({
                                    from: { x, y },
                                    to: { x: x - jump, y }
                                });
                            }
                            if (x + jump < BOARD_WIDTH && this.isValidMove(x, y, x + jump, y)) {
                                moves.push({
                                    from: { x, y },
                                    to: { x: x + jump, y }
                                });
                            }
                        }
                    }
                }
            }
        }
        
        return moves;
    }

    evaluateBoard() {
        let score = 0;
        
        for (let y = 0; y < BOARD_HEIGHT; y++) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
                const piece = this.board[y][x].piece;
                if (piece) {
                    let value = piece.strength * 10;
                    
                    // ä½ç½®ä»·å€¼
                    if (piece.player === 'blue') {
                        value += (8 - y) * 2; // è¶Šé è¿‘å¯¹æ–¹è¶Šå¥½
                        // è¿›å…¥å¯¹æ–¹å…½ç©´çš„å·¨å¤§å¥–åŠ±
                        if (this.board[y][x].type === TERRAIN.DEN && 
                            this.board[y][x].owner === 'red') {
                            value += 1000;
                        }
                    } else {
                        value += y * 2;
                        // è¿›å…¥å¯¹æ–¹å…½ç©´çš„å·¨å¤§å¥–åŠ±
                        if (this.board[y][x].type === TERRAIN.DEN && 
                            this.board[y][x].owner === 'blue') {
                            value += 1000;
                        }
                    }
                    
                    score += piece.player === 'blue' ? value : -value;
                }
            }
        }
        
        return score;
    }

    showHint() {
        if (this.hintCooldown || this.currentPlayer !== 'red') return;
        
        const bestMove = this.minimax(2, true, -Infinity, Infinity);
        if (bestMove.move) {
            this.selectPiece(bestMove.move.from.x, bestMove.move.from.y);
            setTimeout(() => {
                const toCell = document.querySelector(
                    `.cell[data-x="${bestMove.move.to.x}"][data-y="${bestMove.move.to.y}"]`
                );
                if (toCell) {
                    toCell.classList.add('shake');
                    setTimeout(() => toCell.classList.remove('shake'), 200);
                }
            }, 300);
        }
        
        // å†·å´æ—¶é—´
        this.hintCooldown = true;
        const btn = document.getElementById('hintBtn');
        btn.disabled = true;
        let countdown = 5;
        btn.textContent = `ğŸ’¡ AIæç¤º (${countdown}s)`;
        
        const interval = setInterval(() => {
            countdown--;
            btn.textContent = `ğŸ’¡ AIæç¤º (${countdown}s)`;
            if (countdown <= 0) {
                clearInterval(interval);
                this.hintCooldown = false;
                btn.disabled = false;
                btn.textContent = 'ğŸ’¡ AIæç¤º (5s)';
            }
        }, 1000);
    }

    undo() {
        if (this.moveHistory.length === 0) return;
        
        const lastMove = this.moveHistory.pop();
        this.board[lastMove.from.y][lastMove.from.x].piece = lastMove.piece;
        this.board[lastMove.to.y][lastMove.to.x].piece = lastMove.captured;
        
        this.currentPlayer = this.currentPlayer === 'red' ? 'blue' : 'red';
        this.turn = lastMove.turn;
        
        this.render();
        this.playSound('move');
    }

    requestDraw() {
        if (confirm('å¯¹æ–¹è¯·æ±‚å’Œæ£‹ï¼Œæ˜¯å¦åŒæ„ï¼Ÿ')) {
            this.endGame('draw');
        }
    }

    restart() {
        this.board = [];
        this.selectedPiece = null;
        this.currentPlayer = 'red';
        this.turn = 1;
        this.moveHistory = [];
        this.init();
        document.getElementById('gameOver').classList.remove('show');
    }

    endGame(winner) {
        clearInterval(this.timer);
        
        const gameOverEl = document.getElementById('gameOver');
        const winnerText = document.getElementById('winnerText');
        const gameStats = document.getElementById('gameStats');
        
        if (winner === 'draw') {
            winnerText.textContent = 'å’Œæ£‹ï¼';
        } else {
            winnerText.textContent = winner === 'red' ? 'çº¢æ–¹èƒœåˆ©ï¼' : 'è“æ–¹èƒœåˆ©ï¼';
        }
        
        gameStats.textContent = `ç”¨æ—¶: ${this.turn}å›åˆ`;
        gameOverEl.classList.add('show');
        
        // ä¿å­˜ç»Ÿè®¡
        this.saveStats(winner);
        
        // éœ‡åŠ¨æ•ˆæœ
        if (navigator.vibrate) {
            navigator.vibrate(200);
        }
        
        this.playSound('win');
    }

    updateStatus() {
        document.getElementById('turn').textContent = this.turn;
        
        // è®¡ç®—å‰©ä½™å¼ºåº¦
        let redPower = 0;
        for (let row of this.board) {
            for (let cell of row) {
                if (cell.piece && cell.piece.player === 'red') {
                    redPower += cell.piece.strength;
                }
            }
        }
        document.getElementById('red-power').textContent = redPower;
    }

    startTimer() {
        this.timeLeft = 15;
        this.updateTimer();
        
        this.timer = setInterval(() => {
            this.timeLeft--;
            this.updateTimer();
            
            if (this.timeLeft <= 0) {
                // è¶…æ—¶è‡ªåŠ¨éšæœºç§»åŠ¨
                this.randomMove();
            }
        }, 1000);
    }

    resetTimer() {
        clearInterval(this.timer);
        this.startTimer();
    }

    updateTimer() {
        document.getElementById('timer').textContent = this.timeLeft;
        if (this.timeLeft <= 5) {
            document.getElementById('timer').style.color = '#e74c3c';
        } else {
            document.getElementById('timer').style.color = 'white';
        }
    }

    randomMove() {
        const moves = this.getAllPossibleMoves(this.currentPlayer);
        if (moves.length > 0) {
            const randomMove = moves[Math.floor(Math.random() * moves.length)];
            this.movePiece(randomMove.from.x, randomMove.from.y, 
                          randomMove.to.x, randomMove.to.y);
        }
    }

    toggleSound() {
        this.soundEnabled = !this.soundEnabled;
        document.getElementById('soundToggle').textContent = this.soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
    }

    playSound(type) {
        if (!this.soundEnabled) return;
        
        // ä½¿ç”¨Web Audio APIåˆ›å»ºç®€å•éŸ³æ•ˆ
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        switch(type) {
            case 'move':
                oscillator.frequency.value = 440;
                gainNode.gain.value = 0.1;
                break;
            case 'capture':
                oscillator.frequency.value = 220;
                gainNode.gain.value = 0.2;
                break;
            case 'win':
                oscillator.frequency.value = 880;
                gainNode.gain.value = 0.3;
                break;
        }
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.1);
    }

    saveStats(winner) {
        const stats = JSON.parse(localStorage.getItem('jungleChessStats') || '{}');
        stats.games = (stats.games || 0) + 1;
        
        if (winner === 'red') {
            stats.wins = (stats.wins || 0) + 1;
            stats.currentStreak = (stats.currentStreak || 0) + 1;
            stats.maxStreak = Math.max(stats.maxStreak || 0, stats.currentStreak);
        } else if (winner === 'draw') {
            stats.draws = (stats.draws || 0) + 1;
            stats.currentStreak = 0;
        } else {
            stats.currentStreak = 0;
        }
        
        stats.shortestGame = Math.min(stats.shortestGame || Infinity, this.turn);
        
        localStorage.setItem('jungleChessStats', JSON.stringify(stats));
    }

    loadStats() {
        const stats = JSON.parse(localStorage.getItem('jungleChessStats') || '{}');
        console.log('æ¸¸æˆç»Ÿè®¡:', stats);
    }
}

// åˆå§‹åŒ–æ¸¸æˆ
const game = new JungleChess();

// PWAå®‰è£…æç¤º
if ('serviceWorker' in navigator) {
    window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        // å¯ä»¥åœ¨è¿™é‡Œæ˜¾ç¤ºå®‰è£…æç¤º
    });
}

// é˜²æ­¢åŒå‡»ç¼©æ”¾
let lastTouchEnd = 0;
document.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) {
        e.preventDefault();
    }
    lastTouchEnd = now;
}, false);

    </script>
</body>
</html>
