<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‰∏≠ÂõΩË±°Ê£ã</title>
    <style id="dynamicStyles"></style>
</head>
<body>
    <!-- Ê®°ÂºèÈÄâÊã©ÁïåÈù¢ -->
    <div class="mode-selection" id="modeSelection">
        <div class="mode-box">
            <h2>ÈÄâÊã©Ê∏∏ÊàèÊ®°Âºè</h2>
            <button class="mode-button" onclick="startGame('pvp')">Âèå‰∫∫ÂØπÊàò</button>
            <button class="mode-button" onclick="startGame('ai')">AIÂØπÊàò</button>
        </div>
    </div>

    <!-- Ê∏∏Êàè‰∏ªÁïåÈù¢ -->
    <div class="game-container">
        <h1>‰∏≠ÂõΩË±°Ê£ã</h1>
        
        <!-- Ê£ãÁõòÂå∫Âüü -->
        <div class="board" id="board">
            <div class="board-lines">
                <!-- Ê®™Á∫ø -->
                <div class="horizontal-line" style="top: 0%;"></div>
                <div class="horizontal-line" style="top: 10%;"></div>
                <div class="horizontal-line" style="top: 20%;"></div>
                <div class="horizontal-line" style="top: 30%;"></div>
                <div class="horizontal-line" style="top: 40%;"></div>
                <div class="horizontal-line" style="top: 50%;"></div>
                <div class="horizontal-line" style="top: 60%;"></div>
                <div class="horizontal-line" style="top: 70%;"></div>
                <div class="horizontal-line" style="top: 80%;"></div>
                <div class="horizontal-line" style="top: 90%;"></div>
                <div class="horizontal-line" style="top: 100%;"></div>
                
                <!-- Á´ñÁ∫ø -->
                <div class="vertical-line" style="left: 0%;"></div>
                <div class="vertical-line" style="left: 12.5%;"></div>
                <div class="vertical-line" style="left: 25%;"></div>
                <div class="vertical-line" style="left: 37.5%;"></div>
                <div class="vertical-line" style="left: 50%;"></div>
                <div class="vertical-line" style="left: 62.5%;"></div>
                <div class="vertical-line" style="left: 75%;"></div>
                <div class="vertical-line" style="left: 87.5%;"></div>
                <div class="vertical-line" style="left: 100%;"></div>
                
                <!-- Ê•öÊ≤≥Ê±âÁïå -->
                <div class="river"></div>
                
                <!-- ‰πùÂÆ´Ê†ºÊñúÁ∫ø -->
                <div class="diagonal" style="left: 37.5%; top: 0%; transform: rotate(45deg);"></div>
                <div class="diagonal" style="left: 87.5%; top: 0%; transform: rotate(-45deg);"></div>
                <div class="diagonal" style="left: 37.5%; top: 75%; transform: rotate(-45deg);"></div>
                <div class="diagonal" style="left: 87.5%; top: 75%; transform: rotate(45deg);"></div>
            </div>
        </div>
        
        <!-- ÊéßÂà∂ÊåâÈíÆÂå∫Âüü -->
        <div class="controls">
            <button id="resetBtn" onclick="resetGame()">ÈáçÊñ∞ÂºÄÂßã</button>
            <button id="rulesBtn" onclick="showRules()">ËßÑÂàôËØ¥Êòé</button>
            <button id="undoBtn" onclick="undoMove()">ÊÇîÊ£ã</button>
            <button id="hintBtn" onclick="getHint()">ÊèêÁ§∫Ëµ∞Ê≥ï</button>
        </div>
        
        <!-- Áä∂ÊÄÅÊòæÁ§∫Âå∫Âüü -->
        <div class="status">
            ÂΩìÂâçÁé©ÂÆ∂Ôºö<span id="currentPlayer" class="current-player">Á∫¢Êñπ</span>
            <span id="gameMode" style="margin-left: 20px; color: #666;"></span>
        </div>
        
        <!-- ÊèêÁ§∫‰ø°ÊÅØÂå∫Âüü -->
        <div class="hint-text" id="hintText"></div>
        
        <!-- Ëµ∞Ê£ãËÆ∞ÂΩïÂå∫Âüü -->
        <div class="move-history" id="moveHistory">
            <h4>Ëµ∞Ê£ãËÆ∞ÂΩï</h4>
            <div id="moveList"></div>
        </div>
    </div>

    <!-- ËÉåÊôØÂàáÊç¢ÊåâÈíÆ -->
    <button id="bgChangeBtn" onclick="changeBackground()" title="ÂàáÊç¢ËÉåÊôØ">üé®</button>

    <script>
        // ‰∏Ä. ÈÖçÁΩÆÂèòÈáè
        const CONFIG = {
            // 1. Ê£ãÁõòÈÖçÁΩÆ
            BOARD_WIDTH: 9,
            BOARD_HEIGHT: 10,
            
            // 2. Ê£ãÂ≠êÁ±ªÂûã
            PIECE_TYPES: {
                SHUAI: 'Â∏Ö', SHI: 'Â£´', XIANG: 'Áõ∏', MA: 'È©¨',
                JU: 'ËΩ¶', PAO: 'ÁÇÆ', BING: 'ÂÖµ'
            },
            
            // 3. ËÉåÊôØÈ¢úËâ≤ÈÖçÁΩÆ
            BACKGROUNDS: [
                'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                'linear-gradient(135deg, #30cfd0 0%, #330867 100%)',
                'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
                'linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%)',
                'linear-gradient(135deg, #fbc2eb 0%, #a6c1ee 100%)',
                'linear-gradient(135deg, #fdcbf1 0%, #e6dee9 100%)'
            ],
            
            // 4. Ê£ãÂ≠ê‰ª∑ÂÄº
            PIECE_VALUES: {
                'ÂÖµ': 10, 'Âçí': 10, 'ÁÇÆ': 30, 'È©¨': 30, 'Áõ∏': 20, 'Ë±°': 20,
                'Â£´': 20, '‰ªï': 20, 'ËΩ¶': 50, 'Ëªä': 50, 'Â∏Ö': 1000, 'Â∞Ü': 1000
            },
            
            // 5. CSSÊ†∑ÂºèÊ®°Êùø
            CSS_TEMPLATE: `
                /* Âü∫Á°ÄÊ†∑Âºè */
                body {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    min-height: 100vh;
                    margin: 0;
                    padding: 10px;
                    background: {{BACKGROUND}};
                    font-family: Arial, sans-serif;
                    box-sizing: border-box;
                }
                .game-container {
                    text-align: center;
                    max-width: 100vw;
                    overflow-x: auto;
                }
                
                /* Ê®°ÂºèÈÄâÊã©ÂºπÁ™ó */
                .mode-selection {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0,0,0,0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                }
                .mode-box {
                    background-color: white;
                    padding: 30px;
                    border-radius: 10px;
                    box-shadow: 0 0 20px rgba(0,0,0,0.5);
                    max-width: 90vw;
                }
                .mode-box h2 {
                    margin-bottom: 20px;
                    color: #8b4513;
                }
                .mode-button {
                    display: block;
                    width: 200px;
                    margin: 10px auto;
                    padding: 15px;
                    font-size: 18px;
                    background-color: #8b4513;
                    color: white;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                }
                .mode-button:hover {
                    background-color: #a0522d;
                }
                
                /* Ê£ãÁõòÊ†∑Âºè */
                .board {
                    position: relative;
                    width: 90vw;
                    max-width: 600px;
                    height: calc(90vw * 1.1);
                    max-height: 660px;
                    background-color: #f9d4b4;
                    border: 3px solid #8b4513;
                    margin: 20px auto;
                    box-shadow: 0 0 20px rgba(0,0,0,0.3);
                }
                @media (min-width: 768px) {
                    .board {
                        width: 600px;
                        height: 660px;
                    }
                }
                
                /* Ê£ãÂ≠êÊ†∑Âºè */
                .piece {
                    position: absolute;
                    border-radius: 50%;
                    font-weight: bold;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    z-index: 10;
                    user-select: none;
                }
                .piece.red {
                    background: radial-gradient(circle at 30% 30%, #ff6b6b, #cc0000);
                    color: #fff;
                    border: 2px solid #990000;
                    box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                }
                .piece.black {
                    background: radial-gradient(circle at 30% 30%, #666, #000);
                    color: #fff;
                    border: 2px solid #000;
                    box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                }
                .piece.selected {
                    transform: scale(1.1);
                    box-shadow: 0 0 20px #ffff00, 2px 2px 4px rgba(0,0,0,0.3);
                    border-color: #ffff00;
                }
                .piece.hint {
                    animation: pulse 1s infinite;
                }
                @keyframes pulse {
                    0% { transform: scale(1); }
                    50% { transform: scale(1.15); }
                    100% { transform: scale(1); }
                }
                
                /* Ê£ãÁõòÁΩëÊ†ºÊ†∑Âºè */
                .grid {
                    position: absolute;
                    cursor: pointer;
                    z-index: 1;
                }
                
                /* Ê£ãÁõòÁ∫øÊù°ÂìçÂ∫îÂºè */
                .board-lines {
                    position: absolute;
                    top: 5vw;
                    left: 5vw;
                    width: 80vw;
                    max-width: 540px;
                    height: calc(80vw * 1.11);
                    max-height: 600px;
                }
                @media (min-width: 768px) {
                    .board-lines {
                        top: 30px;
                        left: 30px;
                        width: 540px;
                        height: 600px;
                    }
                }
                .horizontal-line {
                    position: absolute;
                    width: 80vw;
                    max-width: 540px;
                    height: 1px;
                    background-color: #000;
                }
                @media (min-width: 768px) {
                    .horizontal-line {
                        width: 540px;
                    }
                }
                .vertical-line {
                    position: absolute;
                    width: 1px;
                    height: calc(80vw * 1.11);
                    max-height: 600px;
                    background-color: #000;
                }
                @media (min-width: 768px) {
                    .vertical-line {
                        height: 600px;
                    }
                }
                .river {
                    position: absolute;
                    top: calc(45vw - 5vw);
                    left: 5vw;
                    width: 80vw;
                    max-width: 540px;
                    height: 10vw;
                    max-height: 60px;
                    background-color: rgba(135, 206, 235, 0.3);
                    pointer-events: none;
                }
                @media (min-width: 768px) {
                    .river {
                        top: 270px;
                        left: 30px;
                        width: 540px;
                        height: 60px;
                    }
                }
                
                /* ÊéßÂà∂ÊåâÈíÆÊ†∑Âºè */
                .controls {
                    margin-top: 20px;
                    display: flex;
                    flex-wrap: wrap;
                    justify-content: center;
                    gap: 10px;
                }
                button {
                    padding: 10px 20px;
                    font-size: 16px;
                    background-color: #8b4513;
                    color: white;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    margin: 5px;
                }
                button:hover {
                    background-color: #a0522d;
                }
                
                /* Áä∂ÊÄÅÊòæÁ§∫Ê†∑Âºè */
                .status {
                    margin-top: 10px;
                    font-size: 18px;
                    font-weight: bold;
                }
                .hint-text {
                    margin-top: 10px;
                    font-size: 14px;
                    color: #666;
                    min-height: 20px;
                }
                
                /* Ëµ∞Ê£ãËÆ∞ÂΩïÊ†∑Âºè */
                .move-history {
                    margin-top: 20px;
                    max-height: 150px;
                    overflow-y: auto;
                    background-color: rgba(255, 255, 255, 0.5);
                    padding: 10px;
                    border-radius: 5px;
                    width: 90vw;
                    max-width: 300px;
                    margin-left: auto;
                    margin-right: auto;
                }
                .move-item {
                    font-size: 12px;
                    margin: 2px 0;
                    padding: 2px 5px;
                    background-color: rgba(255, 255, 255, 0.8);
                    border-radius: 3px;
                }
                .move-item.red {
                    color: #cc0000;
                }
                .move-item.black {
                    color: #000;
                }
                
                /* ËÉåÊôØÂàáÊç¢ÊåâÈíÆ */
                #bgChangeBtn {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    width: 40px;
                    height: 40px;
                    border-radius: 50%;
                    background: rgba(255, 255, 255, 0.8);
                    border: 2px solid #8b4513;
                    cursor: pointer;
                    font-size: 20px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 999;
                    transition: all 0.3s ease;
                }
                #bgChangeBtn:hover {
                    transform: scale(1.1);
                    background: rgba(255, 255, 255, 1);
                }
            `
        };

        // ‰∫å. Ê∏∏ÊàèÁä∂ÊÄÅÂèòÈáè
        let board = [];
        let selectedPiece = null;
        let currentPlayer = 'red';
        let gameOver = false;
        let moveHistory = [];
        let gameMode = '';
        let aiThinking = false;
        let currentBgIndex = 0;

        // ‰∏â. ÂàùÂßãÂåñCSSÊ†∑Âºè
        function initStyles() {
            const styleElement = document.getElementById('dynamicStyles');
            styleElement.textContent = CONFIG.CSS_TEMPLATE.replace('{{BACKGROUND}}', CONFIG.BACKGROUNDS[currentBgIndex]);
        }

        // Âõõ. ËÉåÊôØÂàáÊç¢ÂäüËÉΩ
        function changeBackground() {
            currentBgIndex = (currentBgIndex + 1) % CONFIG.BACKGROUNDS.length;
            const styleElement = document.getElementById('dynamicStyles');
            styleElement.textContent = CONFIG.CSS_TEMPLATE.replace('{{BACKGROUND}}', CONFIG.BACKGROUNDS[currentBgIndex]);
        }

        // ‰∫î. Ê£ãÁõòÂàùÂßãÂåñ
        function initBoard() {
            board = Array(CONFIG.BOARD_HEIGHT).fill(null).map(() => Array(CONFIG.BOARD_WIDTH).fill(null));
            
            // 1. Á∫¢ÊñπÊ£ãÂ≠êÂàùÂßã‰ΩçÁΩÆ
            const redPieces = [
                {type: CONFIG.PIECE_TYPES.JU, row: 9, col: 0, player: 'red'},
                {type: CONFIG.PIECE_TYPES.MA, row: 9, col: 1, player: 'red'},
                {type: CONFIG.PIECE_TYPES.XIANG, row: 9, col: 2, player: 'red'},
                {type: CONFIG.PIECE_TYPES.SHI, row: 9, col: 3, player: 'red'},
                {type: CONFIG.PIECE_TYPES.SHUAI, row: 9, col: 4, player: 'red'},
                {type: CONFIG.PIECE_TYPES.SHI, row: 9, col: 5, player: 'red'},
                {type: CONFIG.PIECE_TYPES.XIANG, row: 9, col: 6, player: 'red'},
                {type: CONFIG.PIECE_TYPES.MA, row: 9, col: 7, player: 'red'},
                {type: CONFIG.PIECE_TYPES.JU, row: 9, col: 8, player: 'red'},
                {type: CONFIG.PIECE_TYPES.PAO, row: 7, col: 1, player: 'red'},
                {type: CONFIG.PIECE_TYPES.PAO, row: 7, col: 7, player: 'red'},
                {type: CONFIG.PIECE_TYPES.BING, row: 6, col: 0, player: 'red'},
                {type: CONFIG.PIECE_TYPES.BING, row: 6, col: 2, player: 'red'},
                {type: CONFIG.PIECE_TYPES.BING, row: 6, col: 4, player: 'red'},
                {type: CONFIG.PIECE_TYPES.BING, row: 6, col: 6, player: 'red'},
                {type: CONFIG.PIECE_TYPES.BING, row: 6, col: 8, player: 'red'}
            ];
            
            // 2. ÈªëÊñπÊ£ãÂ≠êÂàùÂßã‰ΩçÁΩÆ
            const blackPieces = [
                {type: CONFIG.PIECE_TYPES.JU, row: 0, col: 0, player: 'black'},
                {type: CONFIG.PIECE_TYPES.MA, row: 0, col: 1, player: 'black'},
                {type: CONFIG.PIECE_TYPES.XIANG, row: 0, col: 2, player: 'black'},
                {type: CONFIG.PIECE_TYPES.SHI, row: 0, col: 3, player: 'black'},
                {type: CONFIG.PIECE_TYPES.SHUAI, row: 0, col: 4, player: 'black'},
                {type: CONFIG.PIECE_TYPES.SHI, row: 0, col: 5, player: 'black'},
                {type: CONFIG.PIECE_TYPES.XIANG, row: 0, col: 6, player: 'black'},
                {type: CONFIG.PIECE_TYPES.MA, row: 0, col: 7, player: 'black'},
                {type: CONFIG.PIECE_TYPES.JU, row: 0, col: 8, player: 'black'},
                {type: CONFIG.PIECE_TYPES.PAO, row: 2, col: 1, player: 'black'},
                {type: CONFIG.PIECE_TYPES.PAO, row: 2, col: 7, player: 'black'},
                {type: CONFIG.PIECE_TYPES.BING, row: 3, col: 0, player: 'black'},
                {type: CONFIG.PIECE_TYPES.BING, row: 3, col: 2, player: 'black'},
                {type: CONFIG.PIECE_TYPES.BING, row: 3, col: 4, player: 'black'},
                {type: CONFIG.PIECE_TYPES.BING, row: 3, col: 6, player: 'black'},
                {type: CONFIG.PIECE_TYPES.BING, row: 3, col: 8, player: 'black'}
            ];
            
            // 3. Â∞ÜÊâÄÊúâÊ£ãÂ≠êÊîæÁΩÆÂà∞Ê£ãÁõò‰∏ä
            [...redPieces, ...blackPieces].forEach(piece => {
                board[piece.row][piece.col] = piece;
            });
        }

        // ÂÖ≠. Ê£ãÁõòÊ∏≤Êüì
        function getCellSize() {
            const board = document.getElementById('board');
            return board.offsetWidth / CONFIG.BOARD_WIDTH;
        }

        function renderBoard() {
            const boardElement = document.getElementById('board');
            const cellSize = getCellSize();
            const pieceSize = Math.round(cellSize * 0.70);
            const pieceOff = Math.round((cellSize - pieceSize) / 2);
            
            // 1. Ê∏ÖÁ©∫ÊóßÂÜÖÂÆπ
            boardElement.querySelectorAll('.piece, .grid').forEach(el => el.remove());
            
            // 2. ÂàõÂª∫ÁÇπÂáªÊ†ºÂ≠ê
            for (let row = 0; row < CONFIG.BOARD_HEIGHT; row++) {
                for (let col = 0; col < CONFIG.BOARD_WIDTH; col++) {
                    const grid = document.createElement('div');
                    grid.className = 'grid';
                    grid.style.left = `${col * cellSize}px`;
                    grid.style.top = `${row * cellSize}px`;
                    grid.style.width = `${cellSize}px`;
                    grid.style.height = `${cellSize}px`;
                    grid.dataset.row = row;
                    grid.dataset.col = col;
                    grid.onclick = () => handleGridClick(row, col);
                    boardElement.appendChild(grid);
                }
            }
            
            // 3. ÂàõÂª∫Ê£ãÂ≠ê
            for (let row = 0; row < CONFIG.BOARD_HEIGHT; row++) {
                for (let col = 0; col < CONFIG.BOARD_WIDTH; col++) {
                    const piece = board[row][col];
                    if (!piece) continue;
                    
                    const el = document.createElement('div');
                    el.className = `piece ${piece.player}`;
                    el.textContent = piece.type;
                    el.style.left = `${col * cellSize + pieceOff}px`;
                    el.style.top = `${row * cellSize + pieceOff}px`;
                    el.style.width = `${pieceSize}px`;
                    el.style.height = `${pieceSize}px`;
                    el.style.fontSize = `${Math.round(pieceSize * 0.5)}px`;
                    el.dataset.row = row;
                    el.dataset.col = col;
                    el.onclick = (e) => {
                        e.stopPropagation();
                        handlePieceClick(row, col);
                    };
                    boardElement.appendChild(el);
                }
            }
            
            // 4. Ë∞ÉÊï¥Ê£ãÁõòÁ∫ø‰ΩçÁΩÆ
            const lines = document.querySelector('.board-lines');
            if (lines) {
                lines.style.left = `${cellSize / 2}px`;
                lines.style.top = `${cellSize / 2}px`;
                lines.style.width = `${cellSize * (CONFIG.BOARD_WIDTH - 1)}px`;
                lines.style.height = `${cellSize * (CONFIG.BOARD_HEIGHT - 1)}px`;
            }
        }

        // ‰∏É. ‰∫ã‰ª∂Â§ÑÁêÜ
        function handlePieceClick(row, col) {
            if (gameOver || aiThinking) return;
            
            const piece = board[row][col];
            if (!piece) return;
            
            // 1. Â∑≤ÈÄâ‰∏≠Â∑±ÊñπÊ£ãÂ≠êÔºåÂÜçÁÇπÂØπÊñπÊ£ãÂ≠ê‚ÜíÁõ¥Êé•ÂêÉ
            if (selectedPiece && piece.player !== currentPlayer) {
                if (isValidMove(selectedPiece.row, selectedPiece.col, row, col)) {
                    movePiece(selectedPiece.row, selectedPiece.col, row, col);
                    if (gameMode === 'ai' && currentPlayer === 'black' && !gameOver) {
                        setTimeout(() => aiMove(), 500);
                    }
                }
                return;
            }
            
            // 2. Ê≤°ÈÄâ‰∏≠Â∑±ÊñπÊ£ãÂ≠êÔºåÁÇπÂØπÊñπÊ£ãÂ≠ê‚ÜíËá™Âä®ÊâæËÉΩÂêÉÂÆÉÁöÑÂ∑±ÊñπÊ£ãÂ≠ê
            if (piece.player !== currentPlayer) {
                for (let r = 0; r < CONFIG.BOARD_HEIGHT; r++) {
                    for (let c = 0; c < CONFIG.BOARD_WIDTH; c++) {
                        const my = board[r][c];
                        if (my && my.player === currentPlayer && isValidMove(r, c, row, col)) {
                            movePiece(r, c, row, col);
                            if (gameMode === 'ai' && currentPlayer === 'black' && !gameOver) {
                                setTimeout(() => aiMove(), 500);
                            }
                            return;
                        }
                    }
                }
                return;
            }
            
            // 3. ÁÇπÂ∑±ÊñπÊ£ãÂ≠ê‚ÜíÊ≠£Â∏∏ÈÄâ‰∏≠
            clearSelection();
            selectedPiece = {row, col, piece};
            highlightPiece(row, col);
            showValidMoves(row, col);
        }

        function handleGridClick(row, col) {
            if (gameOver || !selectedPiece || aiThinking) return;
            
            const targetPiece = board[row][col];
            if (targetPiece && targetPiece.player === currentPlayer) {
                handlePieceClick(row, col);
                return;
            }
            
            if (isValidMove(selectedPiece.row, selectedPiece.col, row, col)) {
                movePiece(selectedPiece.row, selectedPiece.col, row, col);
                if (gameMode === 'ai' && currentPlayer === 'black' && !gameOver) {
                    setTimeout(() => aiMove(), 500);
                }
            }
        }

        // ÂÖ´. AI Áõ∏ÂÖ≥ÂäüËÉΩ
        function aiMove() {
            if (gameOver || aiThinking) return;
            
            aiThinking = true;
            document.getElementById('hintText').textContent = 'AI Ê≠£Âú®ÊÄùËÄÉ...';
            
            setTimeout(() => {
                const bestMove = findBestMove(3);
                if (bestMove) {
                    movePiece(bestMove.from.row, bestMove.from.col, bestMove.to.row, bestMove.to.col);
                }
                aiThinking = false;
            }, 1000);
        }

        function findBestMove(depth) {
            const possibleMoves = getAllPossibleMoves('black');
            if (possibleMoves.length === 0) return null;
            
            let bestMove = null;
            let bestScore = -Infinity;
            
            for (const move of possibleMoves) {
                const moveData = executeMove(move);
                const score = minimax(depth - 1, -Infinity, Infinity, false);
                undoMoveData(moveData);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            
            return bestMove;
        }

        function minimax(depth, alpha, beta, isMaximizing) {
            if (depth === 0 || gameOver) {
                return evaluateBoard();
            }
            
            const player = isMaximizing ? 'black' : 'red';
            const possibleMoves = getAllPossibleMoves(player);
            
            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of possibleMoves) {
                    const moveData = executeMove(move);
                    const eval = minimax(depth - 1, alpha, beta, false);
                    undoMoveData(moveData);
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of possibleMoves) {
                    const moveData = executeMove(move);
                    const eval = minimax(depth - 1, alpha, beta, true);
                    undoMoveData(moveData);
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        function getAllPossibleMoves(player) {
            const moves = [];
            for (let row = 0; row < CONFIG.BOARD_HEIGHT; row++) {
                for (let col = 0; col < CONFIG.BOARD_WIDTH; col++) {
                    const piece = board[row][col];
                    if (piece && piece.player === player) {
                        for (let toRow = 0; toRow < CONFIG.BOARD_HEIGHT; toRow++) {
                            for (let toCol = 0; toCol < CONFIG.BOARD_WIDTH; toCol++) {
                                if (isValidMove(row, col, toRow, toCol)) {
                                    moves.push({
                                        from: {row, col},
                                        to: {row: toRow, col: toCol},
                                        piece: piece
                                    });
                                }
                            }
                        }
                    }
                }
            }
            return moves;
        }

        function executeMove(move) {
            const piece = board[move.from.row][move.from.col];
            const targetPiece = board[move.to.row][move.to.col];
            
            const moveData = {
                from: {...move.from},
                to: {...move.to},
                piece: {...piece},
                captured: targetPiece ? {...targetPiece} : null,
                board: board.map(row => row.map(cell => cell ? {...cell} : null))
            };
            
            board[move.to.row][move.to.col] = piece;
            board[move.from.row][move.from.col] = null;
            
            return moveData;
        }

        function undoMoveData(moveData) {
            board = moveData.board.map(row => row.map(cell => cell ? {...cell} : null));
        }

        function evaluateBoard() {
            let score = 0;
            for (let r = 0; r < CONFIG.BOARD_HEIGHT; r++) {
                for (let c = 0; c < CONFIG.BOARD_WIDTH; c++) {
                    const p = board[r][c];
                    if (!p) continue;
                    
                    let v = CONFIG.PIECE_VALUES[p.type] || 0;
                    
                    // ËøáÊ≤≥ÂÖµÈ¢ùÂ§ñÂä†ÂàÜ
                    if ((p.player === 'red' && p.type === 'ÂÖµ' && r <= 4) ||
                        (p.player === 'black' && p.type === 'Âçí' && r >= 5)) v += 8;
                    
                    // ÊéßÂà∂‰∏≠ÂøÉÂå∫ÂüüÂä†ÂàÜ
                    if (r >= 2 && r <= 7 && c >= 2 && c <= 6) v += 3;
                    
                    score += (p.player === 'black' ? v : -v);
                }
            }
            return score;
        }

        // ‰πù. Ê£ãÂ≠êÈÄâÊã©‰∏éÊòæÁ§∫
        function clearSelection() {
            selectedPiece = null;
            document.querySelectorAll('.piece.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.piece.hint').forEach(el => {
                el.classList.remove('hint');
            });
            document.querySelectorAll('.piece.valid-move').forEach(el => {
                el.classList.remove('valid-move');
            });
        }

        function highlightPiece(row, col) {
            const pieceElement = document.querySelector(`.piece[data-row="${row}"][data-col="${col}"]`);
            if (pieceElement) {
                pieceElement.classList.add('selected');
            }
        }

        function showValidMoves(row, col) {
            for (let r = 0; r < CONFIG.BOARD_HEIGHT; r++) {
                for (let c = 0; c < CONFIG.BOARD_WIDTH; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const pieceElement = document.querySelector(`.piece[data-row="${r}"][data-col="${c}"]`);
                        if (pieceElement) {
                            pieceElement.classList.add('valid-move');
                        }
                    }
                }
            }
        }

        // ÂçÅ. Ê£ãÂ≠êÁßªÂä®ËßÑÂàô
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            if (!piece) return false;
            
            const targetPiece = board[toRow][toCol];
            if (targetPiece && targetPiece.player === piece.player) return false;
            
            const rowDiff = toRow - fromRow;
            const colDiff = toCol - fromCol;
            const absRowDiff = Math.abs(rowDiff);
            const absColDiff = Math.abs(colDiff);
            
            switch (piece.type) {
                case CONFIG.PIECE_TYPES.SHUAI:
                    return isValidShuaiMove(fromRow, fromCol, toRow, toCol);
                case CONFIG.PIECE_TYPES.SHI:
                    if (piece.player === 'red') {
                        return toRow >= 7 && toRow <= 9 && toCol >= 3 && toCol <= 5 &&
                               absRowDiff === 1 && absColDiff === 1;
                    } else {
                        return toRow >= 0 && toRow <= 2 && toCol >= 3 && toCol <= 5 &&
                               absRowDiff === 1 && absColDiff === 1;
                    }
                case CONFIG.PIECE_TYPES.XIANG:
                    if (piece.player === 'red' && toRow < 5) return false;
                    if (piece.player === 'black' && toRow > 4) return false;
                    if (absRowDiff !== 2 || absColDiff !== 2) return false;
                    const midRow = fromRow + rowDiff / 2;
                    const midCol = fromCol + colDiff / 2;
                    return board[midRow][midCol] === null;
                case CONFIG.PIECE_TYPES.MA:
                    if (!((absRowDiff === 2 && absColDiff === 1) || (absRowDiff === 1 && absColDiff === 2))) return false;
                    if (absRowDiff === 2) {
                        const midRow = fromRow + rowDiff / 2;
                        return board[midRow][fromCol] === null;
                    } else {
                        const midCol = fromCol + colDiff / 2;
                        return board[fromRow][midCol] === null;
                    }
                case CONFIG.PIECE_TYPES.JU:
                    return isValidJuMove(fromRow, fromCol, toRow, toCol);
                case CONFIG.PIECE_TYPES.PAO:
                    return isValidPaoMove(fromRow, fromCol, toRow, toCol);
                case CONFIG.PIECE_TYPES.BING:
                    return isValidBingMove(fromRow, fromCol, toRow, toCol);
                default:
                    return false;
            }
        }

        function isValidShuaiMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];
            
            if (piece.player === 'red') {
                if (toRow < 7 || toRow > 9 || toCol < 3 || toCol > 5) return false;
            } else {
                if (toRow < 0 || toRow > 2 || toCol < 3 || toCol > 5) return false;
            }
            
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            if (!((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1))) {
                return false;
            }
            
            // Â∞ÜÂ∏ÖÂØπÈù¢
            if (targetPiece && targetPiece.type === CONFIG.PIECE_TYPES.SHUAI) {
                if (fromCol === toCol) {
                    const minRow = Math.min(fromRow, toRow);
                    const maxRow = Math.max(fromRow, toRow);
                    for (let row = minRow + 1; row < maxRow; row++) {
                        if (board[row][fromCol] !== null) return false;
                    }
                    return true;
                }
            }
            
            return true;
        }

        function isValidJuMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow !== toRow && fromCol !== toCol) return false;
            
            if (fromRow === toRow) {
                const minCol = Math.min(fromCol, toCol);
                const maxCol = Math.max(fromCol, toCol);
                for (let col = minCol + 1; col < maxCol; col++) {
                    if (board[fromRow][col] !== null) return false;
                }
            } else {
                const minRow = Math.min(fromRow, toRow);
                const maxRow = Math.max(fromRow, toRow);
                for (let row = minRow + 1; row < maxRow; row++) {
                    if (board[row][fromCol] !== null) return false;
                }
            }
            
            return true;
        }

        function isValidPaoMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow !== toRow && fromCol !== toCol) return false;
            
            const targetPiece = board[toRow][toCol];
            let pieceCount = 0;
            
            if (fromRow === toRow) {
                const minCol = Math.min(fromCol, toCol);
                const maxCol = Math.max(fromCol, toCol);
                for (let col = minCol + 1; col < maxCol; col++) {
                    if (board[fromRow][col] !== null) pieceCount++;
                }
            } else {
                const minRow = Math.min(fromRow, toRow);
                const maxRow = Math.max(fromRow, toRow);
                for (let row = minRow + 1; row < maxRow; row++) {
                    if (board[row][fromCol] !== null) pieceCount++;
                }
            }
            
            if (targetPiece) {
                return pieceCount === 1;
            } else {
                return pieceCount === 0;
            }
        }

        function isValidBingMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const rowDiff = toRow - fromRow;
            const colDiff = Math.abs(toCol - fromCol);
            
            if (piece.player === 'red') {
                if (fromRow > 4) {
                    return rowDiff === -1 && colDiff === 0;
                } else {
                    return (rowDiff === -1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
                }
            } else {
                if (fromRow < 5) {
                    return rowDiff === 1 && colDiff === 0;
                } else {
                    return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
                }
            }
        }

        // ÂçÅ‰∏Ä. Ê£ãÂ≠êÁßªÂä®‰∏éÊ∏∏ÊàèÈÄªËæë
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];
            
            const moveData = {
                from: {row: fromRow, col: fromCol},
                to: {row: toRow, col: toCol},
                piece: {...piece},
                captured: targetPiece ? {...targetPiece} : null,
                board: board.map(row => row.map(cell => cell ? {...cell} : null))
            };
            
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            
            addToHistory(moveData);
            
            if (targetPiece) {
                if (targetPiece.type === CONFIG.PIECE_TYPES.SHUAI) {
                    gameOver = true;
                    setTimeout(() => {
                        alert(`${currentPlayer === 'red' ? 'Á∫¢Êñπ' : 'ÈªëÊñπ'}Ëé∑ËÉúÔºÅ`);
                    }, 100);
                }
            }
            
            currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
            updateStatus();
            document.getElementById('hintText').textContent = '';
            clearSelection();
            renderBoard();
        }

        function addToHistory(moveData) {
            const moveList = document.getElementById('moveList');
            const moveItem = document.createElement('div');
            moveItem.className = `move-item ${currentPlayer}`;
            
            const fromPos = `${9 - moveData.from.row}${String.fromCharCode(97 + moveData.from.col)}`;
            const toPos = `${9 - moveData.to.row}${String.fromCharCode(97 + moveData.to.col)}`;
            const captureText = moveData.captured ? ` ÂêÉ ${moveData.captured.type}` : '';
            
            moveItem.textContent = `${moveData.piece.type}: ${fromPos} ‚Üí ${toPos}${captureText}`;
            moveList.insertBefore(moveItem, moveList.firstChild);
            moveHistory.push(moveData);
        }

        // ÂçÅ‰∫å. Ê∏∏ÊàèÊéßÂà∂ÂäüËÉΩ
        function undoMove() {
            if (moveHistory.length === 0) {
                alert('Ê≤°ÊúâÂèØ‰ª•ÊÇîÊ£ãÁöÑËÆ∞ÂΩï‰∫ÜÔºÅ');
                return;
            }
            
            if (gameMode === 'ai' && moveHistory.length < 2) {
                alert('AI Ê®°Âºè‰∏ãËá≥Â∞ëÈúÄË¶ÅËµ∞‰∏§Ê≠•ÊâçËÉΩÊÇîÊ£ãÔºÅ');
                return;
            }
            
            if (confirm('Á°ÆÂÆöË¶ÅÊÇîÊ£ãÂêóÔºü')) {
                const steps = gameMode === 'ai' ? 2 : 1;
                for (let i = 0; i < steps; i++) {
                    if (moveHistory.length === 0) break;
                    const lastMove = moveHistory.pop();
                    board = lastMove.board.map(row => row.map(cell => cell ? {...cell} : null));
                    
                    const moveList = document.getElementById('moveList');
                    if (moveList.firstChild) {
                        moveList.removeChild(moveList.firstChild);
                    }
                    
                    currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
                }
                
                updateStatus();
                clearSelection();
                document.getElementById('hintText').textContent = '';
                renderBoard();
            }
        }

        function getHint() {
            if (gameOver || aiThinking) return;
            
            const playerPieces = [];
            for (let row = 0; row < CONFIG.BOARD_HEIGHT; row++) {
                for (let col = 0; col < CONFIG.BOARD_WIDTH; col++) {
                    const piece = board[row][col];
                    if (piece && piece.player === currentPlayer) {
                        playerPieces.push({row, col, piece});
                    }
                }
            }
            
            const possibleMoves = [];
            for (const pieceInfo of playerPieces) {
                for (let toRow = 0; toRow < CONFIG.BOARD_HEIGHT; toRow++) {
                    for (let toCol = 0; toCol < CONFIG.BOARD_WIDTH; toCol++) {
                        if (isValidMove(pieceInfo.row, pieceInfo.col, toRow, toCol)) {
                            const score = evaluateMoveDeep(pieceInfo.row, pieceInfo.col, toRow, toCol, 3);
                            possibleMoves.push({
                                from: {row: pieceInfo.row, col: pieceInfo.col},
                                to: {row: toRow, col: toCol},
                                piece: pieceInfo.piece,
                                score: score
                            });
                        }
                    }
                }
            }
            
            if (possibleMoves.length === 0) {
                document.getElementById('hintText').textContent = 'Ê≤°ÊúâÂèØËµ∞ÁöÑÊ£ãÂ≠ê‰∫ÜÔºÅ';
                return;
            }
            
            possibleMoves.sort((a, b) => b.score - a.score);
            const bestMove = possibleMoves[0];
            
            const hintText = document.getElementById('hintText');
            const fromPos = `${9 - bestMove.from.row}${String.fromCharCode(97 + bestMove.from.col)}`;
            const toPos = `${9 - bestMove.to.row}${String.fromCharCode(97 + bestMove.to.col)}`;
            
            let reason = '';
            if (bestMove.score > 50) {
                reason = ' (ÂèØ‰ª•ÂêÉÊéâÂØπÊñπÈáçË¶ÅÊ£ãÂ≠ê)';
            } else if (bestMove.score < -20) {
                reason = ' (ÂèØËÉΩË¢´ÂêÉÔºåË∞®ÊÖéËÄÉËôë)';
            } else {
                reason = ' (ËæÉ‰∏∫ÂÆâÂÖ®ÁöÑËµ∞Ê≥ï)';
            }
            
            hintText.textContent = `Âª∫ËÆÆËµ∞Ê≥ïÔºö${bestMove.piece.type} ‰ªé ${fromPos} Ëµ∞Âà∞${toPos}${reason}`;
            hintText.style.color = currentPlayer === 'red' ? '#cc0000' : '#000';
            
            clearSelection();
            const pieceElement = document.querySelector(`.piece[data-row="${bestMove.from.row}"][data-col="${bestMove.from.col}"]`);
            if (pieceElement) {
                pieceElement.classList.add('hint');
            }
        }

        function evaluateMoveDeep(fromRow, fromCol, toRow, toCol, depth) {
            if (depth === 0) return 0;
            
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];
            let score = 0;
            
            const pieceValues = {
                [CONFIG.PIECE_TYPES.BING]: 10,
                [CONFIG.PIECE_TYPES.PAO]: 30,
                [CONFIG.PIECE_TYPES.MA]: 30,
                [CONFIG.PIECE_TYPES.XIANG]: 20,
                [CONFIG.PIECE_TYPES.SHI]: 20,
                [CONFIG.PIECE_TYPES.JU]: 50,
                [CONFIG.PIECE_TYPES.SHUAI]: 1000
            };
            
            if (targetPiece) {
                score += pieceValues[targetPiece.type] || 0;
            }
            
            const originalBoard = board.map(row => row.map(cell => cell ? {...cell} : null));
            const originalGameOver = gameOver;
            
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            
            let canBeCaptured = false;
            let captureValue = 0;
            
            for (let row = 0; row < CONFIG.BOARD_HEIGHT; row++) {
                for (let col = 0; col < CONFIG.BOARD_WIDTH; col++) {
                    const enemyPiece = board[row][col];
                    if (enemyPiece && enemyPiece.player !== currentPlayer) {
                        if (isValidMove(row, col, toRow, toCol)) {
                            canBeCaptured = true;
                            const value = pieceValues[piece.type] || 0;
                            captureValue = Math.max(captureValue, value);
                        }
                    }
                }
            }
            
            if (canBeCaptured) {
                score -= captureValue * 0.8;
            }
            
            if (depth > 1 && !gameOver) {
                const nextPlayer = currentPlayer === 'red' ? 'black' : 'red';
                const nextMoves = getAllPossibleMoves(nextPlayer);
                
                if (nextMoves.length > 0) {
                    let worstResponse = Infinity;
                    for (const nextMove of nextMoves.slice(0, 10)) {
                        const nextScore = evaluateMoveDeep(
                            nextMove.from.row, nextMove.from.col,
                            nextMove.to.row, nextMove.to.col,
                            depth - 1
                        );
                        worstResponse = Math.min(worstResponse, nextScore);
                    }
                    score += worstResponse * 0.3;
                }
            }
            
            board = originalBoard;
            gameOver = originalGameOver;
            
            // ‰ΩçÁΩÆ‰ª∑ÂÄº
            if (piece.player === 'red' && toRow < fromRow) score += 2;
            if (piece.player === 'black' && toRow > fromRow) score += 2;
            
            if (toRow >= 2 && toRow <= 7 && toCol >= 2 && toCol <= 6) {
                score += 3;
            }
            
            // Â∏ÖÁöÑÂÆâÂÖ®
            if (piece.type === CONFIG.PIECE_TYPES.SHUAI) {
                const inPalace = piece.player === 'red' ?
                    (toRow >= 7 && toRow <= 9 && toCol >= 3 && toCol <= 5) :
                    (toRow >= 0 && toRow <= 2 && toCol >= 3 && toCol <= 5);
                if (!inPalace) score -= 50;
            }
            
            return score;
        }

        // ÂçÅ‰∏â. Ê∏∏ÊàèÂàùÂßãÂåñ‰∏éÊéßÂà∂
        function startGame(mode) {
            gameMode = mode;
            document.getElementById('modeSelection').style.display = 'none';
            document.getElementById('gameMode').textContent = mode === 'ai' ? '(AIÂØπÊàò)' : '(Âèå‰∫∫ÂØπÊàò)';
            
            if (mode === 'ai' && currentPlayer === 'black') {
                setTimeout(() => aiMove(), 1000);
            }
        }

        function updateStatus() {
            const statusElement = document.getElementById('currentPlayer');
            statusElement.textContent = currentPlayer === 'red' ? 'Á∫¢Êñπ' : 'ÈªëÊñπ';
            statusElement.style.color = currentPlayer === 'red' ? '#cc0000' : '#000';
        }

      function resetGame() {
    if (confirm('Á°ÆÂÆöË¶ÅÈáçÊñ∞ÂºÄÂßãÊ∏∏ÊàèÔºü')) {
        // Ê∏ÖÈô§Ê∏∏ÊàèÁä∂ÊÄÅ
        gameOver = false;
        currentPlayer = 'red';
        selectedPiece = null;
        moveHistory = [];
        aiThinking = false;
        gameMode = '';

        // Ê∏ÖÁ©∫ÁïåÈù¢
        document.getElementById('moveList').innerHTML = '';
        document.getElementById('hintText').textContent = '';
        document.getElementById('gameMode').textContent = '';

        // ÈáçÊñ∞ÂàùÂßãÂåñÊ£ãÁõò
        initBoard();
        renderBoard();
        updateStatus();

        // ÊòæÁ§∫Ê®°ÂºèÈÄâÊã©ÁïåÈù¢
        const modeSelection = document.getElementById('modeSelection');
        modeSelection.style.display = 'flex';

        // üî•Âº∫Âà∂ÈáçÊñ∞ÁªëÂÆö‰∫ã‰ª∂ÔºàÈò≤Ê≠¢ÁÇπÂáªÊó†ÊïàÔºâ
        modeSelection.innerHTML = `
            <div class="mode-box">
                <h2>ÈÄâÊã©Ê∏∏ÊàèÊ®°Âºè</h2>
                <button class="mode-button" onclick="startGame('pvp')">Âèå‰∫∫ÂØπÊàò</button>
                <button class="mode-button" onclick="startGame('ai')">AIÂØπÊàò</button>
            </div>
        `;
    }
}


        function showRules() {
            alert(`Ë±°Ê£ãËßÑÂàôÔºö
1. Â∏ÖÔºàÂ∞ÜÔºâÔºöÂè™ËÉΩÂú®‰πùÂÆ´Ê†ºÂÜÖÁßªÂä®ÔºåÊØèÊ¨°Âè™ËÉΩËµ∞‰∏ÄÊ†º
2. Â£´Ôºà‰ªïÔºâÔºöÂè™ËÉΩÂú®‰πùÂÆ´Ê†ºÂÜÖÊñúËµ∞‰∏ÄÊ†º
3. Ë±°ÔºàÁõ∏ÔºâÔºöËµ∞Áî∞Â≠óÔºå‰∏çËÉΩËøáÊ≤≥Ôºå‰∏çËÉΩÂ°ûË±°Áúº
4. È©¨ÔºöËµ∞Êó•Â≠óÔºå‰∏çËÉΩËπ©È©¨ËÖø
5. ËΩ¶ÔºöÁõ¥Á∫øË°åËµ∞ÔºåÊ†ºÊï∞‰∏çÈôê
6. ÁÇÆÔºöÁõ¥Á∫øË°åËµ∞ÔºåÂêÉÂ≠êÊó∂ÈúÄË¶ÅÈöî‰∏Ä‰∏™Ê£ãÂ≠ê
7. ÂÖµÔºàÂçíÔºâÔºöËøáÊ≤≥ÂâçÂè™ËÉΩÂêëÂâçÔºåËøáÊ≤≥ÂêéÂèØ‰ª•Â∑¶Âè≥ÁßªÂä®

Êìç‰ΩúËØ¥ÊòéÔºö
- ÁÇπÂáªÊ£ãÂ≠êÈÄâ‰∏≠ÔºåÂÜçÁÇπÂáªÁõÆÊ†á‰ΩçÁΩÆÁßªÂä®
- ÁÇπÂáª"ÊÇîÊ£ã"ÊåâÈíÆÂèØ‰ª•Êí§ÈîÄ‰∏ä‰∏ÄÊ≠•
- ÁÇπÂáª"ÊèêÁ§∫Ëµ∞Ê≥ï"ÂèØ‰ª•Ëé∑ÂæóAIÂª∫ËÆÆÔºàËÄÉËôë3Ê≠•Ôºâ
- AIÂØπÊàòÊ®°Âºè‰∏ãÔºåAI‰ºöËá™Âä®Ëµ∞Ê£ã

ÂêÉÊéâÂØπÊñπÁöÑÂ∞Ü/Â∏ÖÂç≥ÂèØËé∑ËÉúÔºÅ`);
        }

        // ÂçÅÂõõ. ‰∫ã‰ª∂ÁõëÂê¨Âô®
        window.addEventListener('resize', () => {
            if (board.length > 0) {
                renderBoard();
            }
        });

        window.onload = function() {
            initStyles();
            initBoard();
            renderBoard();
            updateStatus();
        };
    </script>
</body>
</html>
