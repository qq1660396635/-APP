<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>增强版康威生命游戏</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 0;
            margin: 0;
            overflow-x: hidden;
        }

        .header {
            text-align: center;
            padding: 20px 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.4);
            margin-bottom: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 5px;
            background: linear-gradient(90deg, #00dbde, #fc00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 15px rgba(0, 219, 222, 0.4);
            font-weight: 700;
        }

        .subtitle {
            font-size: 1.1rem;
            color: #aaa;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 900px;
            flex: 1;
            padding: 0 15px 180px;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 700px;
            margin-bottom: 25px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        #canvas {
            display: block;
            width: 100%;
            height: auto;
            background-color: #000;
            cursor: crosshair;
            touch-action: none;
        }

        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 1.3rem;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.4s;
            padding: 20px;
        }

        .canvas-overlay.show {
            opacity: 1;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin-bottom: 25px;
            width: 100%;
            max-width: 700px;
        }

        .btn {
            padding: 14px 22px;
            font-size: 1rem;
            border: none;
            border-radius: 8px;
            background: linear-gradient(145deg, #00dbde, #fc00ff);
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            font-weight: 600;
            flex: 1;
            min-width: 130px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-pause {
            background: linear-gradient(145deg, #ff9a00, #ff5e00);
        }

        .btn-clear {
            background: linear-gradient(145deg, #ff416c, #ff4b2b);
        }

        .btn-random {
            background: linear-gradient(145deg, #3a7bd5, #00d2ff);
        }

        .btn-rules {
            background: linear-gradient(145deg, #8e2de2, #4a00e0);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            justify-content: center;
            width: 100%;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            flex-wrap: wrap;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            min-width: 220px;
        }

        .slider-label {
            font-size: 1rem;
            color: #ddd;
            min-width: 70px;
            font-weight: 500;
        }

        .slider {
            flex: 1;
            height: 10px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 5px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #00dbde;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            border: 2px solid white;
        }

        .slider-value {
            min-width: 35px;
            text-align: center;
            font-weight: bold;
            color: #00dbde;
            font-size: 1.1rem;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 700px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: #fc00ff;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #aaa;
        }

        .rules-dock {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, #1a1a2e, #16213e);
            padding: 20px;
            text-align: center;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.5);
            z-index: 100;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            max-height: 45vh;
            overflow-y: auto;
        }

        .rules-dock h3 {
            margin-bottom: 15px;
            color: #00dbde;
            font-size: 1.3rem;
        }

        .rules-dock p {
            font-size: 0.95rem;
            line-height: 1.6;
            color: #ccc;
            margin: 8px 0;
        }

        .rules-dock .hint {
            color: #ff9a00;
            font-weight: 600;
            margin-top: 10px;
            font-size: 1rem;
        }

        .rules-selector {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a2e;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.6);
            z-index: 200;
            width: 95%;
            max-width: 800px;
            max-height: 85vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .rules-selector.show {
            display: block;
        }

        .rules-selector h3 {
            text-align: center;
            margin-bottom: 25px;
            color: #00dbde;
            font-size: 1.6rem;
        }

        .rules-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .rule-option {
            background: rgba(255, 255, 255, 0.05);
            padding: 18px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .rule-option:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .rule-option.active {
            border-color: #00dbde;
            background: rgba(0, 219, 222, 0.1);
        }

        .rule-option h4 {
            color: #00dbde;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .rule-option p {
            font-size: 0.9rem;
            color: #ccc;
            line-height: 1.5;
        }

        .close-rules {
            display: block;
            margin: 0 auto;
            padding: 12px 30px;
            background: linear-gradient(145deg, #00dbde, #fc00ff);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.3s;
            font-weight: 600;
        }

        .close-rules:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
        }

        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 150;
            backdrop-filter: blur(5px);
        }

        .overlay.show {
            display: block;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .btn {
                padding: 12px 18px;
                font-size: 0.9rem;
                min-width: 110px;
            }
            
            .rules-dock p {
                font-size: 0.85rem;
            }
            
            .rules-list {
                grid-template-columns: 1fr;
            }
            
            .game-container {
                padding-bottom: 200px;
            }
            
            .slider-container {
                min-width: 100%;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.7rem;
            }
            
            .btn {
                padding: 10px 15px;
                font-size: 0.85rem;
                min-width: 100px;
            }
            
            .rules-dock {
                padding: 15px;
            }
            
            .rules-dock h3 {
                font-size: 1.2rem;
            }
            
            .rules-dock p {
                font-size: 0.8rem;
            }
            
            .rules-selector {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>增强版康威生命游戏</h1>
        <div class="subtitle">探索不同规则下的生命演化</div>
    </div>

    <div class="game-container">
        <div class="canvas-wrapper">
            <canvas id="canvas"></canvas>
            <div class="canvas-overlay" id="canvasOverlay">滑动绘制初始细胞状态</div>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="generationCount">0</div>
                <div class="stat-label">代数</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="liveCells">0</div>
                <div class="stat-label">活细胞</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="ruleName">经典</div>
                <div class="stat-label">当前规则</div>
            </div>
        </div>

        <div class="controls">
            <button class="btn" id="startBtn">开始演化</button>
            <button class="btn btn-pause" id="pauseBtn">暂停</button>
            <button class="btn btn-clear" id="clearBtn">清空</button>
            <button class="btn btn-random" id="randomBtn">随机生成</button>
            <button class="btn btn-rules" id="rulesBtn">修改规则</button>
        </div>

        <div class="control-group">
            <div class="slider-container">
                <span class="slider-label">速度:</span>
                <input type="range" class="slider" id="speedSlider" min="1" max="20" value="10">
                <span class="slider-value" id="speedValue">10</span>
            </div>
            <div class="slider-container">
                <span class="slider-label">网格大小:</span>
                <input type="range" class="slider" id="sizeSlider" min="20" max="60" value="30" step="5">
                <span class="slider-value" id="sizeValue">30</span>
            </div>
            <div class="slider-container">
                <span class="slider-label">细胞密度:</span>
                <input type="range" class="slider" id="densitySlider" min="1" max="10" value="7">
                <span class="slider-value" id="densityValue">70%</span>
            </div>
        </div>
    </div>

    <div class="rules-dock">
        <h3>当前规则: <span id="currentRuleName">经典康威规则 (23/3)</span></h3>
        <p id="currentRuleDesc">1. 任何活细胞周围有2-3个活细胞时，继续存活</p>
        <p id="currentRuleDesc2">2. 任何死细胞周围恰好有3个活细胞时，复活</p>
        <p id="currentRuleDesc3">3. 其他情况下，细胞死亡或保持死亡状态</p>
        <p class="hint">提示: 在开始演化前，可以通过滑动鼠标/手指来绘制初始细胞状态</p>
    </div>

    <div class="overlay" id="overlay"></div>

    <div class="rules-selector" id="rulesSelector">
        <h3>选择游戏规则</h3>
        <div class="rules-list">
            <div class="rule-option active" data-rule="classic">
                <h4>经典康威规则 (23/3)</h4>
                <p>生存: 2-3个邻居 | 出生: 3个邻居</p>
            </div>
            <div class="rule-option" data-rule="highlife">
                <h4>高生命规则 (23/36)</h4>
                <p>生存: 2-3个邻居 | 出生: 3或6个邻居</p>
            </div>
            <div class="rule-option" data-rule="maze">
                <h4>迷宫规则 (12345/3)</h4>
                <p>生存: 1-5个邻居 | 出生: 3个邻居</p>
            </div>
            <div class="rule-option" data-rule="diamoeba">
                <h4>变形虫规则 (35678/5678)</h4>
                <p>生存: 3,5-8个邻居 | 出生: 5-8个邻居</p>
            </div>
            <div class="rule-option" data-rule="replicator">
                <h4>复制器规则 (1357/1357)</h4>
                <p>生存: 1,3,5,7个邻居 | 出生: 1,3,5,7个邻居</p>
            </div>
            <div class="rule-option" data-rule="daynight">
                <h4>昼夜规则 (34678/3678)</h4>
                <p>生存: 3,4,6-8个邻居 | 出生: 3,6-8个邻居</p>
            </div>
            <div class="rule-option" data-rule="2x2">
                <h4>2x2规则 (125/36)</h4>
                <p>生存: 1,2,5个邻居 | 出生: 3,6个邻居</p>
            </div>
            <div class="rule-option" data-rule="amoeba">
                <h4>阿米巴规则 (1358/357)</h4>
                <p>生存: 1,3,5,8个邻居 | 出生: 3,5,7个邻居</p>
            </div>
            <div class="rule-option" data-rule="anneal">
                <h4>退火规则 (4678/368)</h4>
                <p>生存: 4,6-8个邻居 | 出生: 3,6,8个邻居</p>
            </div>
            <div class="rule-option" data-rule="coagulations">
                <h4>凝聚规则 (378/235678)</h4>
                <p>生存: 3,7,8个邻居 | 出生: 2,3,5-8个邻居</p>
            </div>
            <div class="rule-option" data-rule="coral">
                <h4>珊瑚规则 (45678/3)</h4>
                <p>生存: 4-8个邻居 | 出生: 3个邻居</p>
            </div>
            <div class="rule-option" data-rule="drylife">
                <h4>干生命规则 (23/37)</h4>
                <p>生存: 2,3个邻居 | 出生: 3,7个邻居</p>
            </div>
            <div class="rule-option" data-rule="flakes">
                <h4>雪花规则 (012345678/3)</h4>
                <p>生存: 任意数量邻居 | 出生: 3个邻居</p>
            </div>
            <div class="rule-option" data-rule="gnarl">
                <h4>格纳尔规则 (1/1)</h4>
                <p>生存: 1个邻居 | 出生: 1个邻居</p>
            </div>
            <div class="rule-option" data-rule="longlife">
                <h4>长生命规则 (5/345)</h4>
                <p>生存: 5个邻居 | 出生: 3-5个邻居</p>
            </div>
            <div class="rule-option" data-rule="mazectric">
                <h4>迷宫电规则 (1234/3)</h4>
                <p>生存: 1-4个邻居 | 出生: 3个邻居</p>
            </div>
            <div class="rule-option" data-rule="move">
                <h4>移动规则 (245/368)</h4>
                <p>生存: 2,4,5个邻居 | 出生: 3,6,8个邻居</p>
            </div>
            <div class="rule-option" data-rule="pseudolife">
                <h4>伪生命规则 (238/357)</h4>
                <p>生存: 2,3,8个邻居 | 出生: 3,5,7个邻居</p>
            </div>
            <div class="rule-option" data-rule="seeds">
                <h4>种子规则 (/2)</h4>
                <p>生存: 无 | 出生: 2个邻居</p>
            </div>
            <div class="rule-option" data-rule="serviettes">
                <h4>餐巾规则 (/234)</h4>
                <p>生存: 无 | 出生: 2-4个邻居</p>
            </div>
            <div class="rule-option" data-rule="stains">
                <h4>污渍规则 (235678/3678)</h4>
                <p>生存: 2,3,5-8个邻居 | 出生: 3,6-8个邻居</p>
            </div>
            <div class="rule-option" data-rule="walledcities">
                <h4>城墙规则 (2345/45678)</h4>
                <p>生存: 2-5个邻居 | 出生: 4-8个邻居</p>
            </div>
            <div class="rule-option" data-rule="bugs">
                <h4>虫子规则 (345/26)</h4>
                <p>生存: 3-5个邻居 | 出生: 2,6个邻居</p>
            </div>
            <div class="rule-option" data-rule="frogs">
                <h4>青蛙规则 (12/34)</h4>
                <p>生存: 1,2个邻居 | 出生: 3,4个邻居</p>
            </div>
        </div>
        <button class="close-rules" id="closeRules">应用规则</button>
    </div>

    <script>
        // 1. 配置变量
        const config = {
            gridSize: 30,
            cellSize: 20,
            gridColor: '#333',
            aliveColor: '#00dbde',
            deadColor: '#000',
            animationSpeed: 10,
            rules: {
                classic: {
                    name: '经典康威规则 (23/3)',
                    survival: [2, 3],
                    birth: [3],
                    description: [
                        '1. 任何活细胞周围有2-3个活细胞时，继续存活',
                        '2. 任何死细胞周围恰好有3个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                highlife: {
                    name: '高生命规则 (23/36)',
                    survival: [2, 3],
                    birth: [3, 6],
                    description: [
                        '1. 任何活细胞周围有2-3个活细胞时，继续存活',
                        '2. 任何死细胞周围有3或6个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                maze: {
                    name: '迷宫规则 (12345/3)',
                    survival: [1, 2, 3, 4, 5],
                    birth: [3],
                    description: [
                        '1. 任何活细胞周围有1-5个活细胞时，继续存活',
                        '2. 任何死细胞周围恰好有3个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                diamoeba: {
                    name: '变形虫规则 (35678/5678)',
                    survival: [3, 5, 6, 7, 8],
                    birth: [5, 6, 7, 8],
                    description: [
                        '1. 任何活细胞周围有3,5,6,7或8个活细胞时，继续存活',
                        '2. 任何死细胞周围有5-8个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                replicator: {
                    name: '复制器规则 (1357/1357)',
                    survival: [1, 3, 5, 7],
                    birth: [1, 3, 5, 7],
                    description: [
                        '1. 任何活细胞周围有1,3,5或7个活细胞时，继续存活',
                        '2. 任何死细胞周围有1,3,5或7个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                daynight: {
                    name: '昼夜规则 (34678/3678)',
                    survival: [3, 4, 6, 7, 8],
                    birth: [3, 6, 7, 8],
                    description: [
                        '1. 任何活细胞周围有3,4,6,7或8个活细胞时，继续存活',
                        '2. 任何死细胞周围有3,6,7或8个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                '2x2': {
                    name: '2x2规则 (125/36)',
                    survival: [1, 2, 5],
                    birth: [3, 6],
                    description: [
                        '1. 任何活细胞周围有1,2或5个活细胞时，继续存活',
                        '2. 任何死细胞周围有3或6个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                amoeba: {
                    name: '阿米巴规则 (1358/357)',
                    survival: [1, 3, 5, 8],
                    birth: [3, 5, 7],
                    description: [
                        '1. 任何活细胞周围有1,3,5或8个活细胞时，继续存活',
                        '2. 任何死细胞周围有3,5或7个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                anneal: {
                    name: '退火规则 (4678/368)',
                    survival: [4, 6, 7, 8],
                    birth: [3, 6, 8],
                    description: [
                        '1. 任何活细胞周围有4,6,7或8个活细胞时，继续存活',
                        '2. 任何死细胞周围有3,6或8个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                coagulations: {
                    name: '凝聚规则 (378/235678)',
                    survival: [3, 7, 8],
                    birth: [2, 3, 5, 6, 7, 8],
                    description: [
                        '1. 任何活细胞周围有3,7或8个活细胞时，继续存活',
                        '2. 任何死细胞周围有2,3,5,6,7或8个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                coral: {
                    name: '珊瑚规则 (45678/3)',
                    survival: [4, 5, 6, 7, 8],
                    birth: [3],
                    description: [
                        '1. 任何活细胞周围有4-8个活细胞时，继续存活',
                        '2. 任何死细胞周围恰好有3个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                drylife: {
                    name: '干生命规则 (23/37)',
                    survival: [2, 3],
                    birth: [3, 7],
                    description: [
                        '1. 任何活细胞周围有2或3个活细胞时，继续存活',
                        '2. 任何死细胞周围有3或7个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                flakes: {
                    name: '雪花规则 (012345678/3)',
                    survival: [0, 1, 2, 3, 4, 5, 6, 7, 8],
                    birth: [3],
                    description: [
                        '1. 任何活细胞无论周围有多少活细胞都会继续存活',
                        '2. 任何死细胞周围恰好有3个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                gnarl: {
                    name: '格纳尔规则 (1/1)',
                    survival: [1],
                    birth: [1],
                    description: [
                        '1. 任何活细胞周围恰好有1个活细胞时，继续存活',
                        '2. 任何死细胞周围恰好有1个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                longlife: {
                    name: '长生命规则 (5/345)',
                    survival: [5],
                    birth: [3, 4, 5],
                    description: [
                        '1. 任何活细胞周围恰好有5个活细胞时，继续存活',
                        '2. 任何死细胞周围有3,4或5个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                mazectric: {
                    name: '迷宫电规则 (1234/3)',
                    survival: [1, 2, 3, 4],
                    birth: [3],
                    description: [
                        '1. 任何活细胞周围有1-4个活细胞时，继续存活',
                        '2. 任何死细胞周围恰好有3个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                move: {
                    name: '移动规则 (245/368)',
                    survival: [2, 4, 5],
                    birth: [3, 6, 8],
                    description: [
                        '1. 任何活细胞周围有2,4或5个活细胞时，继续存活',
                        '2. 任何死细胞周围有3,6或8个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                pseudolife: {
                    name: '伪生命规则 (238/357)',
                    survival: [2, 3, 8],
                    birth: [3, 5, 7],
                    description: [
                        '1. 任何活细胞周围有2,3或8个活细胞时，继续存活',
                        '2. 任何死细胞周围有3,5或7个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                seeds: {
                    name: '种子规则 (/2)',
                    survival: [],
                    birth: [2],
                    description: [
                        '1. 所有活细胞在下一代都会死亡',
                        '2. 任何死细胞周围恰好有2个活细胞时，复活',
                        '3. 其他情况下，细胞保持死亡状态'
                    ]
                },
                serviettes: {
                    name: '餐巾规则 (/234)',
                    survival: [],
                    birth: [2, 3, 4],
                    description: [
                        '1. 所有活细胞在下一代都会死亡',
                        '2. 任何死细胞周围有2,3或4个活细胞时，复活',
                        '3. 其他情况下，细胞保持死亡状态'
                    ]
                },
                stains: {
                    name: '污渍规则 (235678/3678)',
                    survival: [2, 3, 5, 6, 7, 8],
                    birth: [3, 6, 7, 8],
                    description: [
                        '1. 任何活细胞周围有2,3,5,6,7或8个活细胞时，继续存活',
                        '2. 任何死细胞周围有3,6,7或8个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                walledcities: {
                    name: '城墙规则 (2345/45678)',
                    survival: [2, 3, 4, 5],
                    birth: [4, 5, 6, 7, 8],
                    description: [
                        '1. 任何活细胞周围有2-5个活细胞时，继续存活',
                        '2. 任何死细胞周围有4-8个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                bugs: {
                    name: '虫子规则 (345/26)',
                    survival: [3, 4, 5],
                    birth: [2, 6],
                    description: [
                        '1. 任何活细胞周围有3,4或5个活细胞时，继续存活',
                        '2. 任何死细胞周围有2或6个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                },
                frogs: {
                    name: '青蛙规则 (12/34)',
                    survival: [1, 2],
                    birth: [3, 4],
                    description: [
                        '1. 任何活细胞周围有1或2个活细胞时，继续存活',
                        '2. 任何死细胞周围有3或4个活细胞时，复活',
                        '3. 其他情况下，细胞死亡或保持死亡状态'
                    ]
                }
            }
        };

        // 2. DOM元素引用
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const clearBtn = document.getElementById('clearBtn');
        const randomBtn = document.getElementById('randomBtn');
        const rulesBtn = document.getElementById('rulesBtn');
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        const sizeSlider = document.getElementById('sizeSlider');
        const sizeValue = document.getElementById('sizeValue');
        const densitySlider = document.getElementById('densitySlider');
        const densityValue = document.getElementById('densityValue');
        const currentRuleName = document.getElementById('currentRuleName');
        const currentRuleDesc = document.getElementById('currentRuleDesc');
        const currentRuleDesc2 = document.getElementById('currentRuleDesc2');
        const currentRuleDesc3 = document.getElementById('currentRuleDesc3');
        const rulesSelector = document.getElementById('rulesSelector');
        const overlay = document.getElementById('overlay');
        const closeRules = document.getElementById('closeRules');
        const canvasOverlay = document.getElementById('canvasOverlay');
        const ruleOptions = document.querySelectorAll('.rule-option');
        const generationCount = document.getElementById('generationCount');
        const liveCells = document.getElementById('liveCells');
        const ruleName = document.getElementById('ruleName');

        // 3. 游戏状态变量
        let grid = [];
        let isRunning = false;
        let animationId = null;
        let lastTime = 0;
        let currentSpeed = config.animationSpeed;
        let isDrawing = false;
        let lastDrawnCell = null;
        let currentRule = 'classic';
        let cellSize = config.cellSize;
        let gridSize = config.gridSize;
        let generation = 0;
        let density = 0.7;

        // 4. 初始化函数
        function init() {
            // 设置画布大小
            updateGridSize();
            
            // 创建初始网格
            grid = createEmptyGrid();
            
            // 绘制初始状态
            draw();
            
            // 显示提示
            setTimeout(() => {
                canvasOverlay.classList.add('show');
                setTimeout(() => {
                    canvasOverlay.classList.remove('show');
                }, 3000);
            }, 1000);
            
            // 更新规则显示
            updateRuleDisplay();
            updateStats();
        }

        // 5. 网格和画布函数
        function createEmptyGrid() {
            return Array(gridSize).fill(null).map(() => Array(gridSize).fill(0));
        }

        function updateGridSize() {
            // 根据网格大小和单元格大小计算画布尺寸
            canvas.width = gridSize * cellSize;
            canvas.height = gridSize * cellSize;
        }

        function drawGrid() {
            ctx.strokeStyle = config.gridColor;
            ctx.lineWidth = 1;

            for (let i = 0; i <= gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, canvas.height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(canvas.width, i * cellSize);
                ctx.stroke();
            }
        }

        function drawCells() {
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    ctx.fillStyle = grid[row][col] ? config.aliveColor : config.deadColor;
                    ctx.fillRect(col * cellSize, row * cellSize, cellSize - 1, cellSize - 1);
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawCells();
            drawGrid();
        }

        // 6. 游戏逻辑函数
        function computeNextGeneration() {
            const newGrid = createEmptyGrid();
            const rule = config.rules[currentRule];

            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const neighbors = countNeighbors(row, col);
                    
                    if (grid[row][col] === 1) {
                        // 活细胞 - 检查生存规则
                        if (rule.survival.includes(neighbors)) {
                            newGrid[row][col] = 1;
                        }
                    } else {
                        // 死细胞 - 检查出生规则
                        if (rule.birth.includes(neighbors)) {
                            newGrid[row][col] = 1;
                        }
                    }
                }
            }

            grid = newGrid;
            generation++;
            updateStats();
        }

        function countNeighbors(row, col) {
            let count = 0;

            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;

                    const newRow = row + i;
                    const newCol = col + j;

                    if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {
                        count += grid[newRow][newCol];
                    }
                }
            }

            return count;
        }

        // 7. 游戏循环
        function gameLoop(currentTime) {
            if (!isRunning) return;

            const deltaTime = currentTime - lastTime;
            const interval = 1000 / currentSpeed;

            if (deltaTime >= interval) {
                computeNextGeneration();
                draw();
                lastTime = currentTime;
            }

            animationId = requestAnimationFrame(gameLoop);
        }

        // 8. 用户交互函数
        function setCell(row, col, state) {
            if (row >= 0 && row < gridSize && col >= 0 && col < gridSize) {
                grid[row][col] = state;
                draw();
                updateStats();
            }
        }

        function getGridPosition(x, y) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const canvasX = (x - rect.left) * scaleX;
            const canvasY = (y - rect.top) * scaleY;
            
            const col = Math.floor(canvasX / cellSize);
            const row = Math.floor(canvasY / cellSize);

            return { row, col };
        }

        function randomize() {
            grid = createEmptyGrid();
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    grid[row][col] = Math.random() > (1 - density/10) ? 1 : 0;
                }
            }
            generation = 0;
            draw();
            updateStats();
        }

        function handleDraw(e) {
            if (!isDrawing || isRunning) return;
            
            const x = e.clientX || (e.touches && e.touches[0].clientX);
            const y = e.clientY || (e.touches && e.touches[0].clientY);
            
            if (x === undefined || y === undefined) return;
            
            const { row, col } = getGridPosition(x, y);
            const cellKey = `${row}-${col}`;
            
            if (row >= 0 && row < gridSize && col >= 0 && col < gridSize && cellKey !== lastDrawnCell) {
                setCell(row, col, 1);
                lastDrawnCell = cellKey;
            }
        }

        function updateRuleDisplay() {
            const rule = config.rules[currentRule];
            currentRuleName.textContent = rule.name;
            currentRuleDesc.textContent = rule.description[0];
            currentRuleDesc2.textContent = rule.description[1];
            currentRuleDesc3.textContent = rule.description[2];
            ruleName.textContent = rule.name.split(' ')[0];
        }

        function updateStats() {
            let liveCount = 0;
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (grid[row][col] === 1) liveCount++;
                }
            }
            
            generationCount.textContent = generation;
            liveCells.textContent = liveCount;
        }

        // 9. 事件监听器
        // 画布事件
        canvas.addEventListener('mousedown', (e) => {
            if (isRunning) return;
            isDrawing = true;
            lastDrawnCell = null;
            handleDraw(e);
        });

        canvas.addEventListener('mousemove', handleDraw);

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
            lastDrawnCell = null;
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
            lastDrawnCell = null;
        });

        // 触摸事件
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (isRunning) return;
            isDrawing = true;
            lastDrawnCell = null;
            handleDraw(e);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            handleDraw(e);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDrawing = false;
            lastDrawnCell = null;
        });

        // 控制按钮事件
        startBtn.addEventListener('click', () => {
            isRunning = true;
            lastTime = 0;
            gameLoop(0);
        });

        pauseBtn.addEventListener('click', () => {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        });

        clearBtn.addEventListener('click', () => {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            grid = createEmptyGrid();
            generation = 0;
            draw();
            updateStats();
        });

        randomBtn.addEventListener('click', () => {
            if (!isRunning) {
                randomize();
            }
        });

        rulesBtn.addEventListener('click', () => {
            rulesSelector.classList.add('show');
            overlay.classList.add('show');
        });

        closeRules.addEventListener('click', () => {
            rulesSelector.classList.remove('show');
            overlay.classList.remove('show');
            updateRuleDisplay();
        });

        overlay.addEventListener('click', () => {
            rulesSelector.classList.remove('show');
            overlay.classList.remove('show');
        });

        // 规则选择事件
        ruleOptions.forEach(option => {
            option.addEventListener('click', () => {
                ruleOptions.forEach(opt => opt.classList.remove('active'));
                option.classList.add('active');
                currentRule = option.getAttribute('data-rule');
            });
        });

        // 滑块事件
        speedSlider.addEventListener('input', (e) => {
            currentSpeed = parseInt(e.target.value);
            speedValue.textContent = currentSpeed;
        });

        sizeSlider.addEventListener('input', (e) => {
            gridSize = parseInt(e.target.value);
            sizeValue.textContent = gridSize;
            cellSize = Math.min(20, Math.floor(700 / gridSize)); // 保持画布大小合理
            updateGridSize();
            grid = createEmptyGrid();
            generation = 0;
            draw();
            updateStats();
        });

        densitySlider.addEventListener('input', (e) => {
            density = parseInt(e.target.value);
            densityValue.textContent = density * 10 + '%';
        });

        // 10. 初始化应用
        init();
    </script>
</body>
</html>
