<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Êó†ÈôêËßÜËßâÁÅµÊÑü - ËÑëÊ¥ûÂ§ßÂºÄÁâà</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
            position: relative;
        }

        .container {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        .scene {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
        }

        .scene.active {
            opacity: 1;
            z-index: 10;
        }

        .scene.cached {
            opacity: 0;
            z-index: 5;
            pointer-events: none;
        }

        .effect-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(15px);
            padding: 20px 25px;
            border-radius: 20px;
            z-index: 10;
            max-width: 350px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.4s ease;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .scene.active .info-panel {
            opacity: 1;
            transform: translateY(0);
        }

        .effect-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .effect-description {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.85);
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .effect-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 10px;
        }

        .tag {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .swipe-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            animation: fadeInOut 4s ease-in-out;
        }

        .swipe-hint.show {
            opacity: 1;
        }

        .swipe-icon {
            font-size: 60px;
            margin-bottom: 15px;
            animation: bounce 2.5s infinite;
        }

        .swipe-text {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.95);
            font-weight: 500;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-15px); }
            60% { transform: translateY(-7px); }
        }

        .scene-counter {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(15px);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 14px;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-weight: 500;
        }

        .cache-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 255, 100, 0.2);
            backdrop-filter: blur(15px);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 12px;
            z-index: 100;
            border: 1px solid rgba(0, 255, 100, 0.4);
            display: none;
            font-weight: 500;
        }

        .cache-indicator.show {
            display: block;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* ‰∏∞ÂØåÁöÑËÉåÊôØÊ†∑Âºè */
        .gradient-bg-1 { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .gradient-bg-2 { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .gradient-bg-3 { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .gradient-bg-4 { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); }
        .gradient-bg-5 { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); }
        .gradient-bg-6 { background: linear-gradient(135deg, #30cfd0 0%, #330867 100%); }
        .gradient-bg-7 { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); }
        .gradient-bg-8 { background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%); }
        
        .particle-bg-1 { background: radial-gradient(ellipse at center, #1e3c72 0%, #2a5298 50%, #000428 100%); }
        .particle-bg-2 { background: radial-gradient(ellipse at center, #ff6b6b 0%, #4ecdc4 50%, #45b7d1 100%); }
        .particle-bg-3 { background: radial-gradient(ellipse at center, #f77062 0%, #fe5196 100%); }
        
        .cyber-bg-1 { background: linear-gradient(45deg, #0f0c29, #302b63, #24243e); }
        .cyber-bg-2 { background: linear-gradient(45deg, #1a1a2e, #16213e, #0f3460); }
        .cyber-bg-3 { background: linear-gradient(45deg, #2d1b69, #0f0c29, #24243e); }
        
        .nature-bg-1 { background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364); }
        .nature-bg-2 { background: linear-gradient(to bottom, #134e5e, #71b280); }
        .nature-bg-3 { background: linear-gradient(to bottom, #1e3c72, #2a5298, #7e8ba3); }
        
        .neon-bg-1 { background: linear-gradient(45deg, #12c2e9, #c471ed, #f64f59); }
        .neon-bg-2 { background: linear-gradient(45deg, #ee9ca7, #ffdde1); }
        .neon-bg-3 { background: linear-gradient(45deg, #a1c4fd, #c2e9fb); }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }

        .loading-overlay.show {
            opacity: 1;
            pointer-events: all;
        }

        .loading-content {
            text-align: center;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 25px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            font-weight: 500;
        }

        /* ÁúºÁêÉÂíåemojiÊïàÊûúÊ†∑Âºè */
        .eye-container {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2;
        }

        .eye {
            width: 80px;
            height: 80px;
            background: white;
            border-radius: 50%;
            position: relative;
            margin: 20px;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
        }

        .iris {
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, #4a90e2, #2c5aa0);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .pupil {
            width: 20px;
            height: 20px;
            background: black;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .emoji-particle {
            position: absolute;
            font-size: 30px;
            pointer-events: none;
            z-index: 3;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
        }
    </style>
</head>
<body>
    <div class="container" id="container">
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-content">
                <div class="loading-spinner"></div>
                <div class="loading-text">Ê≠£Âú®ÁîüÊàêÊñ∞‰∏ñÁïå...</div>
            </div>
        </div>
        
        <div class="scene-counter" id="sceneCounter">Âú∫ÊôØ 1 / ‚àû</div>
        <div class="cache-indicator" id="cacheIndicator">‚ú® ÁºìÂ≠òÂ∑≤Â∞±Áª™</div>
        
        <div class="swipe-hint show" id="swipeHint">
            <div class="swipe-icon">üöÄ</div>
            <div class="swipe-text">Âêë‰∏äÊªëÂä®Êé¢Á¥¢Êó†ÈôêÂèØËÉΩ</div>
        </div>
    </div>

    <!-- Âä†ËΩΩÊâÄÈúÄÁöÑÂ∫ì -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.waves.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.cloud.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.fog.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.net.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.dots.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.rings.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.cells.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.halo.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.tron.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tsparticles@2.x/tsparticles.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>

    <script>
        class AdvancedVisualEffectManager {
            constructor() {
                this.container = document.getElementById('container');
                this.currentScene = null;
                this.cachedScenes = new Map();
                this.sceneIndex = parseInt(localStorage.getItem('sceneIndex') || '1');
                this.effects = [];
                this.isTransitioning = false;
                this.touchStartY = 0;
                this.touchEndY = 0;
                this.maxCacheSize = 5;
                this.usedEffects = new Set(); // ËÆ∞ÂΩïÂ∑≤‰ΩøÁî®ÁöÑÊïàÊûúÁªÑÂêà
                
                this.initEffects();
                this.initEventListeners();
                this.restoreLastScene();
            }

            initEffects() {
                // Â§ßÂπÖÂ¢ûÂä†ÊïàÊûúÁßçÁ±ªÔºåÊØè‰∏™ÊïàÊûúÈÉΩÊúâÊõ¥Â§öÈöèÊú∫ÂèÇÊï∞
                this.effects = [
                    // VantaÁ≥ªÂàó - Â¢ûÂº∫Áâà
                    {
                        name: 'Vanta Waves Êµ∑Ê¥ã‰πãÂøÉ',
                        description: 'ÈöèÊú∫È¢úËâ≤ÁöÑÊµ∑Ê¥ãÊ≥¢Êµ™ÔºåÊ∑±ÊµÖ‰∏ç‰∏ÄÁöÑÂæãÂä®',
                        type: 'vanta',
                        effect: 'waves',
                        bgClass: this.getRandomGradient(),
                        randomParams: {
                            color: () => Math.random() * 0xffffff,
                            speed: 0.5 + Math.random() * 2,
                            scale: 0.5 + Math.random() * 2
                        }
                    },
                    {
                        name: 'Vanta Cloud Ê¢¶Âπª‰∫ëÊµ∑',
                        description: 'Â§öÂΩ©‰∫ëÂ±ÇÊºÇÊµÆÔºåÈöèÊú∫ÂØÜÂ∫¶ÂíåÈÄüÂ∫¶',
                        type: 'vanta',
                        effect: 'cloud',
                        bgClass: this.getRandomGradient(),
                        randomParams: {
                            color: () => Math.random() * 0xffffff,
                            speed: 0.3 + Math.random() * 1.5,
                            scale: 0.8 + Math.random() * 1.5
                        }
                    },
                    {
                        name: 'Vanta Fog Á•ûÁßòËø∑Èõæ',
                        description: 'ÈöèÊú∫ÊµìÂ∫¶ÁöÑËø∑ÈõæÊïàÊûú',
                        type: 'vanta',
                        effect: 'fog',
                        bgClass: this.getRandomNature(),
                        randomParams: {
                            color: () => Math.random() * 0xffffff,
                            speed: 0.2 + Math.random() * 1,
                            scale: 0.5 + Math.random() * 2
                        }
                    },
                    {
                        name: 'Vanta Net Á•ûÁªèÁΩëÁªú',
                        description: 'ÈöèÊú∫ËøûÊé•ÂØÜÂ∫¶ÁöÑÁ•ûÁªèÁΩëÁªú',
                        type: 'vanta',
                        effect: 'net',
                        bgClass: this.getRandomCyber(),
                        randomParams: {
                            color: () => Math.random() * 0xffffff,
                            speed: 0.5 + Math.random() * 2,
                            scale: 0.8 + Math.random() * 1.5
                        }
                    },
                    {
                        name: 'Vanta Dots Á≤íÂ≠êÊòü‰∫ë',
                        description: 'ÈöèÊú∫Â§ßÂ∞èÂíåÈ¢úËâ≤ÁöÑÁ≤íÂ≠êÁÇπÈòµ',
                        type: 'vanta',
                        effect: 'dots',
                        bgClass: this.getRandomParticle(),
                        randomParams: {
                            color: () => Math.random() * 0xffffff,
                            speed: 0.3 + Math.random() * 1.8,
                            scale: 0.6 + Math.random() * 1.8
                        }
                    },
                    {
                        name: 'Vanta Rings ÂÆáÂÆôÂÖâÁéØ',
                        description: 'ÈöèÊú∫È¢ëÁéáÁöÑÁéØÂΩ¢Ê≥¢Á∫π',
                        type: 'vanta',
                        effect: 'rings',
                        bgClass: this.getRandomCyber(),
                        randomParams: {
                            color: () => Math.random() * 0xffffff,
                            speed: 0.4 + Math.random() * 1.6,
                            scale: 0.7 + Math.random() * 1.6
                        }
                    },
                    {
                        name: 'Vanta Cells ÁîüÂëΩÁªÜËÉû',
                        description: 'ÈöèÊú∫ÂàÜË£ÇÈÄüÂ∫¶ÁöÑÁªÜËÉûÊïàÊûú',
                        type: 'vanta',
                        effect: 'cells',
                        bgClass: this.getRandomNeon(),
                        randomParams: {
                            color: () => Math.random() * 0xffffff,
                            speed: 0.6 + Math.random() * 2,
                            scale: 0.5 + Math.random() * 2
                        }
                    },
                    {
                        name: 'Vanta Halo Á•ûÂú£ÂÖâÁéØ',
                        description: 'ÈöèÊú∫‰∫ÆÂ∫¶ÁöÑÂÖâÁéØÊïàÊûú',
                        type: 'vanta',
                        effect: 'halo',
                        bgClass: this.getRandomGradient(),
                        randomParams: {
                            color: () => Math.random() * 0xffffff,
                            speed: 0.3 + Math.random() * 1.5,
                            scale: 0.8 + Math.random() * 1.5
                        }
                    },
                    {
                        name: 'Vanta Tron ËµõÂçöÊúãÂÖã',
                        description: 'ÈöèÊú∫ÈÄüÂ∫¶ÁöÑÂÖâÁ∫øËøΩË∏™',
                        type: 'vanta',
                        effect: 'tron',
                        bgClass: this.getRandomCyber(),
                        randomParams: {
                            color: () => Math.random() * 0xffffff,
                            speed: 0.5 + Math.random() * 2.5,
                            scale: 0.6 + Math.random() * 2
                        }
                    },
                    
                    // ÁúºÁêÉËøΩË∏™ÊïàÊûú
                    {
                        name: 'üëÄ ÂçÉÁúºËøΩË∏™',
                        description: 'ÈöèÊú∫Êï∞ÈáèÂíåÈ¢úËâ≤ÁöÑÁúºÁêÉËøΩË∏™Èº†Ê†á',
                        type: 'eyes',
                        bgClass: this.getRandomGradient(),
                        randomParams: {
                            eyeCount: 5 + Math.floor(Math.random() * 15),
                            eyeSize: 40 + Math.random() * 60,
                            irisColor: () => `hsl(${Math.random() * 360}, 70%, 50%)`
                        }
                    },
                    {
                        name: 'üëÅÔ∏è È≠îÊ≥ï‰πãÁúº',
                        description: '‰ºöÂèëÂ∞ÑÂÖâÊùüÁöÑÁ•ûÁßòÁúºÁùõ',
                        type: 'magic-eyes',
                        bgClass: this.getRandomCyber(),
                        randomParams: {
                            eyeCount: 3 + Math.floor(Math.random() * 8),
                            beamColor: () => `hsl(${Math.random() * 360}, 100%, 50%)`
                        }
                    },
                    
                    // EmojiÁ≤íÂ≠êÊïàÊûú
                    {
                        name: 'üòä EmojiÈõ®',
                        description: 'ÈöèÊú∫emojiË°®ÊÉÖ‰ªéÂ§©ËÄåÈôç',
                        type: 'emoji-rain',
                        bgClass: this.getRandomGradient(),
                        randomParams: {
                            emojis: ['üòÄ', 'üòé', 'ü§ñ', 'üëΩ', 'ü¶Ñ', 'üåà', '‚≠ê', 'üí´', 'üî•', '‚ùÑÔ∏è'],
                            speed: 1 + Math.random() * 3,
                            density: 20 + Math.floor(Math.random() * 40)
                        }
                    },
                    {
                        name: 'üí´ ÊòüÁ©∫Emoji',
                        description: 'ÈöèÊú∫emojiÂú®ÊòüÁ©∫ÊºÇÊµÆ',
                        type: 'emoji-stars',
                        bgClass: this.getRandomParticle(),
                        randomParams: {
                            emojis: ['‚≠ê', 'üåü', '‚ú®', 'üí´', 'üå†', '‚òÑÔ∏è', 'üåå', 'üåô', '‚òÄÔ∏è', 'ü™ê'],
                            speed: 0.5 + Math.random() * 2,
                            density: 15 + Math.floor(Math.random() * 35)
                        }
                    },
                    {
                        name: 'üé® ÂΩ©ÁªòEmoji',
                        description: 'ÈöèÊú∫emojiÁªòÂà∂Ëâ∫ÊúØÂõæÊ°à',
                        type: 'emoji-art',
                        bgClass: this.getRandomNeon(),
                        randomParams: {
                            emojis: ['üé®', 'üñåÔ∏è', 'üñºÔ∏è', '‚úèÔ∏è', 'üìê', 'üé≠', 'üé™', 'üéØ', 'üé≤', 'üé∏'],
                            pattern: Math.floor(Math.random() * 5)
                        }
                    },
                    
                    // Three.jsÂ¢ûÂº∫ÊïàÊûú
                    {
                        name: 'üåå 3DÊòüÊ≤≥',
                        description: 'ÈöèÊú∫È¢úËâ≤ÂíåÂØÜÂ∫¶ÁöÑ3DÁ≤íÂ≠êÊòüÊ≤≥',
                        type: 'threejs-galaxy',
                        bgClass: this.getRandomParticle(),
                        randomParams: {
                            particleCount: 3000 + Math.floor(Math.random() * 7000),
                            color: () => Math.random() * 0xffffff,
                            rotationSpeed: 0.001 + Math.random() * 0.005,
                            spiral: Math.random() > 0.5
                        }
                    },
                    {
                        name: 'üîÆ Ê∞¥Êô∂Âá†‰Ωï',
                        description: 'ÈöèÊú∫ÂΩ¢Áä∂ÁöÑÊ∞¥Êô∂Âá†‰Ωï‰Ωì',
                        type: 'threejs-crystals',
                        bgClass: this.getRandomCyber(),
                        randomParams: {
                            shape: ['box', 'sphere', 'tetrahedron', 'octahedron'][Math.floor(Math.random() * 4)],
                            count: 5 + Math.floor(Math.random() * 15),
                            color: () => Math.random() * 0xffffff,
                            rotationSpeed: 0.005 + Math.random() * 0.02
                        }
                    },
                    {
                        name: 'üåä 3DÊµÅ‰Ωì',
                        description: 'ÈöèÊú∫È¢úËâ≤ÁöÑ3DÊµÅ‰ΩìÂä®Áîª',
                        type: 'threejs-fluid',
                        bgClass: this.getRandomGradient(),
                        randomParams: {
                            waveCount: 3 + Math.floor(Math.random() * 7),
                            amplitude: 0.5 + Math.random() * 2,
                            frequency: 0.01 + Math.random() * 0.05,
                            color: () => Math.random() * 0xffffff
                        }
                    },
                    
                    // tsParticlesÂ¢ûÂº∫
                    {
                        name: 'ü´ß ÂΩ©ËôπÊ∞îÊ≥°',
                        description: 'ÈöèÊú∫ÂΩ©ËôπËâ≤ÁöÑÊ∞îÊ≥°ÊïàÊûú',
                        type: 'tsparticles-rainbow',
                        bgClass: this.getRandomGradient(),
                        randomParams: {
                            particleCount: 50 + Math.floor(Math.random() * 100),
                            colors: ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'],
                            speed: 1 + Math.random() * 3,
                            size: 5 + Math.random() * 15
                        }
                    },
                    {
                        name: '‚ùÑÔ∏è ÂÜ∞Êô∂Èõ™Ëä±',
                        description: 'ÈöèÊú∫ÂΩ¢Áä∂ÁöÑÂÜ∞Êô∂Èõ™Ëä±',
                        type: 'tsparticles-snowflakes',
                        bgClass: this.getRandomNature(),
                        randomParams: {
                            particleCount: 80 + Math.floor(Math.random() * 120),
                            snowflakeTypes: ['‚ùÑÔ∏è', '‚ùÖ', '‚ùÜ', '‚úª', '‚úº', '‚ùâ'],
                            speed: 0.5 + Math.random() * 2,
                            wind: Math.random() * 2 - 1
                        }
                    },
                    {
                        name: 'üî• ÁÅ´ÁÑ∞Á≤íÂ≠ê',
                        description: 'ÈöèÊú∫È¢úËâ≤ÁöÑÁÅ´ÁÑ∞‰∏äÂçáÊïàÊûú',
                        type: 'tsparticles-fire',
                        bgClass: this.getRandomGradient(),
                        randomParams: {
                            particleCount: 100 + Math.floor(Math.random() * 150),
                            colors: ['#ff4500', '#ff6347', '#ff8c00', '#ffd700', '#ffff00'],
                            speed: 2 + Math.random() * 4,
                            spread: Math.PI / 6 + Math.random() * Math.PI / 6
                        }
                    },
                    
                    // P5.jsÂàõÊÑèÊïàÊûú
                    {
                        name: 'üß¨ DNAËû∫Êóã',
                        description: 'ÈöèÊú∫È¢úËâ≤ÁöÑDNAÂèåËû∫ÊóãÁªìÊûÑ',
                        type: 'p5js-dna',
                        bgClass: this.getRandomCyber(),
                        randomParams: {
                            color1: () => `hsl(${Math.random() * 360}, 70%, 50%)`,
                            color2: () => `hsl(${Math.random() * 360}, 70%, 50%)`,
                            rotationSpeed: 0.01 + Math.random() * 0.03,
                            helixCount: 2 + Math.floor(Math.random() * 3)
                        }
                    },
                    {
                        name: 'üåä ÂàÜÂΩ¢Êµ∑Ê¥ã',
                        description: 'ÈöèÊú∫ÂèÇÊï∞ÁöÑÂàÜÂΩ¢Êµ∑Êµ™',
                        type: 'p5js-fractal',
                        bgClass: this.getRandomNature(),
                        randomParams: {
                            iterations: 3 + Math.floor(Math.random() * 4),
                            amplitude: 20 + Math.random() * 80,
                            frequency: 0.01 + Math.random() * 0.05,
                            color: () => `hsl(${180 + Math.random() * 60}, 70%, 50%)`
                        }
                    },
                    {
                        name: 'üéÜ ÁÉüËä±ÁªΩÊîæ',
                        description: 'ÈöèÊú∫È¢úËâ≤ÁöÑÁÉüËä±ÊïàÊûú',
                        type: 'p5js-fireworks',
                        bgClass: this.getRandomParticle(),
                        randomParams: {
                            fireworkCount: 1 + Math.floor(Math.random() * 4),
                            particleCount: 50 + Math.floor(Math.random() * 100),
                            colors: () => [`hsl(${Math.random() * 360}, 100%, 50%)`],
                            gravity: 0.05 + Math.random() * 0.15
                        }
                    },
                    {
                        name: 'üå∏ Ê®±Ëä±È£òËêΩ',
                        description: 'ÈöèÊú∫ÂØÜÂ∫¶ÁöÑÊ®±Ëä±È£òËêΩ',
                        type: 'p5js-sakura',
                        bgClass: this.getRandomGradient(),
                        randomParams: {
                            petalCount: 30 + Math.floor(Math.random() * 70),
                            speed: 1 + Math.random() * 2,
                            size: 10 + Math.random() * 20,
                            windStrength: Math.random() * 2
                        }
                    },
                    {
                        name: 'üêü È±ºÁæ§Ê∏∏Âä®',
                        description: 'ÈöèÊú∫Ë°å‰∏∫ÁöÑÈ±ºÁæ§Ê®°Êãü',
                        type: 'p5js-fish',
                        bgClass: this.getRandomNature(),
                        randomParams: {
                            fishCount: 20 + Math.floor(Math.random() * 40),
                            speed: 1 + Math.random() * 3,
                            cohesion: Math.random() * 2,
                            separation: Math.random() * 2,
                            alignment: Math.random() * 2
                        }
                    },
                    
                    // ÁâπÊÆäÁ¨¶Âè∑ÊïàÊûú
                    {
                        name: '‚ö° Èó™ÁîµÈ£éÊö¥',
                        description: 'ÈöèÊú∫Ë∑ØÂæÑÁöÑÈó™ÁîµÊïàÊûú',
                        type: 'lightning',
                        bgClass: this.getRandomCyber(),
                        randomParams: {
                            boltCount: 1 + Math.floor(Math.random() * 5),
                            color: () => `hsl(${180 + Math.random() * 60}, 100%, 70%)`,
                            thickness: 2 + Math.random() * 4,
                            branches: Math.floor(Math.random() * 4)
                        }
                    },
                    {
                        name: 'üåà ÂΩ©ËôπÊ°•',
                        description: 'ÈöèÊú∫ÂºßÂ∫¶ÁöÑÂΩ©ËôπÊïàÊûú',
                        type: 'rainbow',
                        bgClass: this.getRandomGradient(),
                        randomParams: {
                            arcHeight: 0.3 + Math.random() * 0.4,
                            thickness: 20 + Math.random() * 40,
                            opacity: 0.3 + Math.random() * 0.5,
                            animationSpeed: 0.001 + Math.random() * 0.003
                        }
                    },
                    {
                        name: 'üé≠ Èù¢ÂÖ∑Ëàû‰ºö',
                        description: 'ÈöèÊú∫emojiÈù¢ÂÖ∑ÊóãËΩ¨ËàûËπà',
                        type: 'mask-dance',
                        bgClass: this.getRandomNeon(),
                        randomParams: {
                            masks: ['üé≠', 'üé™', 'üé®', 'üéØ', 'üé≤', 'üé∏', 'üé∫', 'üéª'],
                            count: 8 + Math.floor(Math.random() * 16),
                            speed: 0.01 + Math.random() * 0.03,
                            radius: 100 + Math.random() * 200
                        }
                    },
                    {
                        name: 'üîÆ È≠îÊ≥ïÈòµ',
                        description: 'ÈöèÊú∫Á¨¶Âè∑ÁöÑÈ≠îÊ≥ïÈòµÊóãËΩ¨',
                        type: 'magic-circle',
                        bgClass: this.getRandomCyber(),
                        randomParams: {
                            symbols: ['‚≠ê', '‚ú¶', '‚óÜ', '‚óè', '‚ñ≤', '‚ñ†', '‚ô¶', '‚ô†', '‚ô£', '‚ô•'],
                            ringCount: 3 + Math.floor(Math.random() * 4),
                            rotationSpeed: 0.005 + Math.random() * 0.02,
                            glowColor: () => `hsl(${Math.random() * 360}, 100%, 50%)`
                        }
                    }
                ];
            }

            // ÈöèÊú∫ËÉåÊôØÈÄâÊã©Âô®
            getRandomGradient() {
                const gradients = ['gradient-bg-1', 'gradient-bg-2', 'gradient-bg-3', 'gradient-bg-4', 'gradient-bg-5', 'gradient-bg-6', 'gradient-bg-7', 'gradient-bg-8'];
                return gradients[Math.floor(Math.random() * gradients.length)];
            }

            getRandomParticle() {
                const particles = ['particle-bg-1', 'particle-bg-2', 'particle-bg-3'];
                return particles[Math.floor(Math.random() * particles.length)];
            }

            getRandomCyber() {
                const cyber = ['cyber-bg-1', 'cyber-bg-2', 'cyber-bg-3'];
                return cyber[Math.floor(Math.random() * cyber.length)];
            }

            getRandomNature() {
                const nature = ['nature-bg-1', 'nature-bg-2', 'nature-bg-3'];
                return nature[Math.floor(Math.random() * nature.length)];
            }

            getRandomNeon() {
                const neon = ['neon-bg-1', 'neon-bg-2', 'neon-bg-3'];
                return neon[Math.floor(Math.random() * neon.length)];
            }

            // Êô∫ËÉΩÈÄâÊã©ÊïàÊûúÔºåÈÅøÂÖçÈáçÂ§ç
            selectRandomEffect() {
                let availableEffects = this.effects.filter(effect => {
                    const effectKey = `${effect.type}-${effect.effect || effect.name}`;
                    return !this.usedEffects.has(effectKey) || this.usedEffects.size >= this.effects.length;
                });

                if (availableEffects.length === 0) {
                    this.usedEffects.clear();
                    availableEffects = this.effects;
                }

                const selectedEffect = availableEffects[Math.floor(Math.random() * availableEffects.length)];
                const effectKey = `${selectedEffect.type}-${selectedEffect.effect || selectedEffect.name}`;
                this.usedEffects.add(effectKey);

                return selectedEffect;
            }

            initEventListeners() {
                this.container.addEventListener('wheel', (e) => {
                    if (this.isTransitioning) return;
                    if (e.deltaY < 0) {
                        this.nextScene();
                    }
                }, { passive: true });

                this.container.addEventListener('touchstart', (e) => {
                    this.touchStartY = e.touches[0].clientY;
                }, { passive: true });

                this.container.addEventListener('touchend', (e) => {
                    this.touchEndY = e.changedTouches[0].clientY;
                    this.handleSwipe();
                }, { passive: true });

                document.addEventListener('keydown', (e) => {
                    if (this.isTransitioning) return;
                    if (e.key === 'ArrowUp' || e.key === ' ') {
                        e.preventDefault();
                        this.nextScene();
                    }
                });

                window.addEventListener('beforeunload', () => {
                    this.saveState();
                });
            }

            handleSwipe() {
                const swipeDistance = this.touchStartY - this.touchEndY;
                if (Math.abs(swipeDistance) > 50) {
                    if (swipeDistance > 0) {
                        this.nextScene();
                    }
                }
            }

            restoreLastScene() {
                const savedEffect = localStorage.getItem('currentEffect');
                if (savedEffect) {
                    try {
                        const effect = JSON.parse(savedEffect);
                        this.createScene(effect);
                    } catch (e) {
                        this.createScene();
                    }
                } else {
                    this.createScene();
                }
                
                setTimeout(() => {
                    document.getElementById('swipeHint').classList.remove('show');
                }, 4000);
            }

            saveState() {
                if (this.currentScene && this.currentScene.effect) {
                    localStorage.setItem('currentEffect', JSON.stringify(this.currentScene.effect));
                    localStorage.setItem('sceneIndex', this.sceneIndex.toString());
                }
            }

            async createScene(effect = null) {
                const selectedEffect = effect || this.selectRandomEffect();
                const sceneId = `scene-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                
                if (this.cachedScenes.has(sceneId)) {
                    this.switchToScene(this.cachedScenes.get(sceneId));
                    return;
                }

                const scene = document.createElement('div');
                scene.className = `scene ${selectedEffect.bgClass}`;
                scene.id = sceneId;
                
                const canvas = document.createElement('div');
                canvas.className = 'effect-canvas';
                canvas.id = `effect-${Date.now()}`;
                
                const infoPanel = document.createElement('div');
                infoPanel.className = 'info-panel';
                
                // ÁîüÊàêÊ†áÁ≠æ
                const tags = this.generateTags(selectedEffect);
                
                infoPanel.innerHTML = `
                    <div class="effect-title">${selectedEffect.name}</div>
                    <div class="effect-description">${selectedEffect.description}</div>
                    <div class="effect-tags">${tags.map(tag => `<span class="tag">${tag}</span>`).join('')}</div>
                `;
                
                scene.appendChild(canvas);
                scene.appendChild(infoPanel);
                scene.effect = selectedEffect;
                
                this.container.appendChild(scene);
                
                await this.initEffect(selectedEffect, canvas);
                
                this.cachedScenes.set(sceneId, scene);
                
                if (this.cachedScenes.size > this.maxCacheSize) {
                    const oldestScene = this.cachedScenes.keys().next().value;
                    this.removeScene(oldestScene);
                }
                
                this.switchToScene(scene);
            }

            generateTags(effect) {
                const tags = [];
                if (effect.type.includes('vanta')) tags.push('Vanta');
                if (effect.type.includes('threejs')) tags.push('3D');
                if (effect.type.includes('tsparticles')) tags.push('Á≤íÂ≠ê');
                if (effect.type.includes('p5js')) tags.push('ÂàõÊÑè');
                if (effect.type.includes('emoji')) tags.push('Emoji');
                if (effect.type.includes('eye')) tags.push('ÁúºÁêÉ');
                if (effect.randomParams) {
                    if (effect.randomParams.speed) tags.push('Âä®ÊÄÅ');
                    if (effect.randomParams.color) tags.push('ÂΩ©Ëâ≤');
                }
                if (tags.length === 0) tags.push('ÁâπÊïà');
                return tags.slice(0, 3);
            }

            switchToScene(scene) {
                if (this.currentScene) {
                    this.currentScene.classList.remove('active');
                    this.currentScene.classList.add('cached');
                }
                
                scene.classList.remove('cached');
                scene.classList.add('active');
                this.currentScene = scene;
                
                this.sceneIndex++;
                document.getElementById('sceneCounter').textContent = `Âú∫ÊôØ ${this.sceneIndex} / ‚àû`;
                
                if (this.cachedScenes.size > 1) {
                    const indicator = document.getElementById('cacheIndicator');
                    indicator.classList.add('show');
                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                }
                
                this.saveState();
            }

            removeScene(sceneId) {
                const scene = this.cachedScenes.get(sceneId);
                if (scene && scene !== this.currentScene) {
                    if (scene.effectInstance) {
                        this.destroyEffect(scene.effectInstance);
                    }
                    scene.remove();
                    this.cachedScenes.delete(sceneId);
                }
            }

            async initEffect(effect, container) {
                return new Promise((resolve) => {
                    let effectInstance = null;
                    
                    switch(effect.type) {
                        case 'vanta':
                            this.initVantaEffect(effect, container, (instance) => {
                                effectInstance = instance;
                                resolve();
                            });
                            break;
                        case 'eyes':
                            effectInstance = this.initEyesEffect(effect, container);
                            resolve();
                            break;
                        case 'magic-eyes':
                            effectInstance = this.initMagicEyesEffect(effect, container);
                            resolve();
                            break;
                        case 'emoji-rain':
                            effectInstance = this.initEmojiRainEffect(effect, container);
                            resolve();
                            break;
                        case 'emoji-stars':
                            effectInstance = this.initEmojiStarsEffect(effect, container);
                            resolve();
                            break;
                        case 'emoji-art':
                            effectInstance = this.initEmojiArtEffect(effect, container);
                            resolve();
                            break;
                        case 'threejs-galaxy':
                            effectInstance = this.initThreeJSGalaxyEffect(effect, container);
                            resolve();
                            break;
                        case 'threejs-crystals':
                            effectInstance = this.initThreeJSCrystalsEffect(effect, container);
                            resolve();
                            break;
                        case 'threejs-fluid':
                            effectInstance = this.initThreeJSFluidEffect(effect, container);
                            resolve();
                            break;
                        case 'tsparticles-rainbow':
                            this.initTsParticlesRainbowEffect(effect, container, (instance) => {
                                effectInstance = instance;
                                resolve();
                            });
                            break;
                        case 'tsparticles-snowflakes':
                            this.initTsParticlesSnowflakesEffect(effect, container, (instance) => {
                                effectInstance = instance;
                                resolve();
                            });
                            break;
                        case 'tsparticles-fire':
                            this.initTsParticlesFireEffect(effect, container, (instance) => {
                                effectInstance = instance;
                                resolve();
                            });
                            break;
                        case 'p5js-dna':
                            effectInstance = this.initP5JSDNAEffect(effect, container);
                            resolve();
                            break;
                        case 'p5js-fractal':
                            effectInstance = this.initP5JSFractalEffect(effect, container);
                            resolve();
                            break;
                        case 'p5js-fireworks':
                            effectInstance = this.initP5JSFireworksEffect(effect, container);
                            resolve();
                            break;
                        case 'p5js-sakura':
                            effectInstance = this.initP5JSSakuraEffect(effect, container);
                            resolve();
                            break;
                        case 'p5js-fish':
                            effectInstance = this.initP5JSFishEffect(effect, container);
                            resolve();
                            break;
                        case 'lightning':
                            effectInstance = this.initLightningEffect(effect, container);
                            resolve();
                            break;
                        case 'rainbow':
                            effectInstance = this.initRainbowEffect(effect, container);
                            resolve();
                            break;
                        case 'mask-dance':
                            effectInstance = this.initMaskDanceEffect(effect, container);
                            resolve();
                            break;
                        case 'magic-circle':
                            effectInstance = this.initMagicCircleEffect(effect, container);
                            resolve();
                            break;
                        default:
                            resolve();
                    }
                    
                    const scene = container.parentElement;
                    scene.effectInstance = effectInstance;
                });
            }

            // ÁúºÁêÉÊïàÊûú
            initEyesEffect(effect, container) {
                const eyeContainer = document.createElement('div');
                eyeContainer.className = 'eye-container';
                eyeContainer.style.display = 'grid';
                eyeContainer.style.gridTemplateColumns = 'repeat(auto-fit, minmax(100px, 1fr))';
                eyeContainer.style.gap = '20px';
                eyeContainer.style.padding = '40px';
                
                const params = effect.randomParams;
                const eyeCount = params.eyeCount;
                
                for (let i = 0; i < eyeCount; i++) {
                    const eye = document.createElement('div');
                    eye.className = 'eye';
                    eye.style.width = params.eyeSize + 'px';
                    eye.style.height = params.eyeSize + 'px';
                    
                    const iris = document.createElement('div');
                    iris.className = 'iris';
                    iris.style.width = (params.eyeSize * 0.5) + 'px';
                    iris.style.height = (params.eyeSize * 0.5) + 'px';
                    iris.style.background = `radial-gradient(circle, ${params.irisColor()}, ${params.irisColor()}dd)`;
                    
                    const pupil = document.createElement('div');
                    pupil.className = 'pupil';
                    pupil.style.width = (params.eyeSize * 0.25) + 'px';
                    pupil.style.height = (params.eyeSize * 0.25) + 'px';
                    
                    iris.appendChild(pupil);
                    eye.appendChild(iris);
                    eyeContainer.appendChild(eye);
                    
                    // ÁúºÁêÉË∑üË∏™Èº†Ê†á
                    container.addEventListener('mousemove', (e) => {
                        const rect = eye.getBoundingClientRect();
                        const eyeCenterX = rect.left + rect.width / 2;
                        const eyeCenterY = rect.top + rect.height / 2;
                        
                        const angle = Math.atan2(e.clientY - eyeCenterY, e.clientX - eyeCenterX);
                        const distance = Math.min(15, Math.hypot(e.clientX - eyeCenterX, e.clientY - eyeCenterY) / 10);
                        
                        const pupilX = Math.cos(angle) * distance;
                        const pupilY = Math.sin(angle) * distance;
                        
                        iris.style.transform = `translate(calc(-50% + ${pupilX}px), calc(-50% + ${pupilY}px))`;
                    });
                }
                
                container.appendChild(eyeContainer);
                
                return {
                    destroy: () => {
                        container.removeChild(eyeContainer);
                    }
                };
            }

            // È≠îÊ≥ïÁúºÁùõÊïàÊûú
            initMagicEyesEffect(effect, container) {
                const eyeContainer = document.createElement('div');
                eyeContainer.className = 'eye-container';
                eyeContainer.style.display = 'grid';
                eyeContainer.style.gridTemplateColumns = 'repeat(auto-fit, minmax(150px, 1fr))';
                eyeContainer.style.gap = '30px';
                eyeContainer.style.padding = '40px';
                
                const params = effect.randomParams;
                const eyeCount = params.eyeCount;
                
                for (let i = 0; i < eyeCount; i++) {
                    const eyeWrapper = document.createElement('div');
                    eyeWrapper.style.position = 'relative';
                    eyeWrapper.style.display = 'inline-block';
                    
                    const eye = document.createElement('div');
                    eye.className = 'eye';
                    eye.style.width = '100px';
                    eye.style.height = '100px';
                    eye.style.background = `radial-gradient(circle, #1a1a2a, #000)`;
                    eye.style.boxShadow = `0 0 30px ${params.beamColor()}`;
                    
                    const iris = document.createElement('div');
                    iris.className = 'iris';
                    iris.style.width = '50px';
                    iris.style.height = '50px';
                    iris.style.background = `radial-gradient(circle, ${params.beamColor()}, #000)`;
                    
                    const pupil = document.createElement('div');
                    pupil.className = 'pupil';
                    pupil.style.width = '25px';
                    pupil.style.height = '25px';
                    pupil.style.background = '#fff';
                    pupil.style.boxShadow = `0 0 20px ${params.beamColor()}`;
                    
                    iris.appendChild(pupil);
                    eye.appendChild(iris);
                    eyeWrapper.appendChild(eye);
                    
                    // Ê∑ªÂä†ÂÖâÊùü
                    const beam = document.createElement('div');
                    beam.style.position = 'absolute';
                    beam.style.top = '50%';
                    beam.style.left = '50%';
                    beam.style.width = '200px';
                    beam.style.height = '2px';
                    beam.style.background = `linear-gradient(90deg, ${params.beamColor()}, transparent)`;
                    beam.style.transformOrigin = 'left center';
                    beam.style.opacity = '0.6';
                    beam.style.animation = `beam-rotate ${3 + Math.random() * 4}s linear infinite`;
                    
                    eyeWrapper.appendChild(beam);
                    eyeContainer.appendChild(eyeWrapper);
                }
                
                // Ê∑ªÂä†ÂÖâÊùüÊóãËΩ¨Âä®Áîª
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes beam-rotate {
                        from { transform: translate(-50%, -50%) rotate(0deg); }
                        to { transform: translate(-50%, -50%) rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
                
                container.appendChild(eyeContainer);
                
                return {
                    destroy: () => {
                        container.removeChild(eyeContainer);
                        document.head.removeChild(style);
                    }
                };
            }

            // EmojiÈõ®ÊïàÊûú
            initEmojiRainEffect(effect, container) {
                const params = effect.randomParams;
                const emojis = [];
                
                const createEmoji = () => {
                    const emoji = document.createElement('div');
                    emoji.className = 'emoji-particle';
                    emoji.textContent = params.emojis[Math.floor(Math.random() * params.emojis.length)];
                    emoji.style.left = Math.random() * 100 + '%';
                    emoji.style.top = '-50px';
                    emoji.style.fontSize = (20 + Math.random() * 30) + 'px';
                    emoji.style.animationDuration = (5 / params.speed) + 's';
                    
                    container.appendChild(emoji);
                    emojis.push(emoji);
                    
                    let position = -50;
                    const fall = setInterval(() => {
                        position += params.speed * 2;
                        emoji.style.top = position + 'px';
                        
                        if (position > window.innerHeight + 50) {
                            clearInterval(fall);
                            container.removeChild(emoji);
                            emojis.splice(emojis.indexOf(emoji), 1);
                        }
                    }, 50);
                };
                
                const interval = setInterval(() => {
                    if (emojis.length < params.density) {
                        createEmoji();
                    }
                }, 200);
                
                return {
                    destroy: () => {
                        clearInterval(interval);
                        emojis.forEach(emoji => {
                            if (emoji.parentNode) {
                                container.removeChild(emoji);
                            }
                        });
                    }
                };
            }

            // EmojiÊòüÁ©∫ÊïàÊûú
            initEmojiStarsEffect(effect, container) {
                const params = effect.randomParams;
                const emojis = [];
                
                for (let i = 0; i < params.density; i++) {
                    const emoji = document.createElement('div');
                    emoji.className = 'emoji-particle';
                    emoji.textContent = params.emojis[Math.floor(Math.random() * params.emojis.length)];
                    emoji.style.left = Math.random() * 100 + '%';
                    emoji.style.top = Math.random() * 100 + '%';
                    emoji.style.fontSize = (15 + Math.random() * 25) + 'px';
                    emoji.style.animationDuration = (3 + Math.random() * 4) + 's';
                    emoji.style.animationDelay = Math.random() * 3 + 's';
                    
                    container.appendChild(emoji);
                    emojis.push(emoji);
                }
                
                return {
                    destroy: () => {
                        emojis.forEach(emoji => {
                            if (emoji.parentNode) {
                                container.removeChild(emoji);
                            }
                        });
                    }
                };
            }

            // EmojiËâ∫ÊúØÊïàÊûú
            initEmojiArtEffect(effect, container) {
                const params = effect.randomParams;
                const emojis = [];
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                for (let i = 0; i < 50; i++) {
                    const emoji = document.createElement('div');
                    emoji.className = 'emoji-particle';
                    emoji.textContent = params.emojis[Math.floor(Math.random() * params.emojis.length)];
                    emoji.style.fontSize = (20 + Math.random() * 40) + 'px';
                    
                    const angle = (i / 50) * Math.PI * 2;
                    const radius = 100 + Math.random() * 200;
                    
                    emoji.style.left = (centerX + Math.cos(angle) * radius) + 'px';
                    emoji.style.top = (centerY + Math.sin(angle) * radius) + 'px';
                    emoji.style.animationDuration = (2 + Math.random() * 3) + 's';
                    emoji.style.animationDelay = Math.random() * 2 + 's';
                    
                    container.appendChild(emoji);
                    emojis.push(emoji);
                }
                
                return {
                    destroy: () => {
                        emojis.forEach(emoji => {
                            if (emoji.parentNode) {
                                container.removeChild(emoji);
                            }
                        });
                    }
                };
            }

            // Three.jsÊòüÊ≤≥ÊïàÊûú
            initThreeJSGalaxyEffect(effect, container) {
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                
                renderer.setSize(window.innerWidth, window.innerHeight);
                container.appendChild(renderer.domElement);
                
                const params = effect.randomParams;
                const particlesGeometry = new THREE.BufferGeometry();
                const particlesCount = params.particleCount;
                const posArray = new Float32Array(particlesCount * 3);
                const colorsArray = new Float32Array(particlesCount * 3);
                
                const color = new THREE.Color(params.color());
                
                for(let i = 0; i < particlesCount * 3; i += 3) {
                    if (params.spiral) {
                        const angle = (i / 3) * 0.1;
                        const radius = (i / 3) * 0.01;
                        posArray[i] = Math.cos(angle) * radius;
                        posArray[i + 1] = (Math.random() - 0.5) * 2;
                        posArray[i + 2] = Math.sin(angle) * radius;
                    } else {
                        posArray[i] = (Math.random() - 0.5) * 20;
                        posArray[i + 1] = (Math.random() - 0.5) * 20;
                        posArray[i + 2] = (Math.random() - 0.5) * 20;
                    }
                    
                    colorsArray[i] = color.r;
                    colorsArray[i + 1] = color.g;
                    colorsArray[i + 2] = color.b;
                }
                
                particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));
                
                const particlesMaterial = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
                scene.add(particlesMesh);
                
                camera.position.z = 10;
                
                const animate = () => {
                    requestAnimationFrame(animate);
                    
                    particlesMesh.rotation.x += params.rotationSpeed;
                    particlesMesh.rotation.y += params.rotationSpeed * 1.5;
                    
                    renderer.render(scene, camera);
                };
                
                animate();
                
                return {
                    destroy: () => {
                        renderer.dispose();
                        container.removeChild(renderer.domElement);
                    }
                };
            }

            // Three.jsÊ∞¥Êô∂ÊïàÊûú
            initThreeJSCrystalsEffect(effect, container) {
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                
                renderer.setSize(window.innerWidth, window.innerHeight);
                container.appendChild(renderer.domElement);
                
                const params = effect.randomParams;
                const crystals = [];
                
                for (let i = 0; i < params.count; i++) {
                    let geometry;
                    switch(params.shape) {
                        case 'sphere':
                            geometry = new THREE.SphereGeometry(0.5, 32, 32);
                            break;
                        case 'tetrahedron':
                            geometry = new THREE.TetrahedronGeometry(0.7, 0);
                            break;
                        case 'octahedron':
                            geometry = new THREE.OctahedronGeometry(0.6, 0);
                            break;
                        default:
                            geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    }
                    
                    const material = new THREE.MeshPhongMaterial({
                        color: params.color(),
                        transparent: true,
                        opacity: 0.8,
                        shininess: 100
                    });
                    
                    const crystal = new THREE.Mesh(geometry, material);
                    crystal.position.x = (Math.random() - 0.5) * 10;
                    crystal.position.y = (Math.random() - 0.5) * 10;
                    crystal.position.z = (Math.random() - 0.5) * 10;
                    
                    scene.add(crystal);
                    crystals.push(crystal);
                }
                
                const light = new THREE.PointLight(0xffffff, 1, 100);
                light.position.set(10, 10, 10);
                scene.add(light);
                
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);
                
                camera.position.z = 15;
                
                const animate = () => {
                    requestAnimationFrame(animate);
                    
                    crystals.forEach((crystal, index) => {
                        crystal.rotation.x += params.rotationSpeed * (index % 2 === 0 ? 1 : -1);
                        crystal.rotation.y += params.rotationSpeed * (index % 3 === 0 ? 1 : -1);
                    });
                    
                    renderer.render(scene, camera);
                };
                
                animate();
                
                return {
                    destroy: () => {
                        renderer.dispose();
                        container.removeChild(renderer.domElement);
                    }
                };
            }

            // Three.jsÊµÅ‰ΩìÊïàÊûú
            initThreeJSFluidEffect(effect, container) {
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                
                renderer.setSize(window.innerWidth, window.innerHeight);
                container.appendChild(renderer.domElement);
                
                const params = effect.randomParams;
                const waves = [];
                
                for (let i = 0; i < params.waveCount; i++) {
                    const geometry = new THREE.PlaneGeometry(20, 20, 50, 50);
                    const material = new THREE.MeshPhongMaterial({
                        color: params.color(),
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.DoubleSide,
                        wireframe: Math.random() > 0.5
                    });
                    
                    const wave = new THREE.Mesh(geometry, material);
                    wave.position.z = i * 0.5;
                    scene.add(wave);
                    waves.push(wave);
                }
                
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(5, 5, 5);
                scene.add(light);
                
                camera.position.set(0, 5, 10);
                camera.lookAt(0, 0, 0);
                
                let time = 0;
                const animate = () => {
                    requestAnimationFrame(animate);
                    time += 0.01;
                    
                    waves.forEach((wave, index) => {
                        const positions = wave.geometry.attributes.position.array;
                        for (let i = 0; i < positions.length; i += 3) {
                            const x = positions[i];
                            const y = positions[i + 1];
                            positions[i + 2] = Math.sin(x * params.frequency + time + index) * params.amplitude +
                                              Math.cos(y * params.frequency + time + index) * params.amplitude;
                        }
                        wave.geometry.attributes.position.needsUpdate = true;
                    });
                    
                    renderer.render(scene, camera);
                };
                
                animate();
                
                return {
                    destroy: () => {
                        renderer.dispose();
                        container.removeChild(renderer.domElement);
                    }
                };
            }

            // tsParticlesÂΩ©ËôπÊïàÊûú
            initTsParticlesRainbowEffect(effect, container, callback) {
                const params = effect.randomParams;
                const config = {
                    particles: {
                        number: { value: params.particleCount, density: { enable: true, value_area: 800 } },
                        color: { 
                            value: params.colors,
                            animation: {
                                enable: true,
                                speed: 20,
                                sync: false
                            }
                        },
                        shape: { type: "circle" },
                        opacity: { value: 0.8, random: true },
                        size: { value: params.size, random: true },
                        move: {
                            enable: true,
                            speed: params.speed,
                            direction: "top",
                            random: false,
                            straight: false,
                            out_mode: "out"
                        }
                    }
                };
                
                tsParticles.load(container.id, config).then(instance => {
                    callback(instance);
                });
            }

            // tsParticlesÈõ™Ëä±ÊïàÊûú
            initTsParticlesSnowflakesEffect(effect, container, callback) {
                const params = effect.randomParams;
                const config = {
                    particles: {
                        number: { value: params.particleCount, density: { enable: true, value_area: 800 } },
                        color: { value: "#ffffff" },
                        shape: { 
                            type: "char",
                            character: params.snowflakeTypes[Math.floor(Math.random() * params.snowflakeTypes.length)]
                        },
                        opacity: { value: 0.9, random: true },
                        size: { value: 10, random: true },
                        move: {
                            enable: true,
                            speed: params.speed,
                            direction: "bottom",
                            random: true,
                            straight: false,
                            out_mode: "out",
                            attract: {
                                enable: true,
                                rotateX: params.wind * 100,
                                rotateY: 0
                            }
                        }
                    }
                };
                
                tsParticles.load(container.id, config).then(instance => {
                    callback(instance);
                });
            }

            // tsParticlesÁÅ´ÁÑ∞ÊïàÊûú
            initTsParticlesFireEffect(effect, container, callback) {
                const params = effect.randomParams;
                const config = {
                    particles: {
                        number: { value: params.particleCount, density: { enable: true, value_area: 800 } },
                        color: { 
                            value: params.colors,
                            animation: {
                                enable: true,
                                speed: 30,
                                sync: false
                            }
                        },
                        shape: { type: "circle" },
                        opacity: { value: 0.8, random: true },
                        size: { value: 8, random: true },
                        move: {
                            enable: true,
                            speed: params.speed,
                            direction: "top",
                            random: true,
                            straight: false,
                            out_mode: "out",
                            angle: params.spread
                        }
                    }
                };
                
                tsParticles.load(container.id, config).then(instance => {
                    callback(instance);
                });
            }

            // P5.js DNAÊïàÊûú
            initP5JSDNAEffect(effect, container) {
                const params = effect.randomParams;
                const sketch = (p) => {
                    let angle = 0;
                    
                    p.setup = () => {
                        p.createCanvas(window.innerWidth, window.innerHeight);
                        p.colorMode(p.HSB, 360, 100, 100);
                    };
                    
                    p.draw = () => {
                        p.background(0, 0, 0, 0.05);
                        
                        p.push();
                        p.translate(p.width / 2, p.height / 2);
                        
                        for (let j = 0; j < params.helixCount; j++) {
                            const offset = (j / params.helixCount) * p.TWO_PI;
                            
                            for (let i = 0; i < 100; i++) {
                                const y = (i - 50) * 5;
                                const x1 = p.sin(angle + offset + i * 0.1) * 100;
                                const x2 = p.sin(angle + offset + i * 0.1 + p.PI) * 100;
                                
                                p.stroke(j === 0 ? p.color(params.color1()) : p.color(params.color2()));
                                p.strokeWeight(8);
                                p.point(x1, y);
                                p.point(x2, y);
                                
                                if (i % 10 === 0) {
                                    p.stroke(255);
                                    p.strokeWeight(2);
                                    p.line(x1, y, x2, y);
                                }
                            }
                        }
                        
                        p.pop();
                        angle += params.rotationSpeed;
                    };
                    
                    p.windowResized = () => {
                        p.resizeCanvas(window.innerWidth, window.innerHeight);
                    };
                };
                
                return new p5(sketch, container);
            }

            // P5.jsÂàÜÂΩ¢ÊïàÊûú
            initP5JSFractalEffect(effect, container) {
                const params = effect.randomParams;
                const sketch = (p) => {
                    p.setup = () => {
                        p.createCanvas(window.innerWidth, window.innerHeight);
                        p.colorMode(p.HSB, 360, 100, 100);
                    };
                    
                    p.draw = () => {
                        p.background(220, 30, 10);
                        
                        for (let x = 0; x < p.width; x += 10) {
                            for (let y = 0; y < p.height; y += 10) {
                                let noiseVal = p.noise(x * params.frequency, y * params.frequency, p.frameCount * 0.01);
                                let hue = p.map(noiseVal, 0, 1, 180, 240);
                                
                                p.stroke(hue, 70, 80);
                                p.strokeWeight(2);
                                p.line(x, y, x, y + noiseVal * params.amplitude);
                            }
                        }
                    };
                    
                    p.windowResized = () => {
                        p.resizeCanvas(window.innerWidth, window.innerHeight);
                    };
                };
                
                return new p5(sketch, container);
            }

            // P5.jsÁÉüËä±ÊïàÊûú
            initP5JSFireworksEffect(effect, container) {
                const params = effect.randomParams;
                const sketch = (p) => {
                    let fireworks = [];
                    let particles = [];
                    
                    class Firework {
                        constructor() {
                            this.x = p.random(p.width);
                            this.y = p.height;
                            this.vx = 0;
                            this.vy = -p.random(10, 15);
                            this.exploded = false;
                            this.color = p.color(p.random(360), 100, 100);
                        }
                        
                        update() {
                            if (!this.exploded) {
                                this.vy += params.gravity;
                                this.y += this.vy;
                                
                                if (this.vy >= 0) {
                                    this.explode();
                                }
                            }
                        }
                        
                        explode() {
                            this.exploded = true;
                            for (let i = 0; i < params.particleCount; i++) {
                                particles.push(new Particle(this.x, this.y, this.color));
                            }
                        }
                        
                        show() {
                            if (!this.exploded) {
                                p.stroke(this.color);
                                p.strokeWeight(4);
                                p.point(this.x, this.y);
                            }
                        }
                    }
                    
                    class Particle {
                        constructor(x, y, color) {
                            this.x = x;
                            this.y = y;
                            this.vx = p.random(-5, 5);
                            this.vy = p.random(-5, 5);
                            this.alpha = 255;
                            this.color = color;
                        }
                        
                        update() {
                            this.x += this.vx;
                            this.y += this.vy;
                            this.vy += params.gravity;
                            this.alpha -= 3;
                        }
                        
                        show() {
                            p.stroke(red(this.color), green(this.color), blue(this.color), this.alpha);
                            p.strokeWeight(3);
                            p.point(this.x, this.y);
                        }
                    }
                    
                    p.setup = () => {
                        p.createCanvas(window.innerWidth, window.innerHeight);
                        p.colorMode(p.RGB);
                        p.background(0);
                    };
                    
                    p.draw = () => {
                        p.background(0, 0, 0, 25);
                        
                        if (p.frameCount % 60 === 0 && fireworks.length < params.fireworkCount) {
                            fireworks.push(new Firework());
                        }
                        
                        for (let i = fireworks.length - 1; i >= 0; i--) {
                            fireworks[i].update();
                            fireworks[i].show();
                            
                            if (fireworks[i].exploded) {
                                fireworks.splice(i, 1);
                            }
                        }
                        
                        for (let i = particles.length - 1; i >= 0; i--) {
                            particles[i].update();
                            particles[i].show();
                            
                            if (particles[i].alpha <= 0) {
                                particles.splice(i, 1);
                            }
                        }
                    };
                    
                    p.windowResized = () => {
                        p.resizeCanvas(window.innerWidth, window.innerHeight);
                    };
                };
                
                return new p5(sketch, container);
            }

            // P5.jsÊ®±Ëä±ÊïàÊûú
            initP5JSSakuraEffect(effect, container) {
                const params = effect.randomParams;
                const sketch = (p) => {
                    let petals = [];
                    
                    class Petal {
                        constructor() {
                            this.x = p.random(p.width);
                            this.y = -10;
                            this.size = p.random(params.size);
                            this.speed = p.random(params.speed);
                            this.angle = p.random(p.TWO_PI);
                            this.spin = p.random(-0.1, 0.1);
                        }
                        
                        update() {
                            this.y += this.speed;
                            this.x += p.sin(this.angle) * params.windStrength;
                            this.angle += this.spin;
                            
                            if (this.y > p.height + 10) {
                                this.y = -10;
                                this.x = p.random(p.width);
                            }
                        }
                        
                        show() {
                            p.push();
                            p.translate(this.x, this.y);
                            p.rotate(this.angle);
                            p.noStroke();
                            p.fill(255, 182, 193, 200);
                            p.ellipse(0, 0, this.size, this.size * 0.8);
                            p.pop();
                        }
                    }
                    
                    p.setup = () => {
                        p.createCanvas(window.innerWidth, window.innerHeight);
                        
                        for (let i = 0; i < params.petalCount; i++) {
                            petals.push(new Petal());
                        }
                    };
                    
                    p.draw = () => {
                        p.background(255, 248, 220, 50);
                        
                        petals.forEach(petal => {
                            petal.update();
                            petal.show();
                        });
                    };
                    
                    p.windowResized = () => {
                        p.resizeCanvas(window.innerWidth, window.innerHeight);
                    };
                };
                
                return new p5(sketch, container);
            }

            // P5.jsÈ±ºÁæ§ÊïàÊûú
            initP5JSFishEffect(effect, container) {
                const params = effect.randomParams;
                const sketch = (p) => {
                    let fishes = [];
                    
                    class Fish {
                        constructor() {
                            this.position = p.createVector(p.random(p.width), p.random(p.height));
                            this.velocity = p.createVector(p.random(-2, 2), p.random(-2, 2));
                            this.acceleration = p.createVector(0, 0);
                            this.maxSpeed = params.speed;
                            this.maxForce = 0.05;
                            this.size = p.random(5, 15);
                            this.color = p.color(p.random(100, 255), p.random(100, 255), p.random(100, 255));
                        }
                        
                        edges() {
                            if (this.position.x > p.width) this.position.x = 0;
                            if (this.position.x < 0) this.position.x = p.width;
                            if (this.position.y > p.height) this.position.y = 0;
                            if (this.position.y < 0) this.position.y = p.height;
                        }
                        
                        align(fishes) {
                            let perceptionRadius = 50;
                            let steering = p.createVector(0, 0);
                            let total = 0;
                            
                            for (let other of fishes) {
                                let d = p.dist(this.position.x, this.position.y, other.position.x, other.position.y);
                                if (other != this && d < perceptionRadius) {
                                    steering.add(other.velocity);
                                    total++;
                                }
                            }
                            
                            if (total > 0) {
                                steering.div(total);
                                steering.setMag(this.maxSpeed);
                                steering.sub(this.velocity);
                                steering.limit(this.maxForce);
                            }
                            
                            return steering.mult(params.alignment);
                        }
                        
                        separation(fishes) {
                            let perceptionRadius = 25;
                            let steering = p.createVector(0, 0);
                            let total = 0;
                            
                            for (let other of fishes) {
                                let d = p.dist(this.position.x, this.position.y, other.position.x, other.position.y);
                                if (other != this && d < perceptionRadius) {
                                    let diff = p5.Vector.sub(this.position, other.position);
                                    diff.div(d * d);
                                    steering.add(diff);
                                    total++;
                                }
                            }
                            
                            if (total > 0) {
                                steering.div(total);
                                steering.setMag(this.maxSpeed);
                                steering.sub(this.velocity);
                                steering.limit(this.maxForce);
                            }
                            
                            return steering.mult(params.separation);
                        }
                        
                        cohesion(fishes) {
                            let perceptionRadius = 50;
                            let steering = p.createVector(0, 0);
                            let total = 0;
                            
                            for (let other of fishes) {
                                let d = p.dist(this.position.x, this.position.y, other.position.x, other.position.y);
                                if (other != this && d < perceptionRadius) {
                                    steering.add(other.position);
                                    total++;
                                }
                            }
                            
                            if (total > 0) {
                                steering.div(total);
                                steering.sub(this.position);
                                steering.setMag(this.maxSpeed);
                                steering.sub(this.velocity);
                                steering.limit(this.maxForce);
                            }
                            
                            return steering.mult(params.cohesion);
                        }
                        
                        flock(fishes) {
                            let alignment = this.align(fishes);
                            let cohesion = this.cohesion(fishes);
                            let separation = this.separation(fishes);
                            
                            this.acceleration.add(alignment);
                            this.acceleration.add(cohesion);
                            this.acceleration.add(separation);
                        }
                        
                        update() {
                            this.position.add(this.velocity);
                            this.velocity.add(this.acceleration);
                            this.velocity.limit(this.maxSpeed);
                            this.acceleration.mult(0);
                        }
                        
                        show() {
                            p.push();
                            p.translate(this.position.x, this.position.y);
                            p.rotate(this.velocity.heading());
                            p.noStroke();
                            p.fill(this.color);
                            p.triangle(0, 0, -this.size, -this.size/2, -this.size, this.size/2);
                            p.pop();
                        }
                    }
                    
                    p.setup = () => {
                        p.createCanvas(window.innerWidth, window.innerHeight);
                        
                        for (let i = 0; i < params.fishCount; i++) {
                            fishes.push(new Fish());
                        }
                    };
                    
                    p.draw = () => {
                        p.background(0, 50, 100, 25);
                        
                        for (let fish of fishes) {
                            fish.edges();
                            fish.flock(fishes);
                            fish.update();
                            fish.show();
                        }
                    };
                    
                    p.windowResized = () => {
                        p.resizeCanvas(window.innerWidth, window.innerHeight);
                    };
                };
                
                return new p5(sketch, container);
            }

            // Èó™ÁîµÊïàÊûú
            initLightningEffect(effect, container) {
                const params = effect.randomParams;
                const canvas = document.createElement('canvas');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                container.appendChild(canvas);
                
                const ctx = canvas.getContext('2d');
                
                const createLightning = (startX, startY, endX, endY, branches) => {
                    const points = [[startX, startY]];
                    const segments = 8;
                    
                    for (let i = 1; i < segments; i++) {
                        const progress = i / segments;
                        const x = startX + (endX - startX) * progress + (Math.random() - 0.5) * 100;
                        const y = startY + (endY - startY) * progress;
                        points.push([x, y]);
                    }
                    points.push([endX, endY]);
                    
                    ctx.strokeStyle = params.color();
                    ctx.lineWidth = params.thickness;
                    ctx.lineCap = 'round';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = params.color();
                    
                    ctx.beginPath();
                    ctx.moveTo(points[0][0], points[0][1]);
                    
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i][0], points[i][1]);
                    }
                    ctx.stroke();
                    
                    // ÂàõÂª∫ÂàÜÊîØ
                    if (branches > 0) {
                        for (let i = 1; i < points.length - 1; i++) {
                            if (Math.random() < 0.3) {
                                const branchEndX = points[i][0] + (Math.random() - 0.5) * 200;
                                const branchEndY = points[i][1] + Math.random() * 100;
                                createLightning(points[i][0], points[i][1], branchEndX, branchEndY, branches - 1);
                            }
                        }
                    }
                };
                
                const animate = () => {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    if (Math.random() < 0.02) {
                        for (let i = 0; i < params.boltCount; i++) {
                            const startX = Math.random() * canvas.width;
                            const startY = 0;
                            const endX = startX + (Math.random() - 0.5) * 400;
                            const endY = canvas.height;
                            createLightning(startX, startY, endX, endY, params.branches);
                        }
                    }
                };
                
                const animationId = setInterval(animate, 50);
                
                return {
                    destroy: () => {
                        clearInterval(animationId);
                        container.removeChild(canvas);
                    }
                };
            }

            // ÂΩ©ËôπÊïàÊûú
            initRainbowEffect(effect, container) {
                const params = effect.randomParams;
                const canvas = document.createElement('canvas');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                container.appendChild(canvas);
                
                const ctx = canvas.getContext('2d');
                let hue = 0;
                
                const drawRainbow = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height * (1 + params.arcHeight);
                    const radius = canvas.width * 0.8;
                    
                    for (let i = 0; i < 360; i += 2) {
                        const angle = (i * Math.PI) / 180;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;
                        
                        const nextAngle = ((i + 2) * Math.PI) / 180;
                        const nextX = centerX + Math.cos(nextAngle) * radius;
                        const nextY = centerY + Math.sin(nextAngle) * radius;
                        
                        ctx.strokeStyle = `hsla(${(hue + i) % 360}, 100%, 50%, ${params.opacity})`;
                        ctx.lineWidth = params.thickness;
                        ctx.lineCap = 'round';
                        
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(nextX, nextY);
                        ctx.stroke();
                    }
                    
                    hue += params.animationSpeed * 100;
                };
                
                const animationId = setInterval(drawRainbow, 50);
                
                return {
                    destroy: () => {
                        clearInterval(animationId);
                        container.removeChild(canvas);
                    }
                };
            }

            // Èù¢ÂÖ∑ËàûËπàÊïàÊûú
            initMaskDanceEffect(effect, container) {
                const params = effect.randomParams;
                const masks = [];
                
                for (let i = 0; i < params.count; i++) {
                    const mask = document.createElement('div');
                    mask.className = 'emoji-particle';
                    mask.textContent = params.masks[Math.floor(Math.random() * params.masks.length)];
                    mask.style.fontSize = (30 + Math.random() * 40) + 'px';
                    
                    const angle = (i / params.count) * Math.PI * 2;
                    const radius = params.radius;
                    
                    mask.style.left = (window.innerWidth / 2 + Math.cos(angle) * radius) + 'px';
                    mask.style.top = (window.innerHeight / 2 + Math.sin(angle) * radius) + 'px';
                    mask.style.animation = `mask-dance-${i} ${10 / params.speed}s linear infinite`;
                    
                    container.appendChild(mask);
                    masks.push(mask);
                    
                    // ÂàõÂª∫Áã¨ÁâπÁöÑÂä®Áîª
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes mask-dance-${i} {
                            from { 
                                transform: translate(-50%, -50%) rotate(0deg) scale(1);
                            }
                            25% { 
                                transform: translate(-50%, -50%) rotate(90deg) scale(1.2);
                            }
                            50% { 
                                transform: translate(-50%, -50%) rotate(180deg) scale(0.8);
                            }
                            75% { 
                                transform: translate(-50%, -50%) rotate(270deg) scale(1.1);
                            }
                            to { 
                                transform: translate(-50%, -50%) rotate(360deg) scale(1);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                return {
                    destroy: () => {
                        masks.forEach(mask => {
                            if (mask.parentNode) {
                                container.removeChild(mask);
                            }
                        });
                        // Ê∏ÖÁêÜÊ†∑Âºè
                        const styles = document.head.querySelectorAll('style');
                        styles.forEach(style => {
                            if (style.textContent.includes('mask-dance-')) {
                                document.head.removeChild(style);
                            }
                        });
                    }
                };
            }

            // È≠îÊ≥ïÈòµÊïàÊûú
            initMagicCircleEffect(effect, container) {
                const params = effect.randomParams;
                const canvas = document.createElement('canvas');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                container.appendChild(canvas);
                
                const ctx = canvas.getContext('2d');
                let rotation = 0;
                
                const drawMagicCircle = () => {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    for (let ring = 0; ring < params.ringCount; ring++) {
                        const radius = 100 + ring * 60;
                        const symbolCount = 8 + ring * 4;
                        
                        ctx.save();
                        ctx.translate(centerX, centerY);
                        ctx.rotate(rotation + ring * 0.1);
                        
                        // ÁªòÂà∂ÂúÜÁéØ
                        ctx.strokeStyle = params.glowColor();
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = params.glowColor();
                        ctx.beginPath();
                        ctx.arc(0, 0, radius, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // ÁªòÂà∂Á¨¶Âè∑
                        for (let i = 0; i < symbolCount; i++) {
                            const angle = (i / symbolCount) * Math.PI * 2;
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            
                            ctx.fillStyle = params.glowColor();
                            ctx.font = '20px serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(params.symbols[Math.floor(Math.random() * params.symbols.length)], x, y);
                        }
                        
                        ctx.restore();
                    }
                    
                    rotation += params.rotationSpeed;
                };
                
                const animationId = setInterval(drawMagicCircle, 50);
                
                return {
                    destroy: () => {
                        clearInterval(animationId);
                        container.removeChild(canvas);
                    }
                };
            }

            // VantaÊïàÊûúÔºà‰øùÊåÅÂéüÊúâÈÄªËæëÔºâ
            initVantaEffect(effect, container, callback) {
                const vantaEffects = {
                    waves: VANTA.WAVES,
                    cloud: VANTA.CLOUD,
                    fog: VANTA.FOG,
                    net: VANTA.NET,
                    dots: VANTA.DOTS,
                    rings: VANTA.RINGS,
                    cells: VANTA.CELLS,
                    halo: VANTA.HALO,
                    tron: VANTA.TRON
                };
                
                if (vantaEffects[effect.effect]) {
                    const params = effect.randomParams || {};
                    const instance = vantaEffects[effect.effect]({
                        el: container,
                        mouseControls: true,
                        touchControls: true,
                        gyroControls: false,
                        minHeight: 200.00,
                        minWidth: 200.00,
                        scale: params.scale || 1.00,
                        scaleMobile: 1.00,
                        color: params.color ? params.color() : Math.random() * 0xffffff,
                        backgroundColor: 0x0,
                        speed: params.speed || 1.0
                    });
                    callback(instance);
                } else {
                    callback(null);
                }
            }

            destroyEffect(effectInstance) {
                if (effectInstance) {
                    if (typeof effectInstance.destroy === 'function') {
                        effectInstance.destroy();
                    } else if (typeof effectInstance.remove === 'function') {
                        effectInstance.remove();
                    }
                }
            }

            async nextScene() {
                if (this.isTransitioning) return;
                
                this.isTransitioning = true;
                const loadingOverlay = document.getElementById('loadingOverlay');
                loadingOverlay.classList.add('show');
                
                await this.createScene();
                
                setTimeout(() => {
                    loadingOverlay.classList.remove('show');
                    this.isTransitioning = false;
                }, 400);
            }
        }

        // ÂàùÂßãÂåñÂ∫îÁî®
        document.addEventListener('DOMContentLoaded', () => {
            new AdvancedVisualEffectManager();
        });
    </script>
</body>
</html>
