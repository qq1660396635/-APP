<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>è¿·ä½ å¡”é˜²Â·ç»ˆæç‰ˆ</title>
    <style>
        /* ä¸€ã€åŸºç¡€æ ·å¼ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            overflow-x: hidden;
        }

        /* äºŒã€æ¸¸æˆå®¹å™¨ */
        .game-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: rgba(30, 30, 50, 0.9);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            max-height: 100vh;
            overflow: auto;
        }

        /* ä¸‰ã€ç”»å¸ƒæ ·å¼ */
        #gameCanvas {
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 100%);
            border: 3px solid #3498db;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            touch-action: none;
        }

        /* å››ã€æ§åˆ¶é¢æ¿ */
        .control-panel {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .control-panel h2 {
            text-align: center;
            margin-bottom: 15px;
            color: #3498db;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        /* äº”ã€å¡”é€‰æ‹©ç½‘æ ¼ */
        .tower-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .btn {
            padding: 10px;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(52, 152, 219, 0.3);
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.5);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(52, 152, 219, 0.3);
        }

        .btn:disabled {
            background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn.selected {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
            100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
        }

        /* å…­ã€ç»Ÿè®¡é¢æ¿ */
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #34495e;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: rgba(52, 73, 94, 0.6);
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .stat-item:hover {
            background: rgba(52, 73, 94, 0.9);
            transform: scale(1.05);
        }

        .stat-label {
            font-size: 12px;
            color: #bdc3c7;
        }

        .stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #ecf0f1;
        }

        .gold { color: #f1c40f; }
        .red { color: #e74c3c; }
        .blue { color: #3498db; }
        .green { color: #27ae60; }

        /* ä¸ƒã€æ¸¸æˆä¿¡æ¯é¢æ¿ */
        .game-info {
            background: rgba(52, 152, 219, 0.2);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            text-align: center;
            font-size: 14px;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* å…«ã€æ¨¡æ€æ¡† */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .modal h2 {
            color: #3498db;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .modal p {
            margin-bottom: 15px;
            line-height: 1.6;
            color: #ecf0f1;
        }

        .modal-btn {
            padding: 12px 30px;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
        }

        .modal-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.5);
        }

        /* ä¹ã€ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 768px) {
            .game-container {
                width: 100%;
                max-width: 100%;
                padding: 10px;
            }
            
            #gameCanvas {
                width: 100%;
                height: auto;
            }
            
            .tower-grid {
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }
            
            .btn {
                font-size: 12px;
                padding: 8px;
            }
            
            .stats {
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }
        }

        /* åã€åŠ¨ç”»æ•ˆæœ */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }

        /* åä¸€ã€éš¾åº¦æç¤º */
        .difficulty-warning {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            z-index: 2000;
            animation: difficultyPulse 2s ease-out;
            pointer-events: none;
        }

        @keyframes difficultyPulse {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-info" id="gameInfo">ç‚¹å‡»"å¼€å§‹æ¸¸æˆ"å¼€å§‹å†’é™©ï¼</div>
        <canvas id="gameCanvas"></canvas>
        <div class="control-panel">
            <h2>å¡”é˜²æŒ‡æŒ¥ä¸­å¿ƒ</h2>
            <div class="tower-grid">
                <button class="btn" id="pistolBtn">ğŸ”« æ‰‹æªå¡”<br>ğŸ’° 200</button>
                <button class="btn" id="sniperBtn">ğŸ¯ ç‹™å‡»å¡”<br>ğŸ’° 500</button>
                <button class="btn" id="cannonBtn">ğŸ’£ ç«ç‚®å¡”<br>ğŸ’° 800</button>
                <button class="btn" id="laserBtn">âš¡ æ¿€å…‰å¡”<br>ğŸ’° 1200</button>
                <button class="btn" id="freezeBtn">â„ï¸ å†°å†»å¡”<br>ğŸ’° 1000</button>
                <button class="btn" id="startBtn">ğŸ® å¼€å§‹æ¸¸æˆ</button>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">ğŸ’° é‡‘å¸</span>
                    <span class="stat-value gold" id="money">1000</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">â¤ï¸ ç”Ÿå‘½</span>
                    <span class="stat-value red" id="lives">20</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ğŸŒŠ æ³¢æ•°</span>
                    <span class="stat-value blue" id="wave">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">âš”ï¸ å‡»æ€</span>
                    <span class="stat-value green" id="kills">0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- æ¸¸æˆç»“æŸæ¨¡æ€æ¡† -->
    <div class="modal" id="gameModal">
        <div class="modal-content fade-in">
            <h2 id="modalTitle">æ¸¸æˆç»“æŸ</h2>
            <p id="modalMessage">æ¶ˆæ¯å†…å®¹</p>
            <p id="modalStats">ç»Ÿè®¡ä¿¡æ¯</p>
            <p id="modalFact" style="font-style: italic; color: #3498db;"></p>
            <button class="modal-btn" id="modalBtn">ç¡®å®š</button>
        </div>
    </div>

    <script>
        // ä¸€ã€æ¸¸æˆé…ç½®
        const gameConfig = {
            // 1. ç”»å¸ƒè®¾ç½® - é•¿æ–¹å½¢è®¾è®¡
            canvasWidth: 600,
            canvasHeight: 400,
            
            // 2. åˆå§‹çŠ¶æ€
            initialMoney: 1000,
            initialLives: 20,
            
            // 3. åœ°å›¾èƒŒæ™¯é…ç½®
            mapThemes: [
                {
                    name: "æ£®æ—ç§˜å¢ƒ",
                    background: "linear-gradient(135deg, #134e5e 0%, #71b280 100%)",
                    pathColor: "#8B4513",
                    particleColor: "#90EE90"
                },
                {
                    name: "ç«å±±ç†”å²©",
                    background: "linear-gradient(135deg, #ff6b6b 0%, #feca57 100%)",
                    pathColor: "#8B0000",
                    particleColor: "#FF4500"
                },
                {
                    name: "å†°é›ªç‹å›½",
                    background: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
                    pathColor: "#4682B4",
                    particleColor: "#87CEEB"
                },
                {
                    name: "æ²™æ¼ ç»¿æ´²",
                    background: "linear-gradient(135deg, #f2994a 0%, #f2c94c 100%)",
                    pathColor: "#D2691E",
                    particleColor: "#FFD700"
                },
                {
                    name: "æ·±æµ·é—è¿¹",
                    background: "linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)",
                    pathColor: "#191970",
                    particleColor: "#00CED1"
                }
            ],
            
            // 4. å¡”ç±»å‹é…ç½® - é¢œè‰²åŠ æ·±
            towerTypes: {
                pistol: {
                    cost: 200, damage: 1, range: 70, fireRate: 500,
                    color: '#1e5a8e', name: 'æ‰‹æªå¡”', icon: 'ğŸ”«' // æ·±è“è‰²
                },
                sniper: {
                    cost: 500, damage: 5, range: 150, fireRate: 1500,
                    color: '#6b3aa0', name: 'ç‹™å‡»å¡”', icon: 'ğŸ¯' // æ·±ç´«è‰²
                },
                cannon: {
                    cost: 800, damage: 3, range: 80, fireRate: 800,
                    color: '#cc5500', name: 'ç«ç‚®å¡”', icon: 'ğŸ’£', splash: true, splashRange: 35 // æ·±æ©™è‰²
                },
                laser: {
                    cost: 1200, damage: 0.5, range: 130, fireRate: 50,
                    color: '#006600', name: 'æ¿€å…‰å¡”', icon: 'âš¡', continuous: true // æ·±ç»¿è‰²
                },
                freeze: {
                    cost: 1000, damage: 0.1, range: 100, fireRate: 1000,
                    color: '#4682b4', name: 'å†°å†»å¡”', icon: 'â„ï¸', freeze: true, freezeDuration: 2000 // æ·±å¤©è“è‰²
                }
            },
            
            // 5. æ•Œäººç±»å‹é…ç½®
            enemyTypes: [
                { hp: 3, speed: 0.7, color: '#e74c3c', reward: 50, name: 'æ™®é€šæ•Œäºº', icon: 'ğŸ‘¾' },
                { hp: 5, speed: 0.6, color: '#c0392b', reward: 80, name: 'é‡è£…æ•Œäºº', icon: 'ğŸ¤–' },
                { hp: 8, speed: 0.4, color: '#8b4513', reward: 120, name: 'ç²¾è‹±æ•Œäºº', icon: 'ğŸ‘¹' },
                { hp: 15, speed: 0.3, color: '#2c3e50', reward: 200, name: 'BOSSæ•Œäºº', icon: 'ğŸ‘º' },
                { hp: 2, speed: 1.4, color: '#f39c12', reward: 60, name: 'å¿«é€Ÿæ•Œäºº', icon: 'ğŸƒ' }
            ],
            
            // 6. æ¸¸æˆå‚æ•°
            waveMultiplier: 0.15,
            difficultyMultiplier: 0.1, // æ¯10å…³é¢å¤–å¢åŠ çš„éš¾åº¦ç³»æ•°
            enemyBaseCount: 5,
            enemyPerWave: 2,
            baseSpawnInterval: 1500,
            spawnIntervalDecrease: 30,
            minSpawnInterval: 300,
            waveCheckInterval: 800,
            waveDelay: 1500,
            pathWidth: 30,
            towerSize: 30,
            enemyRadius: 12,
            bulletRadius: 4,
            bulletSpeed: 5,
            hitDistance: 10,
            pathTolerance: 20,
            freezeEffect: 0.3,
            splashDamageRatio: 0.5
        };

        // äºŒã€å†·çŸ¥è¯†åº“
        const coldKnowledge = [
            "ğŸŒ åœ°çƒä¸Šæœ€æ·±çš„æµ·æ²Ÿæ˜¯é©¬é‡Œäºšçº³æµ·æ²Ÿï¼Œæ·±åº¦çº¦11å…¬é‡Œã€‚",
            "ğŸ™ ç« é±¼æœ‰ä¸‰é¢—å¿ƒè„å’Œè“è‰²çš„è¡€æ¶²ã€‚",
            "ğŸ¯ èœ‚èœœæ°¸è¿œä¸ä¼šå˜è´¨ï¼Œè€ƒå¤å­¦å®¶å‘ç°äº†3000å¹´å‰çš„èœ‚èœœä»ç„¶å¯ä»¥é£Ÿç”¨ã€‚",
            "ğŸŒ™ æœˆçƒæ¯å¹´è¿œç¦»åœ°çƒçº¦3.8å˜ç±³ã€‚",
            "ğŸ§ ä¼é¹…å¯ä»¥è·³åˆ°1.5ç±³çš„é«˜åº¦ã€‚",
            "ğŸŒˆ å½©è™¹å®é™…ä¸Šæ˜¯åœ†å½¢çš„ï¼Œæˆ‘ä»¬åœ¨åœ°é¢ä¸Šåªèƒ½çœ‹åˆ°åŠåœ†ã€‚",
            "ğŸ¦’ é•¿é¢ˆé¹¿çš„èˆŒå¤´é•¿è¾¾45å˜ç±³ï¼Œå¯ä»¥æ¸…æ´è‡ªå·±çš„è€³æœµã€‚",
            "ğŸŒŠ æµ·æ´‹è¦†ç›–äº†åœ°çƒè¡¨é¢çš„71%ï¼Œä½†æˆ‘ä»¬åªæ¢ç´¢äº†5%ã€‚",
            "ğŸ¦‹ è´è¶ç”¨è„šæ¥å“å°é£Ÿç‰©çš„å‘³é“ã€‚",
            "ğŸ¨ è€ƒæ‹‰æ¯å¤©ç¡çœ æ—¶é—´é•¿è¾¾22å°æ—¶ã€‚",
            "ğŸŒŸ å¤ªé˜³çš„æ ¸å¿ƒæ¸©åº¦é«˜è¾¾1500ä¸‡æ‘„æ°åº¦ã€‚",
            "ğŸ  é‡‘é±¼çš„è®°å¿†åŠ›å…¶å®å¯ä»¥æŒç»­3ä¸ªæœˆä»¥ä¸Šã€‚",
            "ğŸŒ é¦™è•‰æ˜¯æµ†æœï¼Œè€Œè‰è“ä¸æ˜¯ã€‚",
            "ğŸ¦… é¹°å¯ä»¥åœ¨10å…¬é‡Œå¤–çœ‹åˆ°çŒç‰©ã€‚",
            "ğŸŒ¸ æ¨±èŠ±åŸäº§äºå–œé©¬æ‹‰é›…å±±åŒºï¼Œè€Œä¸æ˜¯æ—¥æœ¬ã€‚",
            "ğŸ¢ æœ‰äº›ä¹Œé¾Ÿå¯ä»¥æ´»åˆ°150å²ä»¥ä¸Šã€‚",
            "ğŸŒŒ é“¶æ²³ç³»åŒ…å«2000-4000äº¿é¢—æ’æ˜Ÿã€‚",
            "ğŸ¦˜ è¢‹é¼ æ— æ³•å‘åç§»åŠ¨ã€‚",
            "ğŸ« å·§å…‹åŠ›å¯¹ç‹—æ˜¯æœ‰æ¯’çš„ã€‚",
            "ğŸŒº ä¸–ç•Œä¸Šæœ€å¤§çš„èŠ±æ˜¯å·¨èŠ±é­”èŠ‹ï¼Œç›´å¾„å¯è¾¾1ç±³ã€‚"
        ];

        // ä¸‰ã€æ¸¸æˆåˆå§‹åŒ–
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // 1. è®¾ç½®ç”»å¸ƒå°ºå¯¸
        canvas.width = gameConfig.canvasWidth;
        canvas.height = gameConfig.canvasHeight;
        
        // 2. æ¸¸æˆçŠ¶æ€
        let gameState = {
            money: gameConfig.initialMoney,
            lives: gameConfig.initialLives,
            wave: 0,
            kills: 0,
            isPlaying: false,
            selectedTower: null,
            towers: [],
            enemies: [],
            bullets: [],
            currentMap: 0,
            path: [],
            lastLevelComplete: 0 // è®°å½•ä¸Šæ¬¡é€šå…³çš„æ³¢æ•°ï¼Œé˜²æ­¢é‡å¤æç¤º
        };

        // å››ã€è´ªåƒè›‡å¼è·¯å¾„ç”Ÿæˆå™¨
        function generateRandomPath() {
            const path = [];
            const points = 10 + Math.floor(Math.random() * 4); // 10-13ä¸ªç‚¹ï¼Œæ›´é•¿çš„è·¯å¾„
            const margin = 40;
            const segmentLength = gameConfig.canvasWidth / (points - 1);
            
            // èµ·å§‹ç‚¹åœ¨å·¦ä¾§
            path.push({ x: 0, y: margin + Math.random() * (gameConfig.canvasHeight - 2 * margin) });
            
            // ç”Ÿæˆä¸­é—´ç‚¹ - è´ªåƒè›‡å¼ä¸Šä¸‹æ‹å¼¯
            let lastDirection = 'right'; // è®°å½•ä¸Šæ¬¡ç§»åŠ¨æ–¹å‘
            let verticalCount = 0; // è¿ç»­å‚ç›´ç§»åŠ¨è®¡æ•°
            
            for (let i = 1; i < points - 1; i++) {
                const x = (gameConfig.canvasWidth / (points - 1)) * i;
                let y;
                
                // è´ªåƒè›‡å¼ç§»åŠ¨é€»è¾‘
                if (verticalCount >= 2) {
                    // è¿ç»­ä¸¤æ¬¡å‚ç›´ç§»åŠ¨åï¼Œå¼ºåˆ¶æ°´å¹³ç§»åŠ¨
                    y = path[i-1].y;
                    verticalCount = 0;
                    lastDirection = 'right';
                } else if (Math.random() < 0.6 && lastDirection === 'right') {
                    // 60%æ¦‚ç‡å‚ç›´ç§»åŠ¨
                    const maxY = gameConfig.canvasHeight - margin;
                    const minY = margin;
                    
                    if (path[i-1].y > gameConfig.canvasHeight / 2) {
                        // åœ¨ä¸‹åŠéƒ¨åˆ†ï¼Œå‘ä¸Šç§»åŠ¨
                        y = Math.max(minY, path[i-1].y - (80 + Math.random() * 60));
                    } else {
                        // åœ¨ä¸ŠåŠéƒ¨åˆ†ï¼Œå‘ä¸‹ç§»åŠ¨
                        y = Math.min(maxY, path[i-1].y + (80 + Math.random() * 60));
                    }
                    
                    verticalCount++;
                    lastDirection = 'vertical';
                } else {
                    // æ°´å¹³ç§»åŠ¨ï¼Œä¿æŒYåæ ‡æˆ–å¾®è°ƒ
                    y = path[i-1].y + (Math.random() - 0.5) * 40;
                    y = Math.max(margin, Math.min(gameConfig.canvasHeight - margin, y));
                    lastDirection = 'right';
                }
                
                path.push({ x, y });
            }
            
            // ç»ˆç‚¹åœ¨å³ä¾§
            path.push({ 
                x: gameConfig.canvasWidth, 
                y: margin + Math.random() * (gameConfig.canvasHeight - 2 * margin) 
            });
            
            return path;
        }

        // äº”ã€æ¸¸æˆå¯¹è±¡ç±»
        // 1. æ•Œäººç±»
        class Enemy {
            constructor(type, wave) {
                this.type = type;
                // è®¡ç®—éš¾åº¦ç³»æ•°
                const baseMultiplier = 1 + wave * gameConfig.waveMultiplier;
                const difficultyBonus = Math.floor(wave / 10) * gameConfig.difficultyMultiplier;
                const totalMultiplier = baseMultiplier + difficultyBonus;
                
                this.hp = type.hp * totalMultiplier;
                this.maxHp = this.hp;
                this.speed = type.speed * (1 + difficultyBonus * 0.5); // é€Ÿåº¦ä¹Ÿå—éš¾åº¦å½±å“
                this.color = type.color;
                this.reward = Math.floor(type.reward * (1 + difficultyBonus * 0.3)); // å¥–åŠ±ç•¥å¾®å¢åŠ 
                this.pathIndex = 0;
                this.x = gameState.path[0].x;
                this.y = gameState.path[0].y;
                this.alive = true;
                this.frozen = false;
                this.freezeTimer = 0;
                this.icon = type.icon;
            }

            update() {
                if (!this.alive) return;
                
                // 1. å†°å†»çŠ¶æ€å¤„ç†
                if (this.freezeTimer > 0) {
                    this.freezeTimer--;
                    this.frozen = this.freezeTimer > 0;
                }
                
                // 2. è·¯å¾„ç»ˆç‚¹æ£€æµ‹
                if (this.pathIndex >= gameState.path.length - 1) {
                    this.alive = false;
                    gameState.lives--;
                    updateUI();
                    return;
                }
                
                // 3. ç§»åŠ¨é€»è¾‘
                const target = gameState.path[this.pathIndex + 1];
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 5) {
                    this.pathIndex++;
                } else {
                    const currentSpeed = this.frozen ? 
                        this.speed * gameConfig.freezeEffect : 
                        this.speed;
                    this.x += (dx / distance) * currentSpeed;
                    this.y += (dy / distance) * currentSpeed;
                }
            }

            draw() {
                if (!this.alive) return;
                
                // 1. ç»˜åˆ¶æ•Œäººå›¾æ ‡
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (this.frozen) {
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = '#87ceeb';
                } else {
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = this.color;
                }
                
                ctx.fillText(this.icon, this.x, this.y);
                
                // 2. å†°å†»æ•ˆæœ
                if (this.frozen) {
                    ctx.strokeStyle = '#87ceeb';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, gameConfig.enemyRadius + 3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                // 3. è¡€æ¡
                const barWidth = 25;
                const barHeight = 4;
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x - barWidth/2, this.y - 20, barWidth, barHeight);
                
                ctx.fillStyle = this.hp > this.maxHp/2 ? '#27ae60' : '#e74c3c';
                ctx.fillRect(this.x - barWidth/2, this.y - 20, barWidth * (this.hp/this.maxHp), barHeight);
            }

            takeDamage(damage) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    this.alive = false;
                    gameState.money += this.reward;
                    gameState.kills++;
                    updateUI();
                }
            }
        }

        // 2. å¡”ç±»
        class Tower {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.lastFire = 0;
                this.target = null;
                this.laserTimer = 0;
            }

            update() {
                // 1. å¯»æ‰¾ç›®æ ‡
                if (!this.target || !this.target.alive) {
                    this.findTarget();
                }
                
                // 2. ç›®æ ‡æ£€æµ‹
                if (this.target && this.getDistance(this.target) > this.type.range) {
                    this.target = null;
                }
                
                // 3. æ”»å‡»é€»è¾‘
                if (this.target) {
                    if (this.type.continuous) {
                        this.laserTimer++;
                        if (this.laserTimer % 3 === 0) {
                            this.target.takeDamage(this.type.damage);
                        }
                    } else if (Date.now() - this.lastFire > this.type.fireRate) {
                        gameState.bullets.push(new Bullet(this.x, this.y, this.target, this.type));
                        this.lastFire = Date.now();
                    }
                }
            }

            draw() {
                // 1. ç»˜åˆ¶å¡”å›¾æ ‡
                ctx.font = '25px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.type.icon, this.x, this.y);
                
                // 2. æ¿€å…‰æ•ˆæœ
                if (this.type.continuous && this.target && this.target.alive) {
                    ctx.strokeStyle = this.type.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.target.x, this.target.y);
                    ctx.stroke();
                }
                
                // 3. å°„ç¨‹èŒƒå›´
                ctx.strokeStyle = this.type.color + '30';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.type.range, 0, Math.PI * 2);
                ctx.stroke();
            }

            findTarget() {
                let closestEnemy = null;
                let closestDistance = Infinity;
                
                for (const enemy of gameState.enemies) {
                    if (!enemy.alive) continue;
                    const distance = this.getDistance(enemy);
                    if (distance < this.type.range && distance < closestDistance) {
                        closestDistance = distance;
                        closestEnemy = enemy;
                    }
                }
                
                this.target = closestEnemy;
            }

            getDistance(enemy) {
                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        // 3. å­å¼¹ç±»
        class Bullet {
            constructor(x, y, target, towerType) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.damage = towerType.damage;
                this.speed = gameConfig.bulletSpeed;
                this.alive = true;
                this.type = towerType;
            }

            update() {
                if (!this.alive || !this.target.alive) {
                    this.alive = false;
                    return;
                }
                
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < gameConfig.hitDistance) {
                    this.target.takeDamage(this.damage);
                    
                    // 1. å†°å†»æ•ˆæœ
                    if (this.type.freeze) {
                        this.target.frozen = true;
                        this.target.freezeTimer = this.type.freezeDuration;
                    }
                    
                    // 2. æº…å°„ä¼¤å®³
                    if (this.type.splash) {
                        for (const enemy of gameState.enemies) {
                            if (enemy !== this.target && enemy.alive) {
                                const splashDistance = Math.sqrt(
                                    Math.pow(enemy.x - this.target.x, 2) + 
                                    Math.pow(enemy.y - this.target.y, 2)
                                );
                                if (splashDistance < this.type.splashRange) {
                                    enemy.takeDamage(this.damage * gameConfig.splashDamageRatio);
                                }
                            }
                        }
                    }
                    
                    this.alive = false;
                } else {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }
            }

            draw() {
                if (!this.alive) return;
                ctx.fillStyle = this.type.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, gameConfig.bulletRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // å…­ã€æ¸¸æˆæ ¸å¿ƒåŠŸèƒ½
        // 1. æ¸¸æˆä¸»å¾ªç¯
        function gameLoop() {
            if (!gameState.isPlaying) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            drawPath();
            
            // 1. æ›´æ–°å¡”
            gameState.towers.forEach(tower => {
                tower.update();
                tower.draw();
            });
            
            // 2. æ›´æ–°æ•Œäºº
            gameState.enemies = gameState.enemies.filter(enemy => {
                enemy.update();
                enemy.draw();
                return enemy.alive;
            });
            
            // 3. æ›´æ–°å­å¼¹
            gameState.bullets = gameState.bullets.filter(bullet => {
                bullet.update();
                bullet.draw();
                return bullet.alive;
            });
            
            // 4. æ¸¸æˆç»“æŸæ£€æµ‹
            if (gameState.lives <= 0) {
                gameOver();
                return;
            }
            
            requestAnimationFrame(gameLoop);
        }

        // 2. ç»˜åˆ¶èƒŒæ™¯
        function drawBackground() {
            const theme = gameConfig.mapThemes[gameState.currentMap];
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            
            // æ ¹æ®ä¸»é¢˜è®¾ç½®æ¸å˜è‰²
            const colors = theme.background.match(/#[a-fA-F0-9]{6}/g);
            gradient.addColorStop(0, colors[0]);
            gradient.addColorStop(1, colors[1]);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // æ·»åŠ è£…é¥°æ€§ç²’å­
            ctx.fillStyle = theme.particleColor + '30';
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 3 + 1;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // 3. ç»˜åˆ¶è·¯å¾„
        function drawPath() {
            const theme = gameConfig.mapThemes[gameState.currentMap];
            ctx.strokeStyle = theme.pathColor;
            ctx.lineWidth = gameConfig.pathWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(gameState.path[0].x, gameState.path[0].y);
            
            for (let i = 1; i < gameState.path.length; i++) {
                ctx.lineTo(gameState.path[i].x, gameState.path[i].y);
            }
            ctx.stroke();
        }

        // 4. æ³¢æ¬¡ç”Ÿæˆ
        let enemySpawned = 0;

        function spawnWave() {
            gameState.wave++;
            
            // æ£€æŸ¥æ˜¯å¦ä¸º10çš„å€æ•°ï¼Œæ˜¾ç¤ºéš¾åº¦è­¦å‘Š
            if (gameState.wave % 10 === 0) {
                showDifficultyWarning();
            }
            
            const enemyCount = gameConfig.enemyBaseCount + gameState.wave * gameConfig.enemyPerWave;
            enemySpawned = 0;
            
            updateGameInfo(`ğŸŒŠ ç¬¬ ${gameState.wave} æ³¢æ•Œäººæ¥è¢­ï¼`);
            
            const spawnInterval = setInterval(() => {
                if (enemySpawned < enemyCount) {
                    const enemyTypeIndex = Math.min(
                        Math.floor(gameState.wave / 3) + 
                        Math.floor(Math.random() * 3),
                        gameConfig.enemyTypes.length - 1
                    );
                    gameState.enemies.push(new Enemy(gameConfig.enemyTypes[enemyTypeIndex], gameState.wave));
                    enemySpawned++;
                } else {
                    clearInterval(spawnInterval);
                }
            }, Math.max(gameConfig.minSpawnInterval, gameConfig.baseSpawnInterval - gameState.wave * gameConfig.spawnIntervalDecrease));
        }

        // 5. æ˜¾ç¤ºéš¾åº¦è­¦å‘Š
        function showDifficultyWarning() {
            const warning = document.createElement('div');
            warning.className = 'difficulty-warning';
            warning.textContent = `âš ï¸ éš¾åº¦æå‡ï¼ç¬¬ ${gameState.wave} æ³¢`;
            document.body.appendChild(warning);
            
            setTimeout(() => {
                document.body.removeChild(warning);
            }, 2000);
        }

        // 6. UIæ›´æ–°
        function updateUI() {
            document.getElementById('money').textContent = gameState.money;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('kills').textContent = gameState.kills;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.getElementById('pistolBtn').disabled = gameState.money < gameConfig.towerTypes.pistol.cost;
            document.getElementById('sniperBtn').disabled = gameState.money < gameConfig.towerTypes.sniper.cost;
            document.getElementById('cannonBtn').disabled = gameState.money < gameConfig.towerTypes.cannon.cost;
            document.getElementById('laserBtn').disabled = gameState.money < gameConfig.towerTypes.laser.cost;
            document.getElementById('freezeBtn').disabled = gameState.money < gameConfig.towerTypes.freeze.cost;
        }

        // 7. æ¸¸æˆä¿¡æ¯æ›´æ–°
        function updateGameInfo(message) {
            document.getElementById('gameInfo').textContent = message;
            document.getElementById('gameInfo').classList.add('fade-in');
            setTimeout(() => {
                document.getElementById('gameInfo').classList.remove('fade-in');
            }, 500);
        }

        // 8. æ¸¸æˆç»“æŸ
        function gameOver() {
            gameState.isPlaying = false;
            const fact = coldKnowledge[Math.floor(Math.random() * coldKnowledge.length)];
            
            showModal(
                "ğŸ’€ æ¸¸æˆç»“æŸ",
                `å¾ˆé—æ†¾ï¼Œä½ çš„é˜²çº¿è¢«çªç ´äº†ï¼`,
                `æ³¢æ•°ï¼š${gameState.wave} | å‡»æ€ï¼š${gameState.kills}`,
                `ğŸ’¡ å†·çŸ¥è¯†ï¼š${fact}`
            );
        }

        // 9. é€šå…³å¥–åŠ±
        function levelComplete() {
            // é˜²æ­¢é‡å¤æç¤º
            if (gameState.wave === gameState.lastLevelComplete) {
                return;
            }
            
            gameState.lastLevelComplete = gameState.wave;
            const fact = coldKnowledge[Math.floor(Math.random() * coldKnowledge.length)];
            const bonus = 100 + gameState.wave * 50;
            gameState.money += bonus;
            
            showModal(
                "ğŸ‰ å…³å¡å®Œæˆ",
                `æ­å–œé€šè¿‡ç¬¬ ${gameState.wave} æ³¢ï¼`,
                `å¥–åŠ±é‡‘å¸ï¼š${bonus} | æ€»å‡»æ€ï¼š${gameState.kills}`,
                `ğŸ’¡ å†·çŸ¥è¯†ï¼š${fact}`,
                () => {
                    // åˆ‡æ¢åœ°å›¾ä¸»é¢˜
                    gameState.currentMap = (gameState.currentMap + 1) % gameConfig.mapThemes.length;
                    gameState.path = generateRandomPath();
                    updateGameInfo(`ğŸ—ºï¸ è¿›å…¥æ–°åœ°å›¾ï¼š${gameConfig.mapThemes[gameState.currentMap].name}`);
                }
            );
        }

        // 10. æ¨¡æ€æ¡†æ§åˆ¶
        function showModal(title, message, stats, fact, callback) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;
            document.getElementById('modalStats').textContent = stats;
            document.getElementById('modalFact').textContent = fact || '';
            document.getElementById('gameModal').style.display = 'flex';
            
            document.getElementById('modalBtn').onclick = () => {
                document.getElementById('gameModal').style.display = 'none';
                if (callback) callback();
                if (gameState.lives > 0) {
                    setTimeout(spawnWave, 1000);
                }
            };
        }

        // ä¸ƒã€äº‹ä»¶å¤„ç†
        // 1. ç”»å¸ƒç‚¹å‡»äº‹ä»¶ï¼ˆæ”¯æŒç§»åŠ¨ç«¯ï¼‰
        function getEventPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            if (e.touches) {
                return {
                    x: (e.touches[0].clientX - rect.left) * scaleX,
                    y: (e.touches[0].clientY - rect.top) * scaleY
                };
            }
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('click', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });

        function handleCanvasClick(e) {
            if (!gameState.isPlaying || !gameState.selectedTower) return;
            
            const pos = getEventPosition(e);
            const x = pos.x;
            const y = pos.y;
            
            // æ£€æŸ¥æ˜¯å¦åœ¨è·¯å¾„ä¸Š
            let onPath = false;
            for (let i = 0; i < gameState.path.length - 1; i++) {
                const p1 = gameState.path[i];
                const p2 = gameState.path[i + 1];
                
                if ((x >= Math.min(p1.x, p2.x) - gameConfig.pathTolerance && 
                     x <= Math.max(p1.x, p2.x) + gameConfig.pathTolerance) &&
                    (y >= Math.min(p1.y, p2.y) - gameConfig.pathTolerance && 
                     y <= Math.max(p1.y, p2.y) + gameConfig.pathTolerance)) {
                    onPath = true;
                    break;
                }
            }
            
            // æ”¾ç½®å¡”
            if (!onPath) {
                const towerType = gameConfig.towerTypes[gameState.selectedTower];
                if (gameState.money >= towerType.cost) {
                    gameState.towers.push(new Tower(x, y, towerType));
                    gameState.money -= towerType.cost;
                    gameState.selectedTower = null;
                    updateUI();
                    updateGameInfo(`ğŸ—ï¸ æˆåŠŸå»ºé€  ${towerType.name}ï¼`);
                    
                    // æ¸…é™¤æ‰€æœ‰æŒ‰é’®é€‰ä¸­çŠ¶æ€
                    document.querySelectorAll('.btn').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                }
            }
        }

        // 2. æŒ‰é’®äº‹ä»¶
        function setupTowerButton(towerId, towerKey) {
            document.getElementById(towerId).addEventListener('click', () => {
                if (gameState.money >= gameConfig.towerTypes[towerKey].cost) {
                    // æ¸…é™¤å…¶ä»–æŒ‰é’®é€‰ä¸­çŠ¶æ€
                    document.querySelectorAll('.btn').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    
                    // è®¾ç½®å½“å‰æŒ‰é’®ä¸ºé€‰ä¸­çŠ¶æ€
                    document.getElementById(towerId).classList.add('selected');
                    gameState.selectedTower = towerKey;
                    updateGameInfo(`ğŸ¯ é€‰æ‹©å»ºé€  ${gameConfig.towerTypes[towerKey].name}`);
                }
            });
        }

        setupTowerButton('pistolBtn', 'pistol');
        setupTowerButton('sniperBtn', 'sniper');
        setupTowerButton('cannonBtn', 'cannon');
        setupTowerButton('laserBtn', 'laser');
        setupTowerButton('freezeBtn', 'freeze');

        document.getElementById('startBtn').addEventListener('click', () => {
            if (!gameState.isPlaying) {
                gameState.isPlaying = true;
                gameState.money = gameConfig.initialMoney;
                gameState.lives = gameConfig.initialLives;
                gameState.wave = 0;
                gameState.kills = 0;
                gameState.towers = [];
                gameState.enemies = [];
                gameState.bullets = [];
                gameState.currentMap = Math.floor(Math.random() * gameConfig.mapThemes.length);
                gameState.path = generateRandomPath();
                gameState.lastLevelComplete = 0; // é‡ç½®é€šå…³è®°å½•
                
                updateUI();
                updateGameInfo(`ğŸ® æ¸¸æˆå¼€å§‹ï¼å½“å‰åœ°å›¾ï¼š${gameConfig.mapThemes[gameState.currentMap].name}`);
                spawnWave();
                gameLoop();
            }
        });

        // 3. æ³¢æ¬¡æ£€æµ‹
        setInterval(() => {
            if (gameState.isPlaying && gameState.enemies.length === 0) {
                setTimeout(() => {
                    if (gameState.wave > 0 && gameState.wave % 5 === 0) {
                        levelComplete();
                    } else {
                        spawnWave();
                    }
                }, gameConfig.waveDelay);
            }
        }, gameConfig.waveCheckInterval);

        // åˆå§‹åŒ–UI
        updateUI();
    </script>
</body>
</html>
