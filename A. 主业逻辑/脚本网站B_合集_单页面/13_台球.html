<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç‚«å½©å°çƒå¤§å¸ˆ</title>
    <style>
        :root {
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --accent-color: #f093fb;
            --table-color: #2d3748;
            --border-color: #4a5568;
            --text-color: white;
            --shadow-color: rgba(0,0,0,0.3);
            --ball-size: 0.025;
            --pocket-size: 0.04;
            --friction: 0.98;
            --min-velocity: 0.1;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow-x: auto;
            position: relative;
            min-height: 100vh;
            transition: background 1s ease;
        }

        #gameContainer {
            width: 100%;
            max-width: 800px;
            height: 100vh;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 20px;
        }

        #gameCanvas {
            border: 3px solid var(--border-color);
            border-radius: 20px;
            box-shadow: 0 20px 40px var(--shadow-color);
            background: var(--table-color);
            width: 100%;
            max-height: 70vh;
            cursor: crosshair;
            transition: all 0.3s ease;
        }

        #gameCanvas:active {
            transform: scale(0.98);
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--text-color);
            font-size: 18px;
            text-shadow: 2px 2px 4px var(--shadow-color);
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        #powerBar {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 20px var(--shadow-color);
        }

        #powerFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88 0%, #ffff00 50%, #ff0066 100%);
            width: 0%;
            transition: width 0.1s;
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
        }

        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 15px 25px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: var(--text-color);
            cursor: pointer;
            box-shadow: 0 8px 16px var(--shadow-color);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 24px var(--shadow-color);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 6px 12px var(--shadow-color);
        }

        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95);
            padding: 50px;
            border-radius: 30px;
            text-align: center;
            color: #333;
            box-shadow: 0 20px 40px var(--shadow-color);
            backdrop-filter: blur(10px);
            z-index: 100;
            max-width: 90%;
        }

        #menu h2 {
            margin-bottom: 30px;
            font-size: 32px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: none;
        }

        #menu button {
            margin: 15px;
            width: 220px;
            padding: 20px;
            font-size: 20px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .hidden {
            display: none !important;
        }

        #danmakuContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 50;
        }

        .danmaku {
            position: absolute;
            color: white;
            font-size: 22px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            white-space: nowrap;
            animation: danmaku-move 8s linear;
            opacity: 0;
        }

        @keyframes danmaku-move {
            0% {
                transform: translateX(100%);
                opacity: 1;
            }
            100% {
                transform: translateX(-100%);
                opacity: 0.8;
            }
        }

        .cheer-effect {
            position: absolute;
            font-size: 30px;
            animation: cheer-pop 2s ease-out forwards;
            pointer-events: none;
            z-index: 60;
        }

        @keyframes cheer-pop {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: scale(1.5) rotate(15deg);
            }
            100% {
                transform: scale(1) rotate(-5deg) translateY(-80px);
                opacity: 0;
            }
        }

        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            pointer-events: none;
            animation: particle-float 3s ease-out forwards;
        }

        @keyframes particle-float {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        #combo {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 24px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            padding: 15px 25px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
        }

        #soundToggle {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        #soundToggle:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        @media (max-width: 480px) {
            #ui {
                font-size: 14px;
                padding: 15px;
            }
            
            #powerBar {
                width: 250px;
                height: 25px;
            }
            
            button {
                padding: 12px 20px;
                font-size: 14px;
            }
            
            #menu {
                padding: 30px;
            }
            
            #menu h2 {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div>ğŸ® ç©å®¶: <span id="playerScore">0</span></div>
            <div>ğŸ¤– AI: <span id="aiScore">0</span></div>
            <div>ğŸ¯ å›åˆ: <span id="currentPlayer">ç©å®¶</span></div>
        </div>
        <div id="combo" style="display: none;">
            ğŸ”¥ è¿å‡» x<span id="comboCount">0</span>
        </div>
        <div id="powerBar">
            <div id="powerFill"></div>
        </div>
        <div id="controls">
            <button id="shootBtn">âš¡ å‡»çƒ</button>
            <button id="resetBtn">ğŸ”„ é‡ç½®</button>
            <button id="cheerBtn">ğŸ‰ å–å½©</button>
            <button id="effectBtn">âœ¨ ç‰¹æ•ˆ</button>
        </div>
        <div id="menu">
            <h2>ğŸ± ç‚«å½©å°çƒå¤§å¸ˆ ğŸ±</h2>
            <p>é€‰æ‹©ä½ çš„æ¸¸æˆæ¨¡å¼</p>
            <button onclick="startGame('8ball')">ğŸ± 8 çƒæ¨¡å¼</button>
            <button onclick="startGame('9ball')">ğŸ¯ 9 çƒæ¨¡å¼</button>
        </div>
        <div id="danmakuContainer"></div>
        <button id="soundToggle">ğŸ”Š</button>
    </div>

    <script>
        // ==================== é…ç½®å‚æ•° ====================
        // ä¸€. æ¸¸æˆé…ç½®åˆå§‹åŒ–
        const CONFIG = {
            // 1. èƒŒæ™¯é¢œè‰²æ•°ç»„ï¼ˆ15ç§å¹´è½»åŒ–æ¸å˜è‰²ï¼‰
            backgroundColors: [
                'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                'linear-gradient(135deg, #30cfd0 0%, #330867 100%)',
                'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
                'linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%)',
                'linear-gradient(135deg, #fbc2eb 0%, #a6c1ee 100%)',
                'linear-gradient(135deg, #fdcbf1 0%, #e6dee9 100%)',
                'linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%)',
                'linear-gradient(135deg, #d299c2 0%, #fef9d7 100%)',
                'linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%)',
                'linear-gradient(135deg, #fddb92 0%, #d1fdff 100%)',
                'linear-gradient(135deg, #9890e3 0%, #b1f4cf 100%)'
            ],
            // 2. çƒä½“é¢œè‰²æ•°ç»„ï¼ˆ15ç§æµ…è‰²ç³»ï¼‰
            ballColors: [
                '#FFE5B4', '#FFB6C1', '#E6E6FA', '#F0E68C', 
                '#DDA0DD', '#F0FFFF', '#FFE4E1', '#F5DEB3',
                '#E0FFFF', '#FAFAD2', '#FFF0F5', '#F5FFFA',
                '#FFF8DC', '#FFFAF0', '#F0FFF0'
            ],
            // 3. ç‰©ç†å‚æ•°
            sizes: {
                ballRatio: 0.025,
                pocketRatio: 0.04,
                maxCanvasWidth: 0.95,
                maxCanvasHeight: 0.85,
                aspectRatio: 16/9
            },
            physics: {
                friction: 0.98,
                minVelocity: 0.1,
                powerMultiplier: 0.2,
                aiDelay: 1000
            },
            // 4. å¼¹å¹•å’Œå–å½©å†…å®¹
            danmaku: [
                "å¤ªæ£’äº†ï¼", "å®Œç¾è¿›çƒï¼", "ç¥æ“ä½œï¼", "666ï¼", "ç²¾å½©ï¼",
                "é«˜æ‰‹ï¼", "ç»äº†ï¼", "æ¼‚äº®ï¼", "ä¸“ä¸šï¼", "å¤§å¸ˆçº§ï¼",
                "è¿™æŠ€æœ¯ï¼", "ä¸å¯æ€è®®ï¼", "ç²¾å‡†ï¼", "å®Œç¾ï¼", "ç‰›ï¼"
            ],
            cheers: ["ğŸ‰", "ğŸŠ", "âœ¨", "ğŸŒŸ", "ğŸ’«", "ğŸ”¥", "ğŸ’¯", "ğŸ‘"],
            soundEnabled: true
        };

        // ==================== æ¸¸æˆæ ¸å¿ƒç±» ====================
        // äºŒ. çƒç±»å®šä¹‰
        class Ball {
            // 1. æ„é€ å‡½æ•°
            constructor(x, y, color, number = null, isCueBall = false) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.radius = canvas.width * CONFIG.sizes.ballRatio;
                this.color = color;
                this.number = number;
                this.isCueBall = isCueBall;
                this.isPocketed = false;
                this.mass = 1;
                this.trail = [];
            }

            // 2. æ›´æ–°çƒçš„ä½ç½®å’ŒçŠ¶æ€
            update() {
                if (this.isPocketed) return;
                
                // æ·»åŠ è½¨è¿¹æ•ˆæœ
                if (Math.abs(this.vx) > 0.5 || Math.abs(this.vy) > 0.5) {
                    this.trail.push({x: this.x, y: this.y, alpha: 1});
                    if (this.trail.length > 10) {
                        this.trail.shift();
                    }
                }
                
                this.x += this.vx;
                this.y += this.vy;
                
                this.vx *= CONFIG.physics.friction;
                this.vy *= CONFIG.physics.friction;
                
                if (Math.abs(this.vx) < CONFIG.physics.minVelocity) this.vx = 0;
                if (Math.abs(this.vy) < CONFIG.physics.minVelocity) this.vy = 0;
                
                // è¾¹ç•Œç¢°æ’æ£€æµ‹
                if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                    this.vx = -this.vx;
                    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                }
                
                if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) {
                    this.vy = -this.vy;
                    this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
                }
                
                // è¿›çƒæ£€æµ‹
                game.pockets.forEach(pocket => {
                    const dist = Math.sqrt((this.x - pocket.x) ** 2 + (this.y - pocket.y) ** 2);
                    if (dist < pocket.radius) {
                        this.isPocketed = true;
                        this.vx = 0;
                        this.vy = 0;
                        
                        if (this.isCueBall) {
                            resetCueBall();
                        } else {
                            // ä¿®æ­£è§„åˆ™ï¼šè¿›çƒåç»§ç»­å½“å‰ç©å®¶å›åˆ
                            if (game.currentPlayer === 'player') {
                                game.playerScore++;
                                game.combo++;
                                ui.showDanmaku();
                                ui.showCheerEffect(this.x, this.y);
                                ui.changeBackground();
                                ui.createParticles(this.x, this.y);
                                ui.updateCombo();
                                // ä¿æŒç©å®¶å›åˆï¼Œä¸åˆ‡æ¢åˆ°AI
                            } else {
                                game.aiScore++;
                                game.combo = 0;
                                ui.updateCombo();
                                // AIè¿›çƒåä¿æŒAIå›åˆ
                            }
                            updateUI();
                        }
                    }
                });
                
                // æ›´æ–°è½¨è¿¹é€æ˜åº¦
                this.trail = this.trail.map(point => ({
                    ...point,
                    alpha: point.alpha * 0.9
                })).filter(point => point.alpha > 0.1);
            }

            // 3. ç»˜åˆ¶çƒä½“
            draw() {
                if (this.isPocketed) return;
                
                // ç»˜åˆ¶è½¨è¿¹
                this.trail.forEach((point, index) => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, this.radius * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${point.alpha * 0.3})`;
                    ctx.fill();
                });
                
                // çƒä½“é˜´å½±
                ctx.beginPath();
                ctx.arc(this.x + 2, this.y + 2, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fill();
                
                // çƒä½“ä¸»ä½“
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // é«˜å…‰æ•ˆæœ
                const gradient = ctx.createRadialGradient(
                    this.x - this.radius * 0.3, 
                    this.y - this.radius * 0.3, 
                    0,
                    this.x, this.y, this.radius
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // çƒå·
                if (this.number !== null && !this.isCueBall) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 0.6, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fill();
                    
                    ctx.fillStyle = '#333';
                    ctx.font = `bold ${this.radius * 0.8}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.number, this.x, this.y);
                }
            }
        }

        // ==================== UIç®¡ç†ç±» ====================
        // ä¸‰. UIæ•ˆæœç®¡ç†
        class UIManager {
            // 1. æ„é€ å‡½æ•°
            constructor() {
                this.danmakuContainer = document.getElementById('danmakuContainer');
                this.currentBgIndex = 0;
            }

            // 2. æ˜¾ç¤ºå¼¹å¹•
            showDanmaku() {
                if (Math.random() > 0.5) {
                    const danmaku = document.createElement('div');
                    danmaku.className = 'danmaku';
                    danmaku.textContent = CONFIG.danmaku[Math.floor(Math.random() * CONFIG.danmaku.length)];
                    danmaku.style.top = Math.random() * 80 + '%';
                    danmaku.style.left = '100%';
                    danmaku.style.color = `hsl(${Math.random() * 360}, 100%, 80%)`;
                    
                    this.danmakuContainer.appendChild(danmaku);
                    
                    setTimeout(() => {
                        danmaku.remove();
                    }, 8000);
                }
            }

            // 3. æ˜¾ç¤ºå–å½©æ•ˆæœ
            showCheerEffect(x, y) {
                const cheer = document.createElement('div');
                cheer.className = 'cheer-effect';
                cheer.textContent = CONFIG.cheers[Math.floor(Math.random() * CONFIG.cheers.length)];
                
                const rect = canvas.getBoundingClientRect();
                cheer.style.left = `${rect.left + x}px`;
                cheer.style.top = `${rect.top + y}px`;
                
                document.body.appendChild(cheer);
                
                setTimeout(() => {
                    cheer.remove();
                }, 2000);
            }

            // 4. åˆ‡æ¢èƒŒæ™¯é¢œè‰²
            changeBackground() {
                this.currentBgIndex = (this.currentBgIndex + 1) % CONFIG.backgroundColors.length;
                document.body.style.background = CONFIG.backgroundColors[this.currentBgIndex];
            }

            // 5. åˆ›å»ºç²’å­æ•ˆæœ
            createParticles(x, y) {
                const rect = canvas.getBoundingClientRect();
                for (let i = 0; i < 10; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = `${rect.left + x}px`;
                    particle.style.top = `${rect.top + y}px`;
                    particle.style.background = `hsl(${Math.random() * 360}, 100%, 70%)`;
                    particle.style.setProperty('--tx', `${(Math.random() - 0.5) * 200}px`);
                    particle.style.setProperty('--ty', `${(Math.random() - 0.5) * 200}px`);
                    
                    document.body.appendChild(particle);
                    
                    setTimeout(() => {
                        particle.remove();
                    }, 3000);
                }
            }

            // 6. æ›´æ–°è¿å‡»æ˜¾ç¤º
            updateCombo() {
                const comboEl = document.getElementById('combo');
                const comboCount = document.getElementById('comboCount');
                
                if (game.combo > 1) {
                    comboEl.style.display = 'block';
                    comboCount.textContent = game.combo;
                    
                    comboEl.style.animation = 'none';
                    setTimeout(() => {
                        comboEl.style.animation = 'cheer-pop 0.5s ease-out';
                    }, 10);
                } else {
                    comboEl.style.display = 'none';
                }
            }

            // 7. åˆ‡æ¢éŸ³æ•ˆ
            toggleSound() {
                CONFIG.soundEnabled = !CONFIG.soundEnabled;
                document.getElementById('soundToggle').textContent = CONFIG.soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
            }
        }

        // ==================== æ¸¸æˆåˆå§‹åŒ– ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const ui = new UIManager();

        // æ¸¸æˆçŠ¶æ€
        const game = {
            mode: '8ball',
            currentPlayer: 'player',
            playerScore: 0,
            aiScore: 0,
            power: 0,
            isAiming: false,
            isPowerCharging: false,
            balls: [],
            cueBall: null,
            pockets: [],
            mouseX: 0,
            mouseY: 0,
            combo: 0,
            effects: true,
            playerMissed: false // æ ‡è®°ç©å®¶æ˜¯å¦å¤±è¯¯
        };

        // å››. ç”»å¸ƒé€‚é…
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const maxWidth = container.clientWidth * CONFIG.sizes.maxCanvasWidth;
            const maxHeight = window.innerHeight * CONFIG.sizes.maxCanvasHeight;
            const aspectRatio = CONFIG.sizes.aspectRatio;
            
            if (maxHeight / aspectRatio < maxWidth) {
                canvas.height = maxHeight;
                canvas.width = maxHeight / aspectRatio;
            } else {
                canvas.width = maxWidth;
                canvas.height = maxWidth * aspectRatio;
            }
            
            initGame();
        }

        // äº”. æ¸¸æˆåˆå§‹åŒ–
        function initGame() {
            game.balls = [];
            game.pockets = [];
            game.combo = 0;
            game.playerMissed = false;
            ui.updateCombo();
            
            // åˆ›å»ºçƒè¢‹
            const pocketRadius = canvas.width * CONFIG.sizes.pocketRatio;
            const positions = [
                {x: pocketRadius, y: pocketRadius},
                {x: canvas.width / 2, y: pocketRadius},
                {x: canvas.width - pocketRadius, y: pocketRadius},
                {x: pocketRadius, y: canvas.height - pocketRadius},
                {x: canvas.width / 2, y: canvas.height - pocketRadius},
                {x: canvas.width - pocketRadius, y: canvas.height - pocketRadius}
            ];
            
            positions.forEach(pos => {
                game.pockets.push({x: pos.x, y: pos.y, radius: pocketRadius});
            });
            
            // åˆ›å»ºä¸»çƒ
            game.cueBall = new Ball(canvas.width / 2, canvas.height * 0.8, 'white', null, true);
            game.balls.push(game.cueBall);
            
            // åˆ›å»ºç›®æ ‡çƒ
            const ballRadius = game.cueBall.radius;
            const startX = canvas.width / 2;
            const startY = canvas.height * 0.2;
            const ballNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
            let ballIndex = 0;
            
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col <= row; col++) {
                    if (ballIndex < ballNumbers.length) {
                        const x = startX + (col - row / 2) * ballRadius * 2;
                        const y = startY - row * ballRadius * 1.8;
                        const color = CONFIG.ballColors[ballIndex % CONFIG.ballColors.length];
                        const ball = new Ball(x, y, color, ballNumbers[ballIndex]);
                        game.balls.push(ball);
                        ballIndex++;
                    }
                }
            }
        }

        // å…­. ç¢°æ’æ£€æµ‹
        function checkBallCollisions() {
            for (let i = 0; i < game.balls.length; i++) {
                for (let j = i + 1; j < game.balls.length; j++) {
                    const ball1 = game.balls[i];
                    const ball2 = game.balls[j];
                    
                    if (ball1.isPocketed || ball2.isPocketed) continue;
                    
                    const dx = ball2.x - ball1.x;
                    const dy = ball2.y - ball1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < ball1.radius + ball2.radius) {
                        // ç¢°æ’å“åº”
                        const angle = Math.atan2(dy, dx);
                        const sin = Math.sin(angle);
                        const cos = Math.cos(angle);
                        
                        // æ—‹è½¬é€Ÿåº¦
                        const vx1 = ball1.vx * cos + ball1.vy * sin;
                        const vy1 = ball1.vy * cos - ball1.vx * sin;
                        const vx2 = ball2.vx * cos + ball2.vy * sin;
                        const vy2 = ball2.vy * cos - ball2.vx * sin;
                        
                        // äº¤æ¢é€Ÿåº¦
                        const finalVx1 = vx2;
                        const finalVx2 = vx1;
                        
                        // æ—‹è½¬å›åŸåæ ‡ç³»
                        ball1.vx = finalVx1 * cos - vy1 * sin;
                        ball1.vy = vy1 * cos + finalVx1 * sin;
                        ball2.vx = finalVx2 * cos - vy2 * sin;
                        ball2.vy = vy2 * cos + finalVx2 * sin;
                        
                        // åˆ†ç¦»é‡å 
                        const overlap = ball1.radius + ball2.radius - distance;
                        const separationX = dx / distance * overlap / 2;
                        const separationY = dy / distance * overlap / 2;
                        
                        ball1.x -= separationX;
                        ball1.y -= separationY;
                        ball2.x += separationX;
                        ball2.y += separationY;
                    }
                }
            }
        }

        // ä¸ƒ. ç»˜åˆ¶çƒæ†
        function drawCue() {
            if (game.currentPlayer !== 'player' || game.cueBall.isPocketed) return;
            
            const angle = Math.atan2(game.mouseY - game.cueBall.y, game.mouseX - game.cueBall.x);
            const cueLength = canvas.width * 0.3;
            const cueDistance = game.cueBall.radius + game.power * canvas.width * 0.002;
            
            const startX = game.cueBall.x - Math.cos(angle) * (cueLength + cueDistance);
            const startY = game.cueBall.y - Math.sin(angle) * (cueLength + cueDistance);
            const endX = game.cueBall.x - Math.cos(angle) * cueDistance;
            const endY = game.cueBall.y - Math.sin(angle) * cueDistance;
            
            // çƒæ†ä¸»ä½“æ¸å˜
            const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
            gradient.addColorStop(0, '#8B4513');
            gradient.addColorStop(1, '#654321');
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.stroke();
            
            // çƒæ†å°–ç«¯
            ctx.beginPath();
            ctx.arc(endX, endY, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#654321';
            ctx.fill();
            
            // ç„å‡†çº¿
            ctx.beginPath();
            ctx.setLineDash([10, 10]);
            ctx.moveTo(game.cueBall.x, game.cueBall.y);
            ctx.lineTo(game.cueBall.x + Math.cos(angle) * 150, game.cueBall.y + Math.sin(angle) * 150);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.setLineDash([]);
            
            // åŠ›é‡æŒ‡ç¤ºå™¨
            if (game.power > 0) {
                const powerX = game.cueBall.x + Math.cos(angle) * 50;
                const powerY = game.cueBall.y + Math.sin(angle) * 50;
                
                ctx.beginPath();
                ctx.arc(powerX, powerY, 10 + game.power / 5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, ${255 - game.power * 2}, 0, 0.5)`;
                ctx.fill();
            }
        }

        // å…«. é‡ç½®ä¸»çƒ
        function resetCueBall() {
            game.cueBall.x = canvas.width / 2;
            game.cueBall.y = canvas.height * 0.8;
            game.cueBall.isPocketed = false;
            game.combo = 0;
            ui.updateCombo();
        }

        // ä¹. æ›´æ–°UI
        function updateUI() {
            document.getElementById('playerScore').textContent = game.playerScore;
            document.getElementById('aiScore').textContent = game.aiScore;
            document.getElementById('currentPlayer').textContent = 
                game.currentPlayer === 'player' ? 'ç©å®¶' : 'AI';
        }

        // å. AIé€»è¾‘
        function aiTurn() {
            if (game.currentPlayer !== 'ai') return;
            
            let targetBall = null;
            let minDistance = Infinity;
            
            game.balls.forEach(ball => {
                if (!ball.isPocketed && !ball.isCueBall) {
                    const dist = Math.sqrt((ball.x - game.cueBall.x) ** 2 + 
                                         (ball.y - game.cueBall.y) ** 2);
                    if (dist < minDistance) {
                        minDistance = dist;
                        targetBall = ball;
                    }
                }
            });
            
            if (targetBall) {
                const angle = Math.atan2(targetBall.y - game.cueBall.y, 
                                        targetBall.x - game.cueBall.x);
                const power = Math.min(0.7, minDistance / (canvas.height * 0.5));
                
                setTimeout(() => {
                    game.cueBall.vx = Math.cos(angle) * power * 15;
                    game.cueBall.vy = Math.sin(angle) * power * 15;
                    game.currentPlayer = 'player';
                    updateUI();
                }, CONFIG.physics.aiDelay);
            }
        }

        // åä¸€. æ¸¸æˆå¾ªç¯
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶çƒè¢‹
            game.pockets.forEach(pocket => {
                ctx.beginPath();
                ctx.arc(pocket.x, pocket.y, pocket.radius + 2, 0, Math.PI * 2);
                ctx.fillStyle = '#2d3748';
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(pocket.x, pocket.y, pocket.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#000';
                ctx.fill();
                ctx.strokeStyle = '#4a5568';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
            
            // æ›´æ–°å’Œç»˜åˆ¶çƒ
            let movingBalls = false;
            let ballPocketed = false;
            
            game.balls.forEach(ball => {
                const wasPocketed = ball.isPocketed;
                ball.update();
                if (Math.abs(ball.vx) > 0 || Math.abs(ball.vy) > 0) {
                    movingBalls = true;
                }
                // æ£€æµ‹æ˜¯å¦æœ‰çƒåˆšè¿›è¢‹
                if (!wasPocketed && ball.isPocketed && !ball.isCueBall) {
                    ballPocketed = true;
                }
            });
            
            checkBallCollisions();
            game.balls.forEach(ball => ball.draw());
            
            // ç»˜åˆ¶çƒæ†
            if (!movingBalls && game.currentPlayer === 'player') {
                drawCue();
            }
            
            // æ›´æ–°åŠ›é‡æ¡
            if (game.isPowerCharging) {
                game.power = Math.min(game.power + 2, 100);
                document.getElementById('powerFill').style.width = game.power + '%';
            }
            
            // å¤„ç†å›åˆåˆ‡æ¢
            if (!movingBalls) {
                if (game.currentPlayer === 'ai') {
                    aiTurn();
                } else if (game.currentPlayer === 'player' && !ballPocketed && !game.isPowerCharging) {
                    // ç©å®¶æ²¡æœ‰è¿›çƒä¸”æ²¡æœ‰åœ¨è“„åŠ›ï¼Œåˆ‡æ¢åˆ°AI
                    if (!game.playerMissed) {
                        game.playerMissed = true;
                        setTimeout(() => {
                            if (game.currentPlayer === 'player' && !game.isPowerCharging) {
                                game.currentPlayer = 'ai';
                                game.playerMissed = false;
                                updateUI();
                            }
                        }, 1000);
                    }
                }
            }
            
            requestAnimationFrame(gameLoop);
        }

        // åäºŒ. äº‹ä»¶å¤„ç†
        // é¼ æ ‡äº‹ä»¶
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            game.mouseX = e.clientX - rect.left;
            game.mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', () => {
            if (game.currentPlayer === 'player' && !game.isPowerCharging) {
                game.isPowerCharging = true;
                game.power = 0;
                game.playerMissed = false;
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (game.currentPlayer === 'player' && game.isPowerCharging) {
                shoot();
            }
        });

        // è§¦æ‘¸äº‹ä»¶
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            game.mouseX = touch.clientX - rect.left;
            game.mouseY = touch.clientY - rect.top;
            
            if (game.currentPlayer === 'player' && !game.isPowerCharging) {
                game.isPowerCharging = true;
                game.power = 0;
                game.playerMissed = false;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            game.mouseX = touch.clientX - rect.left;
            game.mouseY = touch.clientY - rect.top;
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (game.currentPlayer === 'player' && game.isPowerCharging) {
                shoot();
            }
        });

        // å‡»çƒå‡½æ•°
        function shoot() {
            game.isPowerCharging = false;
            const angle = Math.atan2(game.mouseY - game.cueBall.y, 
                                    game.mouseX - game.cueBall.x);
            game.cueBall.vx = Math.cos(angle) * game.power * CONFIG.physics.powerMultiplier;
            game.cueBall.vy = Math.sin(angle) * game.power * CONFIG.physics.powerMultiplier;
            game.power = 0;
            document.getElementById('powerFill').style.width = '0%';
        }

        // æŒ‰é’®äº‹ä»¶
        document.getElementById('shootBtn').addEventListener('click', () => {
            if (game.currentPlayer === 'player' && !game.isPowerCharging) {
                game.isPowerCharging = true;
                game.power = 0;
                game.playerMissed = false;
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initGame();
            game.currentPlayer = 'player';
            game.playerScore = 0;
            game.aiScore = 0;
            updateUI();
        });

        document.getElementById('cheerBtn').addEventListener('click', () => {
            ui.showDanmaku();
            ui.showCheerEffect(canvas.width / 2, canvas.height / 2);
            ui.createParticles(canvas.width / 2, canvas.height / 2);
        });

        document.getElementById('effectBtn').addEventListener('click', () => {
            game.effects = !game.effects;
            if (game.effects) {
                ui.changeBackground();
                ui.showDanmaku();
            }
        });

        document.getElementById('soundToggle').addEventListener('click', () => {
            ui.toggleSound();
        });

        // å¼€å§‹æ¸¸æˆ
        function startGame(mode) {
            game.mode = mode;
            document.getElementById('menu').classList.add('hidden');
            initGame();
            updateUI();
            gameLoop();
        }

        // é˜²æ­¢è§¦æ‘¸æ»šåŠ¨
        document.addEventListener('touchmove', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });

        // åˆå§‹åŒ–
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>
