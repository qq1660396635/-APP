<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>水果忍者</title>
    <style>
        /* 一、基础样式配置 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            user-select: none;
            background: #f0f0f0;
        }
        
        /* 二、游戏容器样式 */
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 800px;
            max-height: 1000px;
            margin: 0 auto;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            cursor: crosshair;
            background: transparent;
            width: 100%;
            height: 100%;
        }
        
        /* 三、UI元素样式 */
        #gameUI {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }
        
        #shopBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }
        
        #shopPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 15px;
            color: white;
            display: none;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 100;
        }
        
        /* 四、皮肤商店样式 */
        .skin-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            margin: 10px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .skin-item:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(5px);
        }
        
        .skin-item.owned {
            background: rgba(0,255,0,0.2);
        }
        
        .skin-item.selected {
            border: 2px solid #FFD700;
            box-shadow: 0 0 10px #FFD700;
        }
        
        .skin-name {
            font-size: 18px;
            font-weight: bold;
        }
        
        .skin-price {
            color: #FFD700;
            font-size: 16px;
        }
        
        .skin-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        /* 五、按钮样式 */
        button {
            padding: 10px 20px;
            font-size: 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #45a049;
            transform: scale(1.05);
        }
        
        #closeShop {
            background: #f44336;
        }
        
        #closeShop:hover {
            background: #da190b;
        }
        
        /* 六、动画效果 */
        .coin-effect {
            position: absolute;
            color: #FFD700;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
            animation: coinFloat 1s ease-out forwards;
        }
        
        @keyframes coinFloat {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }
        
        .combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            pointer-events: none;
            animation: comboAnim 1s ease-out forwards;
        }
        
        @keyframes comboAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="gameUI">
            <div>金币: <span id="coins">0</span></div>
            <div>得分: <span id="score">0</span></div>
            <div>连击: <span id="combo">0</span></div>
        </div>
        <button id="shopBtn" onclick="toggleShop()">商店</button>
        <div id="shopPanel">
            <h2>皮肤商店</h2>
            <div id="skinList"></div>
            <button id="closeShop" onclick="toggleShop()">关闭</button>
        </div>
    </div>

    <script>
        // 一、游戏配置变量
        const gameConfig = {
            // 1. 水果生成配置
            fruitSpawnRate: 0.02,      // 水果生成概率 (原0.5降低到0.02)
            maxFruits: 3,              // 最大同时存在水果数
            gravity: 0.08,             // 重力加速度
            
            // 2. 游戏尺寸配置
            canvasWidth: 800,          // 默认画布宽度
            canvasHeight: 1000,        // 默认画布高度
            maxContainerWidth: 800,    // 最大容器宽度
            maxContainerHeight: 1000,  // 最大容器高度
            
            // 3. UI文本配置
            uiText: {
                coins: "金币: ",
                score: "得分: ",
                combo: "连击: ",
                shop: "商店",
                close: "关闭",
                shopTitle: "皮肤商店",
                owned: "已拥有",
                insufficientCoins: "金币不足！"
            },
            
            // 4. 颜色配置
            colors: {
                background: {
                    start: '#FFF8E7',
                    end: '#FFEFD5'
                },
                board: {
                    main: '#D2B48C',
                    secondary: '#BC9A6A',
                    border: '#8B7355'
                },
                text: '#FFFFFF',
                shadow: 'rgba(0,0,0,0.5)'
            },
            
            // 5. 音效配置
            soundEnabled: true,
            soundVolume: 0.5
        };

        // 二、游戏状态管理
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        
        // 1. 初始化画布尺寸
        function resizeCanvas() {
            const containerWidth = Math.min(window.innerWidth, gameConfig.maxContainerWidth);
            const containerHeight = Math.min(window.innerHeight, gameConfig.maxContainerHeight);
            
            gameContainer.style.width = containerWidth + 'px';
            gameContainer.style.height = containerHeight + 'px';
            
            canvas.width = containerWidth;
            canvas.height = containerHeight;
        }
        
        // 2. 游戏状态
        let gameState = {
            coins: 0,
            score: 0,
            combo: 0,
            lastSliceTime: 0,
            currentSkin: 'default',
            ownedSkins: ['default'],
            fruits: [],
            particles: [],
            sliceTrails: [],
            backgroundFruits: []
        };

        // 三、游戏资源初始化
        // 1. 音效系统
        const sounds = {
            slice: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmFgU7k9n1unEiBC13yO/eizEIHWq+8+OWT'),
            coin: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmFgU7k9n1unEiBC13yO/eizEIHWq+8+OWT'),
            combo: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmFgU7k9n1unEiBC13yO/eizEIHWq+8+OWT')
        };
        
        // 设置音量
        Object.values(sounds).forEach(sound => {
            sound.volume = gameConfig.soundVolume;
        });

        // 2. 水果类型配置
        const fruitTypes = [
            { name: '苹果', color: '#E74C3C', highlight: '#FF6B6B', points: 10, coinChance: 1.0, stemColor: '#2ECC71' },
            { name: '橙子', color: '#E67E22', highlight: '#FFA500', points: 15, coinChance: 1.0, stemColor: '#27AE60' },
            { name: '西瓜', color: '#27AE60', highlight: '#4ECDC4', points: 20, coinChance: 1.0, stemColor: '#229954' },
            { name: '葡萄', color: '#8E44AD', highlight: '#9B59B6', points: 25, coinChance: 1.0, stemColor: '#196F3D' },
            { name: '香蕉', color: '#F1C40F', highlight: '#F39C12', points: 30, coinChance: 1.0, stemColor: '#7D6608' },
            { name: '猕猴桃', color: '#8F9779', highlight: '#A4A688', points: 35, coinChance: 1.0, stemColor: '#5D6D3E' }
        ];

        // 3. 皮肤系统配置
        const skins = {
            default: { name: '默认刀', price: 0, color: '#FFFFFF', effect: 'normal', owned: true },
            white: { name: '白色刀刃', price: 100, color: '#F0F0F0', effect: 'glow', owned: false },
            pixel: { name: '像素刀', price: 200, color: '#8B4513', effect: 'pixel', owned: false },
            rainbow: { name: '彩虹刀', price: 500, color: 'rainbow', effect: 'rainbow', owned: false },
            dragon: { name: '青龙', price: 1000, color: '#00FF00', effect: 'dragon', owned: false },
            flame: { name: '烈焰之刃', price: 300, color: '#FF4500', effect: 'flame', owned: false },
            ice: { name: '寒冰之刃', price: 300, color: '#00CED1', effect: 'ice', owned: false },
            lightning: { name: '闪电', price: 500, color: '#FFD700', effect: 'lightning', owned: false },
            shadow: { name: '暗影', price: 600, color: '#2F2F2F', effect: 'shadow', owned: false },
            gold: { name: '黄金', price: 1000, color: '#FFD700', effect: 'gold', owned: false }
        };

        // 四、游戏核心类
        // 1. 背景装饰水果类
        class BackgroundFruit {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = canvas.height - 80 - Math.random() * 150;
                this.radius = 15 + Math.random() * 25;
                this.type = fruitTypes[Math.floor(Math.random() * fruitTypes.length)];
                this.rotation = Math.random() * Math.PI * 2;
                this.sliced = Math.random() < 0.6;
                this.slicePieces = [];
                this.opacity = 0.6 + Math.random() * 0.3;
                this.particles = [];
                
                if (this.sliced) {
                    this.createSlicePieces();
                    this.createJuiceParticles();
                }
            }
            
            createSlicePieces() {
                for (let i = 0; i < 3; i++) {
                    this.slicePieces.push({
                        x: this.x + (Math.random() - 0.5) * 60,
                        y: this.y + (Math.random() - 0.5) * 40,
                        rotation: Math.random() * Math.PI * 2,
                        radius: this.radius * (0.4 + Math.random() * 0.4),
                        startAngle: Math.random() * Math.PI,
                        endAngle: Math.random() * Math.PI + Math.PI
                    });
                }
            }
            
            createJuiceParticles() {
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: this.x + (Math.random() - 0.5) * 30,
                        y: this.y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 3,
                        vy: -Math.random() * 3,
                        size: 2 + Math.random() * 4,
                        color: this.type.highlight,
                        life: 0.8 + Math.random() * 0.4
                    });
                }
            }
            
            update() {
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.1;
                    particle.life -= 0.015;
                    particle.size *= 0.98;
                    return particle.life > 0;
                });
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                
                if (this.sliced) {
                    this.slicePieces.forEach(piece => {
                        ctx.save();
                        ctx.translate(piece.x, piece.y);
                        ctx.rotate(piece.rotation);
                        ctx.fillStyle = this.type.color;
                        ctx.beginPath();
                        ctx.arc(0, 0, piece.radius, piece.startAngle, piece.endAngle);
                        ctx.lineTo(0, 0);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(255,255,255,0.3)';
                        ctx.beginPath();
                        ctx.arc(0, 0, piece.radius * 0.7, piece.startAngle, piece.endAngle);
                        ctx.lineTo(0, 0);
                        ctx.closePath();
                        ctx.fill();
                        
                        if (this.type.name === '西瓜') {
                            ctx.fillStyle = '#000000';
                            for (let i = 0; i < 2; i++) {
                                const angle = piece.startAngle + (piece.endAngle - piece.startAngle) * (i + 1) / 3;
                                const x = Math.cos(angle) * piece.radius * 0.5;
                                const y = Math.sin(angle) * piece.radius * 0.5;
                                ctx.beginPath();
                                ctx.arc(x, y, 1.5, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        ctx.restore();
                    });
                    
                    this.particles.forEach(particle => {
                        ctx.save();
                        ctx.globalAlpha = particle.life * this.opacity;
                        ctx.fillStyle = particle.color;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    });
                } else {
                    this.drawWholeFruit();
                }
                ctx.restore();
            }
            
            drawWholeFruit() {
                const fruitType = this.type.name;
                switch(fruitType) {
                    case '苹果':
                        ctx.fillStyle = this.type.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = this.type.highlight;
                        ctx.beginPath();
                        ctx.arc(this.x - this.radius/3, this.y - this.radius/3, this.radius/3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = this.type.stemColor;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - this.radius);
                        ctx.lineTo(this.x, this.y - this.radius - 5);
                        ctx.stroke();
                        break;
                    // 其他水果绘制逻辑类似...
                }
            }
        }

        // 2. 游戏水果类
        class Fruit {
            constructor() {
                const fromLeft = Math.random() < 0.5;
                
                if (fromLeft) {
                    this.x = -50;
                    this.vx = 1.5 + Math.random() * 2;
                } else {
                    this.x = canvas.width + 50;
                    this.vx = -(1.5 + Math.random() * 2);
                }
                
                this.y = Math.random() * canvas.height * 0.5 + 50;
                this.vy = -1 - Math.random() * 2;
                this.gravity = gameConfig.gravity;
                this.radius = 20 + Math.random() * 25;
                this.type = fruitTypes[Math.floor(Math.random() * fruitTypes.length)];
                this.rotation = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.08;
                this.sliced = false;
                this.slicePieces = [];
                this.opacity = 1;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.rotation += this.rotationSpeed;
                
                if (this.sliced) {
                    this.opacity -= 0.02;
                    this.slicePieces.forEach(piece => {
                        piece.x += piece.vx;
                        piece.y += piece.vy;
                        piece.vy += this.gravity;
                        piece.rotation += piece.rotationSpeed;
                        piece.opacity -= 0.03;
                    });
                }
            }
            
            draw() {
                if (!this.sliced) {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    this.drawRealisticFruit();
                    ctx.restore();
                } else {
                    this.slicePieces.forEach(piece => {
                        ctx.save();
                        ctx.globalAlpha = piece.opacity;
                        ctx.translate(piece.x, piece.y);
                        ctx.rotate(piece.rotation);
                        this.drawSlicePiece(piece);
                        ctx.restore();
                    });
                }
            }
            
            drawRealisticFruit() {
                const fruitType = this.type.name;
                switch(fruitType) {
                    case '苹果':
                        this.drawApple();
                        break;
                    case '橙子':
                        this.drawOrange();
                        break;
                    case '西瓜':
                        this.drawWatermelon();
                        break;
                    // 其他水果绘制逻辑...
                }
            }
            
            drawApple() {
                ctx.fillStyle = this.type.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = this.type.highlight;
                ctx.beginPath();
                ctx.arc(-this.radius/3, -this.radius/3, this.radius/3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = this.type.color;
                ctx.beginPath();
                ctx.arc(0, -this.radius/2, this.radius/4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = this.type.stemColor;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, -this.radius);
                ctx.lineTo(0, -this.radius - 8);
                ctx.stroke();
            }
            
            drawOrange() {
                ctx.fillStyle = this.type.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = this.type.highlight;
                ctx.lineWidth = 1;
                for (let i = 0; i < 8; i++) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius - 5, i * Math.PI/4, (i + 1) * Math.PI/4);
                    ctx.stroke();
                }
                
                ctx.fillStyle = this.type.stemColor;
                ctx.beginPath();
                ctx.arc(0, -this.radius, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawWatermelon() {
                ctx.save();
                ctx.scale(1, 0.8);
                ctx.fillStyle = this.type.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = this.type.highlight;
                ctx.lineWidth = 3;
                for (let i = -2; i <= 2; i++) {
                    ctx.beginPath();
                    ctx.arc(0, i * this.radius/4, this.radius, 0, Math.PI);
                    ctx.stroke();
                }
                ctx.restore();
                
                ctx.fillStyle = this.type.stemColor;
                ctx.beginPath();
                ctx.arc(0, -this.radius * 0.8, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawSlicePiece(piece) {
                ctx.fillStyle = this.type.color;
                ctx.beginPath();
                ctx.arc(0, 0, piece.radius, piece.startAngle, piece.endAngle);
                ctx.lineTo(0, 0);
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.beginPath();
                ctx.arc(0, 0, piece.radius * 0.7, piece.startAngle, piece.endAngle);
                ctx.lineTo(0, 0);
                ctx.closePath();
                ctx.fill();
                
                if (this.type.name === '西瓜') {
                    ctx.fillStyle = '#000000';
                    for (let i = 0; i < 3; i++) {
                        const angle = piece.startAngle + (piece.endAngle - piece.startAngle) * (i + 1) / 4;
                        const x = Math.cos(angle) * piece.radius * 0.5;
                        const y = Math.sin(angle) * piece.radius * 0.5;
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            slice() {
                if (this.sliced) return;
                
                this.sliced = true;
                if (gameConfig.soundEnabled) {
                    sounds.slice.currentTime = 0;
                    sounds.slice.play();
                }
                
                for (let i = 0; i < 2; i++) {
                    this.slicePieces.push({
                        x: this.x,
                        y: this.y,
                        vx: (i - 0.5) * 8,
                        vy: -6,
                        radius: this.radius,
                        startAngle: i * Math.PI,
                        endAngle: (i + 1) * Math.PI,
                        rotation: 0,
                        rotationSpeed: (Math.random() - 0.5) * 0.3,
                        opacity: 1
                    });
                }
                
                gameState.score += this.type.points;
                
                let coinMultiplier = 1;
                const currentTime = Date.now();
                
                if (currentTime - gameState.lastSliceTime < 1500) {
                    gameState.combo++;
                    
                    if (gameState.combo >= 10) {
                        coinMultiplier = 10;
                        showComboEffect(10);
                        if (gameConfig.soundEnabled) {
                            sounds.combo.currentTime = 0;
                            sounds.combo.play();
                        }
                    } else if (gameState.combo >= 5) {
                        coinMultiplier = 5;
                        if (gameState.combo === 5) {
                            showComboEffect(5);
                            if (gameConfig.soundEnabled) {
                                sounds.combo.currentTime = 0;
                                sounds.combo.play();
                            }
                        }
                    } else if (gameState.combo >= 3) {
                        coinMultiplier = 3;
                        if (gameState.combo === 3) {
                            showComboEffect(3);
                            if (gameConfig.soundEnabled) {
                                sounds.combo.currentTime = 0;
                                sounds.combo.play();
                            }
                        }
                    }
                } else {
                    gameState.combo = 1;
                }
                
                gameState.lastSliceTime = currentTime;
                
                const baseCoins = 10;
                const coinsEarned = baseCoins * coinMultiplier;
                gameState.coins += coinsEarned;
                showCoinEffect(this.x, this.y, coinsEarned);
                
                if (gameConfig.soundEnabled) {
                    sounds.coin.currentTime = 0;
                    sounds.coin.play();
                }
                
                updateUI();
            }
            
            isOffScreen() {
                return (this.x < -100 || this.x > canvas.width + 100 ||
                        this.y > canvas.height + 100 || 
                        (this.sliced && this.opacity <= 0));
            }
        }

        // 3. 粒子效果类
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.color = color;
                this.size = Math.random() * 5 + 2;
                this.life = 1;
                this.gravity = 0.2;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.life -= 0.02;
                this.size *= 0.98;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // 4. 切片轨迹类
        class SliceTrail {
            constructor(x, y) {
                this.points = [{x, y}];
                this.maxLength = 10;
                this.life = 1;
            }
            
            addPoint(x, y) {
                this.points.push({x, y});
                if (this.points.length > this.maxLength) {
                    this.points.shift();
                }
            }
            
            update() {
                this.life -= 0.1;
            }
            
            draw() {
                if (this.points.length < 2) return;
                
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.strokeStyle = getCurrentSkinColor();
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                applySkinEffect(ctx);
                
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.stroke();
                ctx.restore();
            }
        }

        // 五、游戏核心功能
        // 1. 获取当前皮肤颜色
        function getCurrentSkinColor() {
            const skin = skins[gameState.currentSkin];
            const time = Date.now() / 10;
            
            switch (skin.color) {
                case 'rainbow':
                    return `hsl(${time % 360}, 100%, 50%)`;
                default:
                    return skin.color;
            }
        }

        // 2. 应用皮肤特效
        function applySkinEffect(ctx) {
            const skin = skins[gameState.currentSkin];
            
            switch (skin.effect) {
                case 'glow':
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = skin.color;
                    break;
                case 'pixel':
                    ctx.imageSmoothingEnabled = false;
                    break;
                case 'rainbow':
                    ctx.strokeStyle = getCurrentSkinColor();
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = ctx.strokeStyle;
                    break;
                case 'flame':
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#FF4500';
                    ctx.strokeStyle = `hsl(${Math.random() * 60}, 100%, 50%)`;
                    break;
                case 'ice':
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00CED1';
                    break;
                case 'lightning':
                    ctx.shadowBlur = 35;
                    ctx.shadowColor = '#FFD700';
                    ctx.strokeStyle = Math.random() < 0.5 ? '#FFFFFF' : '#FFFF00';
                    break;
                case 'shadow':
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#2F2F2F';
                    break;
                case 'gold':
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#FFD700';
                    break;
            }
        }

        // 3. 显示金币效果
        function showCoinEffect(x, y, amount) {
            const coinElement = document.createElement('div');
            coinElement.className = 'coin-effect';
            coinElement.textContent = `+${amount}`;
            coinElement.style.left = x + 'px';
            coinElement.style.top = y + 'px';
            gameContainer.appendChild(coinElement);
            
            setTimeout(() => {
                if (gameContainer.contains(coinElement)) {
                    gameContainer.removeChild(coinElement);
                }
            }, 1000);
        }

        // 4. 显示连击效果
        function showComboEffect(multiplier) {
            const comboElement = document.createElement('div');
            comboElement.className = 'combo-display';
            comboElement.textContent = `${gameState.combo} 连击! 金币 x${multiplier}`;
            gameContainer.appendChild(comboElement);
            
            setTimeout(() => {
                if (gameContainer.contains(comboElement)) {
                    gameContainer.removeChild(comboElement);
                }
            }, 1000);
        }

        // 5. 更新UI
        function updateUI() {
            document.getElementById('coins').textContent = gameState.coins;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('combo').textContent = gameState.combo;
        }

        // 6. 绘制厨房背景
        function drawKitchenBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, gameConfig.colors.background.start);
            gradient.addColorStop(1, gameConfig.colors.background.end);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制瓷砖
            ctx.strokeStyle = 'rgba(255, 228, 196, 0.3)';
            ctx.lineWidth = 1;
            const tileSize = 60;
            for (let x = 0; x < canvas.width; x += tileSize) {
                for (let y = 0; y < canvas.height; y += tileSize) {
                    ctx.strokeRect(x, y, tileSize, tileSize);
                }
            }
            
            // 绘制砧板
            const boardX = canvas.width / 2;
            const boardY = canvas.height - 150;
            const boardRadius = Math.min(canvas.width * 0.4, 300);
            
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath();
            ctx.arc(boardX + 8, boardY + 8, boardRadius, 0, Math.PI * 2);
            ctx.fill();
            
            const boardGradient = ctx.createRadialGradient(
                boardX - boardRadius/3, boardY - boardRadius/3, 0,
                boardX, boardY, boardRadius
            );
            boardGradient.addColorStop(0, gameConfig.colors.board.main);
            boardGradient.addColorStop(0.7, gameConfig.colors.board.secondary);
            boardGradient.addColorStop(1, '#A0826D');
            
            ctx.fillStyle = boardGradient;
            ctx.beginPath();
            ctx.arc(boardX, boardY, boardRadius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = gameConfig.colors.board.border;
            ctx.lineWidth = 12;
            ctx.beginPath();
            ctx.arc(boardX, boardY, boardRadius - 6, 0, Math.PI * 2);
            ctx.stroke();
            
            // 砧板纹理
            ctx.strokeStyle = 'rgba(139, 115, 85, 0.4)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                const startAngle = (i / 8) * Math.PI * 2;
                const radius = boardRadius * (0.3 + Math.random() * 0.5);
                ctx.arc(boardX, boardY, radius, startAngle, startAngle + Math.PI / 4);
                ctx.stroke();
            }
            
            // 砧板文字
            ctx.fillStyle = 'rgba(101, 67, 33, 0.6)';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('WOODEN', boardX, boardY - 8);
            ctx.font = '12px Arial';
            ctx.fillText('CUTTING BOARD', boardX, boardY + 8);
        }

        // 7. 生成背景装饰水果
        function initBackgroundFruits() {
            const fruitCount = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < fruitCount; i++) {
                gameState.backgroundFruits.push(new BackgroundFruit());
            }
        }

        // 8. 生成水果 - 控制生成量
        function spawnFruit() {
            // 限制同时存在的水果数量
            if (gameState.fruits.length >= gameConfig.maxFruits) {
                return;
            }
            
            // 降低生成概率
            if (Math.random() < gameConfig.fruitSpawnRate) {
                gameState.fruits.push(new Fruit());
            }
        }

        // 六、事件处理
        // 1. 鼠标事件
        let isMouseDown = false;
        let currentTrail = null;

        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const rect = canvas.getBoundingClientRect();
            currentTrail = new SliceTrail(
                e.clientX - rect.left, 
                e.clientY - rect.top
            );
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isMouseDown || !currentTrail) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            currentTrail.addPoint(x, y);
            
            gameState.fruits.forEach(fruit => {
                if (!fruit.sliced) {
                    const distance = Math.sqrt(
                        Math.pow(fruit.x - x, 2) + 
                        Math.pow(fruit.y - y, 2)
                    );
                    
                    if (distance < fruit.radius) {
                        fruit.slice();
                        for (let i = 0; i < 12; i++) {
                            gameState.particles.push(
                                new Particle(fruit.x, fruit.y, fruit.type.color)
                            );
                        }
                    }
                }
            });
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
            if (currentTrail) {
                gameState.sliceTrails.push(currentTrail);
                currentTrail = null;
            }
        });

        // 2. 触摸事件支持
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            
            isMouseDown = true;
            currentTrail = new SliceTrail(
                touch.clientX - rect.left, 
                touch.clientY - rect.top
            );
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isMouseDown || !currentTrail) return;
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            currentTrail.addPoint(x, y);
            
            gameState.fruits.forEach(fruit => {
                if (!fruit.sliced) {
                    const distance = Math.sqrt(
                        Math.pow(fruit.x - x, 2) + 
                        Math.pow(fruit.y - y, 2)
                    );
                    
                    if (distance < fruit.radius) {
                        fruit.slice();
                        for (let i = 0; i < 12; i++) {
                            gameState.particles.push(
                                new Particle(fruit.x, fruit.y, fruit.type.color)
                            );
                        }
                    }
                }
            });
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isMouseDown = false;
            if (currentTrail) {
                gameState.sliceTrails.push(currentTrail);
                currentTrail = null;
            }
        });

        // 七、商店系统
        // 1. 初始化商店
        function initShop() {
            const skinList = document.getElementById('skinList');
            skinList.innerHTML = '';
            
            Object.keys(skins).forEach(skinId => {
                const skin = skins[skinId];
                const skinItem = document.createElement('div');
                skinItem.className = 'skin-item';
                
                if (gameState.ownedSkins.includes(skinId)) {
                    skinItem.classList.add('owned');
                }
                
                if (gameState.currentSkin === skinId) {
                    skinItem.classList.add('selected');
                }
                
                const isGradient = skin.color.includes('rainbow');
                const previewStyle = isGradient 
                    ? 'background: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet)'
                    : `background: ${skin.color}`;
                
                skinItem.innerHTML = `
                    <div class="skin-preview" style="${previewStyle}">⚔️</div>
                    <div class="skin-name">${skin.name}</div>
                    <div class="skin-price">
                        ${gameState.ownedSkins.includes(skinId) 
                            ? gameConfig.uiText.owned 
                            : skin.price + ' 金币'}
                    </div>
                `;
                
                skinItem.addEventListener('click', () => {
                    if (gameState.ownedSkins.includes(skinId)) {
                        gameState.currentSkin = skinId;
                        initShop();
                    } else if (gameState.coins >= skin.price) {
                        gameState.coins -= skin.price;
                        gameState.ownedSkins.push(skinId);
                        updateUI();
                        initShop();
                    } else {
                        alert(gameConfig.uiText.insufficientCoins);
                    }
                });
                
                skinList.appendChild(skinItem);
            });
        }

        // 2. 切换商店显示
        function toggleShop() {
            const shopPanel = document.getElementById('shopPanel');
            if (shopPanel.style.display === 'none' || shopPanel.style.display === '') {
                shopPanel.style.display = 'block';
                initShop();
            } else {
                shopPanel.style.display = 'none';
            }
        }

        // 八、游戏循环
        function gameLoop() {
            // 1. 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 2. 绘制背景
            drawKitchenBackground();
            
            // 3. 更新和绘制背景水果
            gameState.backgroundFruits.forEach(fruit => {
                fruit.update();
                fruit.draw();
            });
            
            // 4. 生成新水果
            spawnFruit();
            
            // 5. 更新和绘制游戏水果
            gameState.fruits = gameState.fruits.filter(fruit => {
                fruit.update();
                fruit.draw();
                return !fruit.isOffScreen();
            });
            
            // 6. 更新和绘制粒子效果
            gameState.particles = gameState.particles.filter(particle => {
                particle.update();
                particle.draw();
                return particle.life > 0;
            });
            
            // 7. 更新和绘制切片轨迹
            gameState.sliceTrails = gameState.sliceTrails.filter(trail => {
                trail.update();
                trail.draw();
                return trail.life > 0;
            });
            
            // 8. 绘制当前轨迹
            if (currentTrail) {
                currentTrail.draw();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // 九、初始化游戏
        function initGame() {
            // 1. 设置画布尺寸
            resizeCanvas();
            
            // 2. 初始化UI文本
            document.getElementById('shopBtn').textContent = gameConfig.uiText.shop;
            document.getElementById('closeShop').textContent = gameConfig.uiText.close;
            document.querySelector('#shopPanel h2').textContent = gameConfig.uiText.shopTitle;
            
            // 3. 更新UI
            updateUI();
            
            // 4. 初始化背景水果
            initBackgroundFruits();
            
            // 5. 启动游戏循环
            gameLoop();
        }

        // 十、响应式处理
        window.addEventListener('resize', () => {
            resizeCanvas();
            gameState.backgroundFruits = [];
            initBackgroundFruits();
        });

        // 启动游戏
        initGame();
    </script>
</body>
</html>
