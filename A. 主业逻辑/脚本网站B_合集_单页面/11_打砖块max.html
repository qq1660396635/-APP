<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>è¶…çº§æ‰“ç –å— - Ultimate Breakout</title>
    <style>
        /* 1. å…¨å±€æ ·å¼å’Œå˜é‡å®šä¹‰ */
        :root {
            --primary-color: #00ffcc;
            --secondary-color: #ff00ff;
            --bg-gradient-start: #0a0e27;
            --bg-gradient-end: #1a1f3a;
            --text-color: #ffffff;
            --panel-bg: rgba(20, 25, 45, 0.9);
        }

        /* 2. é¡µé¢å¸ƒå±€æ ·å¼ */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start), var(--bg-gradient-end));
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
            touch-action: none;
        }

        /* 3. æ¸¸æˆå¤´éƒ¨ä¿¡æ¯æ  */
        .game-header {
            width: 100%;
            max-width: 600px;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            border-radius: 0 0 20px 20px;
            box-shadow: 0 4px 20px rgba(0, 255, 204, 0.2);
            margin-bottom: 20px;
        }

        .info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: var(--text-color);
        }

        .info-label {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
            text-shadow: 0 0 10px currentColor;
        }

        /* 4. æ¸¸æˆå®¹å™¨æ ·å¼ */
        .game-container {
            position: relative;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5),
                        0 0 60px rgba(0, 255, 204, 0.3);
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* 5. Canvasç”»å¸ƒæ ·å¼ */
        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, #0a0e27 0%, #1a1f3a 100%);
            border: 3px solid var(--primary-color);
            border-radius: 20px;
            max-width: 100%;
            height: auto;
        }

        /* 6. æ¸¸æˆæ§åˆ¶é¢æ¿ */
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 204, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 204, 0.5);
        }

        .btn:active {
            transform: translateY(0);
        }

        /* 7. æ¸¸æˆç»“æŸå’Œå…³å¡å®Œæˆå¼¹çª— */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1f3a, #2a3050);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
            box-shadow: 0 10px 40px rgba(0, 255, 204, 0.4);
            border: 2px solid var(--primary-color);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal h2 {
            font-size: 32px;
            margin-bottom: 20px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .modal p {
            font-size: 18px;
            margin: 10px 0;
        }

        /* 8. é“å…·æ˜¾ç¤ºåŒºåŸŸ */
        .power-ups {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
        }

        .power-up-indicator {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .power-up-indicator.active {
            opacity: 1;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* 9. è¿å‡»æ˜¾ç¤º */
        .combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 0 0 20px currentColor;
            opacity: 0;
            pointer-events: none;
        }

        .combo-display.show {
            animation: comboAnimation 1s ease;
        }

        @keyframes comboAnimation {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.5);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        /* 10. å“åº”å¼è®¾è®¡ */
        @media (max-width: 600px) {
            .game-header {
                padding: 15px;
                border-radius: 0 0 15px 15px;
            }
            
            .info-value {
                font-size: 20px;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <!-- æ¸¸æˆå¤´éƒ¨ä¿¡æ¯ -->
    <div class="game-header">
        <div class="info-item">
            <span class="info-label">å¾—åˆ†</span>
            <span class="info-value" id="score">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">å…³å¡</span>
            <span class="info-value" id="level">1</span>
        </div>
        <div class="info-item">
            <span class="info-label">ç”Ÿå‘½</span>
            <span class="info-value" id="lives">3</span>
        </div>
        <div class="info-item">
            <span class="info-label">è¿å‡»</span>
            <span class="info-value" id="combo">0</span>
        </div>
    </div>

    <!-- æ¸¸æˆä¸»å®¹å™¨ -->
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <!-- é“å…·æŒ‡ç¤ºå™¨ -->
        <div class="power-ups">
            <div class="power-up-indicator" id="powerUp1" title="åŠ é€Ÿçƒ">âš¡</div>
            <div class="power-up-indicator" id="powerUp2" title="åŠ é•¿æŒ¡æ¿">ğŸ”·</div>
            <div class="power-up-indicator" id="powerUp3" title="å¤šé‡çƒ">ğŸ±</div>
        </div>
        <!-- è¿å‡»æ˜¾ç¤º -->
        <div class="combo-display" id="comboDisplay"></div>
    </div>

    <!-- æ¸¸æˆæ§åˆ¶æŒ‰é’® -->
    <div class="controls">
        <button class="btn" onclick="togglePause()">æš‚åœ/ç»§ç»­</button>
        <button class="btn" onclick="resetGame()">é‡æ–°å¼€å§‹</button>
        <button class="btn" onclick="toggleSound()">éŸ³æ•ˆ: å¼€</button>
    </div>

    <!-- æ¸¸æˆç»“æŸå¼¹çª— -->
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2>æ¸¸æˆç»“æŸ</h2>
            <p>æœ€ç»ˆå¾—åˆ†: <span id="finalScore">0</span></p>
            <p>æœ€é«˜å…³å¡: <span id="finalLevel">1</span></p>
            <p>æœ€å¤§è¿å‡»: <span id="maxCombo">0</span></p>
            <button class="btn" onclick="resetGame()">å†æ¥ä¸€å±€</button>
        </div>
    </div>

    <!-- å…³å¡å®Œæˆå¼¹çª— -->
    <div class="modal" id="levelCompleteModal">
        <div class="modal-content">
            <h2>å…³å¡å®Œæˆï¼</h2>
            <p>å½“å‰å¾—åˆ†: <span id="currentScore">0</span></p>
            <p>å‡†å¤‡è¿›å…¥ç¬¬ <span id="nextLevel">2</span> å…³</p>
            <button class="btn" onclick="nextLevel()">ä¸‹ä¸€å…³</button>
        </div>
    </div>

    <script>
        // ========== æ¸¸æˆé…ç½®å˜é‡ ==========
        const CONFIG = {
            // ç”»å¸ƒé…ç½®
            CANVAS_WIDTH: 600,
            CANVAS_HEIGHT: 700,
            
            // çƒé…ç½®
            BALL_RADIUS: 8,
            BALL_SPEED: 5,
            BALL_MAX_SPEED: 12,
            
            // æŒ¡æ¿é…ç½®
            PADDLE_WIDTH: 100,
            PADDLE_HEIGHT: 15,
            PADDLE_SPEED: 8,
            PADDLE_EXTENDED_WIDTH: 150,
            
            // ç –å—é…ç½®
            BRICK_ROWS: 6,
            BRICK_COLS: 10,
            BRICK_WIDTH: 50,
            BRICK_HEIGHT: 25,
            BRICK_PADDING: 5,
            BRICK_OFFSET_TOP: 80,
            BRICK_OFFSET_LEFT: 25,
            
            // æ¸¸æˆé…ç½®
            INITIAL_LIVES: 3,
            POINTS_PER_BRICK: 10,
            COMBO_MULTIPLIER: 1.5,
            POWER_UP_DURATION: 5000,
            
            // é¢œè‰²é…ç½®
            BACKGROUND_COLORS: [
                ['#0a0e27', '#1a1f3a'],
                ['#1a0e2a', '#2a1f3a'],
                ['#0e1a27', '#1f2a3a'],
                ['#1a0e0e', '#3a1f1f'],
                ['#0e1a0e', '#1f3a1f']
            ],
            
            // ç²’å­é…ç½®
            PARTICLE_COUNT: 10,
            PARTICLE_LIFETIME: 30
        };

        // ========== æ¸¸æˆçŠ¶æ€å˜é‡ ==========
        let canvas, ctx;
        let gameState = {
            score: 0,
            level: 1,
            lives: CONFIG.INITIAL_LIVES,
            combo: 0,
            maxCombo: 0,
            isPaused: false,
            isGameOver: false,
            soundEnabled: true,
            bricksDestroyed: 0,
            backgroundIndex: 0
        };

        // ========== æ¸¸æˆå¯¹è±¡ ==========
        let ball = {
            x: CONFIG.CANVAS_WIDTH / 2,
            y: CONFIG.CANVAS_HEIGHT - 100,
            dx: CONFIG.BALL_SPEED,
            dy: -CONFIG.BALL_SPEED,
            radius: CONFIG.BALL_RADIUS,
            trail: []
        };

        let paddle = {
            x: CONFIG.CANVAS_WIDTH / 2 - CONFIG.PADDLE_WIDTH / 2,
            y: CONFIG.CANVAS_HEIGHT - 40,
            width: CONFIG.PADDLE_WIDTH,
            height: CONFIG.PADDLE_HEIGHT,
            isExtended: false
        };

        let bricks = [];
        let particles = [];
        let powerUps = [];
        let activePowerUps = {
            speed: false,
            extended: false,
            multi: false
        };

        // ========== åˆå§‹åŒ–æ¸¸æˆ ==========
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // è®¾ç½®ç”»å¸ƒå¤§å°
            canvas.width = CONFIG.CANVAS_WIDTH;
            canvas.height = CONFIG.CANVAS_HEIGHT;
            
            // åˆå§‹åŒ–ç –å—
            createBricks();
            
            // ç»‘å®šäº‹ä»¶
            bindEvents();
            
            // å¼€å§‹æ¸¸æˆå¾ªç¯
            gameLoop();
        }

        // ========== åˆ›å»ºç –å— ==========
        function createBricks() {
            bricks = [];
            const specialBrickChance = 0.1 + (gameState.level * 0.02);
            
            for (let c = 0; c < CONFIG.BRICK_COLS; c++) {
                bricks[c] = [];
                for (let r = 0; r < CONFIG.BRICK_ROWS; r++) {
                    const isSpecial = Math.random() < specialBrickChance;
                    const hue = (r * 60 + c * 20) % 360;
                    
                    bricks[c][r] = {
                        x: 0,
                        y: 0,
                        status: isSpecial ? 2 : 1,
                        color: `hsl(${hue}, 70%, 50%)`,
                        isSpecial: isSpecial,
                        powerUp: isSpecial ? getRandomPowerUp() : null
                    };
                }
            }
        }

        // ========== è·å–éšæœºé“å…· ==========
        function getRandomPowerUp() {
            const powerUpTypes = ['speed', 'extended', 'multi'];
            return powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
        }

        // ========== ç»‘å®šäº‹ä»¶ ==========
        function bindEvents() {
            // è§¦æ‘¸äº‹ä»¶
            let touchX = null;
            
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                touchX = e.touches[0].clientX - rect.left;
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (touchX !== null && !gameState.isPaused) {
                    const rect = canvas.getBoundingClientRect();
                    const currentX = e.touches[0].clientX - rect.left;
                    const deltaX = currentX - touchX;
                    paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x + deltaX));
                    touchX = currentX;
                }
            });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchX = null;
            });
            
            // é¼ æ ‡äº‹ä»¶
            canvas.addEventListener('mousemove', (e) => {
                if (!gameState.isPaused) {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, mouseX - paddle.width / 2));
                }
            });
            
            // é”®ç›˜äº‹ä»¶
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft' && !gameState.isPaused) {
                    paddle.x = Math.max(0, paddle.x - CONFIG.PADDLE_SPEED);
                } else if (e.key === 'ArrowRight' && !gameState.isPaused) {
                    paddle.x = Math.min(canvas.width - paddle.width, paddle.x + CONFIG.PADDLE_SPEED);
                } else if (e.key === ' ') {
                    togglePause();
                }
            });
        }

        // ========== æ¸¸æˆä¸»å¾ªç¯ ==========
        function gameLoop() {
            if (!gameState.isPaused && !gameState.isGameOver) {
                update();
                render();
            }
            requestAnimationFrame(gameLoop);
        }

        // ========== æ›´æ–°æ¸¸æˆçŠ¶æ€ ==========
        function update() {
            // æ›´æ–°çƒçš„ä½ç½®
            updateBall();
            
            // æ›´æ–°ç²’å­æ•ˆæœ
            updateParticles();
            
            // æ›´æ–°é“å…·
            updatePowerUps();
            
            // æ£€æµ‹ç¢°æ’
            checkCollisions();
            
            // æ£€æŸ¥æ¸¸æˆçŠ¶æ€
            checkGameStatus();
        }

        // ========== æ›´æ–°çƒ ==========
        function updateBall() {
            // æ·»åŠ è½¨è¿¹
            ball.trail.push({ x: ball.x, y: ball.y, alpha: 1 });
            if (ball.trail.length > 10) {
                ball.trail.shift();
            }
            
            // æ›´æ–°è½¨è¿¹é€æ˜åº¦
            ball.trail.forEach(point => {
                point.alpha *= 0.9;
            });
            
            // ç§»åŠ¨çƒ
            ball.x += ball.dx;
            ball.y += ball.dy;
            
            // å¢™å£ç¢°æ’
            if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
                ball.dx = -ball.dx;
                createImpactParticles(ball.x, ball.y);
            }
            
            if (ball.y - ball.radius < 0) {
                ball.dy = -ball.dy;
                createImpactParticles(ball.x, ball.y);
            }
            
            // åº•éƒ¨æ£€æµ‹
            if (ball.y - ball.radius > canvas.height) {
                loseLife();
            }
        }

        // ========== æ›´æ–°ç²’å­ ==========
        function updateParticles() {
            particles = particles.filter(particle => {
                particle.x += particle.dx;
                particle.y += particle.dy;
                particle.dy += 0.2; // é‡åŠ›
                particle.life--;
                particle.alpha = particle.life / CONFIG.PARTICLE_LIFETIME;
                return particle.life > 0;
            });
        }

        // ========== æ›´æ–°é“å…· ==========
        function updatePowerUps() {
            powerUps = powerUps.filter(powerUp => {
                powerUp.y += 2;
                
                // æ£€æµ‹ä¸æŒ¡æ¿ç¢°æ’
                if (powerUp.y + 10 > paddle.y &&
                    powerUp.x > paddle.x &&
                    powerUp.x < paddle.x + paddle.width) {
                    activatePowerUp(powerUp.type);
                    return false;
                }
                
                return powerUp.y < canvas.height;
            });
        }

        // ========== æ¿€æ´»é“å…· ==========
        function activatePowerUp(type) {
            activePowerUps[type] = true;
            
            // æ˜¾ç¤ºé“å…·æŒ‡ç¤ºå™¨
            const indicator = document.getElementById(`powerUp${type === 'speed' ? '1' : type === 'extended' ? '2' : '3'}`);
            indicator.classList.add('active');
            
            // åº”ç”¨é“å…·æ•ˆæœ
            switch(type) {
                case 'speed':
                    const speedMultiplier = 1.5;
                    ball.dx *= speedMultiplier;
                    ball.dy *= speedMultiplier;
                    break;
                case 'extended':
                    paddle.width = CONFIG.PADDLE_EXTENDED_WIDTH;
                    paddle.isExtended = true;
                    break;
                case 'multi':
                    // å¤šé‡çƒæ•ˆæœï¼ˆç®€åŒ–ç‰ˆï¼‰
                    createImpactParticles(ball.x, ball.y, 20);
                    break;
            }
            
            // è®¾ç½®é“å…·æŒç»­æ—¶é—´
            setTimeout(() => {
                deactivatePowerUp(type);
            }, CONFIG.POWER_UP_DURATION);
        }

        // ========== å–æ¶ˆé“å…· ==========
        function deactivatePowerUp(type) {
            activePowerUps[type] = false;
            
            // éšè—é“å…·æŒ‡ç¤ºå™¨
            const indicator = document.getElementById(`powerUp${type === 'speed' ? '1' : type === 'extended' ? '2' : '3'}`);
            indicator.classList.remove('active');
            
            // æ¢å¤åŸå§‹çŠ¶æ€
            switch(type) {
                case 'speed':
                    const speedMultiplier = 1 / 1.5;
                    ball.dx *= speedMultiplier;
                    ball.dy *= speedMultiplier;
                    break;
                case 'extended':
                    paddle.width = CONFIG.PADDLE_WIDTH;
                    paddle.isExtended = false;
                    break;
            }
        }

        // ========== ç¢°æ’æ£€æµ‹ ==========
        function checkCollisions() {
            // æŒ¡æ¿ç¢°æ’
            if (ball.y + ball.radius > paddle.y &&
                ball.y - ball.radius < paddle.y + paddle.height &&
                ball.x > paddle.x &&
                ball.x < paddle.x + paddle.width) {
                
                ball.dy = -Math.abs(ball.dy);
                
                // æ ¹æ®ç¢°æ’ä½ç½®è°ƒæ•´è§’åº¦
                const hitPos = (ball.x - paddle.x) / paddle.width;
                ball.dx = 8 * (hitPos - 0.5);
                
                createImpactParticles(ball.x, paddle.y);
            }
            
            // ç –å—ç¢°æ’
            for (let c = 0; c < CONFIG.BRICK_COLS; c++) {
                for (let r = 0; r < CONFIG.BRICK_ROWS; r++) {
                    const brick = bricks[c][r];
                    if (brick.status > 0) {
                        const brickX = c * (CONFIG.BRICK_WIDTH + CONFIG.BRICK_PADDING) + CONFIG.BRICK_OFFSET_LEFT;
                        const brickY = r * (CONFIG.BRICK_HEIGHT + CONFIG.BRICK_PADDING) + CONFIG.BRICK_OFFSET_TOP;
                        
                        if (ball.x > brickX &&
                            ball.x < brickX + CONFIG.BRICK_WIDTH &&
                            ball.y > brickY &&
                            ball.y < brickY + CONFIG.BRICK_HEIGHT) {
                            
                            ball.dy = -ball.dy;
                            brick.status--;
                            
                            if (brick.status === 0) {
                                // ç –å—è¢«æ‘§æ¯
                                onBrickDestroyed(brickX, brickY, brick);
                            } else {
                                // ç‰¹æ®Šç –å—å—æŸ
                                createImpactParticles(brickX + CONFIG.BRICK_WIDTH/2, brickY + CONFIG.BRICK_HEIGHT/2);
                            }
                        }
                    }
                }
            }
        }

        // ========== ç –å—è¢«æ‘§æ¯ ==========
        function onBrickDestroyed(x, y, brick) {
            // å¢åŠ åˆ†æ•°
            const points = CONFIG.POINTS_PER_BRICK * (1 + gameState.combo * 0.1);
            gameState.score += Math.floor(points);
            gameState.combo++;
            gameState.bricksDestroyed++;
            
            // æ›´æ–°UI
            updateUI();
            
            // åˆ›å»ºç²’å­æ•ˆæœ
            createBrickParticles(x + CONFIG.BRICK_WIDTH/2, y + CONFIG.BRICK_HEIGHT/2, brick.color);
            
            // æ‰è½é“å…·
            if (brick.powerUp) {
                powerUps.push({
                    x: x + CONFIG.BRICK_WIDTH/2,
                    y: y + CONFIG.BRICK_HEIGHT/2,
                    type: brick.powerUp,
                    color: brick.color
                });
            }
            
            // æ˜¾ç¤ºè¿å‡»
            if (gameState.combo > 2) {
                showCombo();
            }
            
            // æ¯5ä¸ªç –å—æ”¹å˜èƒŒæ™¯
            if (gameState.bricksDestroyed % 5 === 0) {
                changeBackgroundColor();
            }
            
            // æ£€æŸ¥å…³å¡å®Œæˆ
            if (checkLevelComplete()) {
                onLevelComplete();
            }
        }

        // ========== åˆ›å»ºç²’å­æ•ˆæœ ==========
        function createBrickParticles(x, y, color) {
            for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
                particles.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * 8,
                    dy: (Math.random() - 0.5) * 8,
                    color: color,
                    size: Math.random() * 4 + 2,
                    life: CONFIG.PARTICLE_LIFETIME,
                    alpha: 1
                });
            }
        }

        // ========== åˆ›å»ºæ’å‡»ç²’å­ ==========
        function createImpactParticles(x, y, count = 5) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * 4,
                    dy: (Math.random() - 0.5) * 4,
                    color: '#ffffff',
                    size: Math.random() * 3 + 1,
                    life: 15,
                    alpha: 1
                });
            }
        }

        // ========== æ”¹å˜èƒŒæ™¯é¢œè‰² ==========
        function changeBackgroundColor() {
            gameState.backgroundIndex = (gameState.backgroundIndex + 1) % CONFIG.BACKGROUND_COLORS.length;
            const colors = CONFIG.BACKGROUND_COLORS[gameState.backgroundIndex];
            document.body.style.background = `linear-gradient(135deg, ${colors[0]}, ${colors[1]})`;
        }

        // ========== æ˜¾ç¤ºè¿å‡» ==========
        function showCombo() {
            const comboDisplay = document.getElementById('comboDisplay');
            comboDisplay.textContent = `${gameState.combo}x è¿å‡»!`;
            comboDisplay.classList.remove('show');
            void comboDisplay.offsetWidth; // è§¦å‘é‡æ’
            comboDisplay.classList.add('show');
        }

        // ========== æ›´æ–°UI ==========
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('combo').textContent = gameState.combo;
        }

        // ========== æ£€æŸ¥å…³å¡å®Œæˆ ==========
        function checkLevelComplete() {
            for (let c = 0; c < CONFIG.BRICK_COLS; c++) {
                for (let r = 0; r < CONFIG.BRICK_ROWS; r++) {
                    if (bricks[c][r].status > 0) {
                        return false;
                    }
                }
            }
            return true;
        }

        // ========== å…³å¡å®Œæˆ ==========
        function onLevelComplete() {
            gameState.isPaused = true;
            document.getElementById('currentScore').textContent = gameState.score;
            document.getElementById('nextLevel').textContent = gameState.level + 1;
            document.getElementById('levelCompleteModal').style.display = 'flex';
        }

        // ========== ä¸‹ä¸€å…³ ==========
        function nextLevel() {
            gameState.level++;
            gameState.isPaused = false;
            gameState.bricksDestroyed = 0;
            
            // é‡ç½®çƒå’ŒæŒ¡æ¿
            resetBallAndPaddle();
            
            // åˆ›å»ºæ–°ç –å—
            createBricks();
            
            // å¢åŠ çƒé€Ÿ
            const speedIncrease = 1.1;
            ball.dx *= speedIncrease;
            ball.dy *= speedIncrease;
            
            // æ”¹å˜èƒŒæ™¯
            changeBackgroundColor();
            
            // éšè—å¼¹çª—
            document.getElementById('levelCompleteModal').style.display = 'none';
            
            updateUI();
        }

        // ========== å¤±å»ç”Ÿå‘½ ==========
        function loseLife() {
            gameState.lives--;
            gameState.combo = 0;
            
            if (gameState.lives <= 0) {
                gameOver();
            } else {
                resetBallAndPaddle();
                updateUI();
            }
        }

        // ========== é‡ç½®çƒå’ŒæŒ¡æ¿ ==========
        function resetBallAndPaddle() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height - 100;
            ball.dx = CONFIG.BALL_SPEED * (Math.random() > 0.5 ? 1 : -1);
            ball.dy = -CONFIG.BALL_SPEED;
            ball.trail = [];
            
            paddle.x = canvas.width / 2 - paddle.width / 2;
        }

        // ========== æ¸¸æˆç»“æŸ ==========
        function gameOver() {
            gameState.isGameOver = true;
            gameState.maxCombo = Math.max(gameState.maxCombo, gameState.combo);
            
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalLevel').textContent = gameState.level;
            document.getElementById('maxCombo').textContent = gameState.maxCombo;
            document.getElementById('gameOverModal').style.display = 'flex';
        }

        // ========== æ£€æŸ¥æ¸¸æˆçŠ¶æ€ ==========
        function checkGameStatus() {
            // è¿™é‡Œå¯ä»¥æ·»åŠ é¢å¤–çš„æ¸¸æˆçŠ¶æ€æ£€æŸ¥
        }

        // ========== æ¸²æŸ“æ¸¸æˆ ==========
        function render() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = 'rgba(10, 14, 39, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
            drawGrid();
            
            // ç»˜åˆ¶ç –å—
            drawBricks();
            
            // ç»˜åˆ¶ç²’å­
            drawParticles();
            
            // ç»˜åˆ¶é“å…·
            drawPowerUps();
            
            // ç»˜åˆ¶çƒè½¨è¿¹
            drawBallTrail();
            
            // ç»˜åˆ¶çƒ
            drawBall();
            
            // ç»˜åˆ¶æŒ¡æ¿
            drawPaddle();
        }

        // ========== ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯ ==========
        function drawGrid() {
            ctx.strokeStyle = 'rgba(0, 255, 204, 0.05)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            
            for (let i = 0; i < canvas.height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
        }

        // ========== ç»˜åˆ¶ç –å— ==========
        function drawBricks() {
            for (let c = 0; c < CONFIG.BRICK_COLS; c++) {
                for (let r = 0; r < CONFIG.BRICK_ROWS; r++) {
                    const brick = bricks[c][r];
                    if (brick.status > 0) {
                        const brickX = c * (CONFIG.BRICK_WIDTH + CONFIG.BRICK_PADDING) + CONFIG.BRICK_OFFSET_LEFT;
                        const brickY = r * (CONFIG.BRICK_HEIGHT + CONFIG.BRICK_PADDING) + CONFIG.BRICK_OFFSET_TOP;
                        
                        // ç»˜åˆ¶ç –å—é˜´å½±
                        ctx.shadowColor = brick.color;
                        ctx.shadowBlur = 10;
                        
                        // ç»˜åˆ¶ç –å—
                        ctx.fillStyle = brick.status === 2 ? brick.color : `${brick.color}88`;
                        ctx.fillRect(brickX, brickY, CONFIG.BRICK_WIDTH, CONFIG.BRICK_HEIGHT);
                        
                        // ç»˜åˆ¶ç –å—è¾¹æ¡†
                        ctx.strokeStyle = brick.color;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(brickX, brickY, CONFIG.BRICK_WIDTH, CONFIG.BRICK_HEIGHT);
                        
                        // ç‰¹æ®Šç –å—æ ‡è®°
                        if (brick.isSpecial) {
                            ctx.fillStyle = '#ffffff';
                            ctx.font = '16px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('â˜…', brickX + CONFIG.BRICK_WIDTH/2, brickY + CONFIG.BRICK_HEIGHT/2 + 5);
                        }
                        
                        ctx.shadowBlur = 0;
                    }
                }
            }
        }

        // ========== ç»˜åˆ¶ç²’å­ ==========
        function drawParticles() {
            particles.forEach(particle => {
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;
                ctx.fillRect(particle.x - particle.size/2, particle.y - particle.size/2, particle.size, particle.size);
            });
            ctx.globalAlpha = 1;
        }

        // ========== ç»˜åˆ¶é“å…· ==========
        function drawPowerUps() {
            powerUps.forEach(powerUp => {
                // ç»˜åˆ¶é“å…·å…‰æ™•
                const gradient = ctx.createRadialGradient(powerUp.x, powerUp.y, 0, powerUp.x, powerUp.y, 20);
                gradient.addColorStop(0, powerUp.color);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(powerUp.x - 20, powerUp.y - 20, 40, 40);
                
                // ç»˜åˆ¶é“å…·å›¾æ ‡
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                const icon = powerUp.type === 'speed' ? 'âš¡' : powerUp.type === 'extended' ? 'ğŸ”·' : 'ğŸ±';
                ctx.fillText(icon, powerUp.x, powerUp.y + 5);
            });
        }

        // ========== ç»˜åˆ¶çƒè½¨è¿¹ ==========
        function drawBallTrail() {
            ball.trail.forEach((point, index) => {
                ctx.globalAlpha = point.alpha * 0.5;
                ctx.fillStyle = '#00ffcc';
                ctx.beginPath();
                ctx.arc(point.x, point.y, ball.radius * (index / ball.trail.length), 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        // ========== ç»˜åˆ¶çƒ ==========
        function drawBall() {
            // ç»˜åˆ¶çƒå…‰æ™•
            const gradient = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ball.radius * 2);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.5, '#00ffcc');
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius * 2, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶çƒä½“
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        // ========== ç»˜åˆ¶æŒ¡æ¿ ==========
        function drawPaddle() {
            // ç»˜åˆ¶æŒ¡æ¿å…‰æ™•
            ctx.shadowColor = '#0095DD';
            ctx.shadowBlur = 20;
            
            // ç»˜åˆ¶æŒ¡æ¿ä¸»ä½“
            const gradient = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.height);
            gradient.addColorStop(0, '#00ffcc');
            gradient.addColorStop(1, '#0095DD');
            ctx.fillStyle = gradient;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            
            // ç»˜åˆ¶æŒ¡æ¿è¾¹æ¡†
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(paddle.x, paddle.y, paddle.width, paddle.height);
            
            ctx.shadowBlur = 0;
        }

        // ========== æ¸¸æˆæ§åˆ¶å‡½æ•° ==========
        function togglePause() {
            gameState.isPaused = !gameState.isPaused;
        }

        function resetGame() {
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameState = {
                score: 0,
                level: 1,
                lives: CONFIG.INITIAL_LIVES,
                combo: 0,
                maxCombo: 0,
                isPaused: false,
                isGameOver: false,
                soundEnabled: gameState.soundEnabled,
                bricksDestroyed: 0,
                backgroundIndex: 0
            };
            
            // é‡ç½®æ¸¸æˆå¯¹è±¡
            resetBallAndPaddle();
            createBricks();
            particles = [];
            powerUps = [];
            
            // é‡ç½®èƒŒæ™¯
            document.body.style.background = `linear-gradient(135deg, ${CONFIG.BACKGROUND_COLORS[0][0]}, ${CONFIG.BACKGROUND_COLORS[0][1]})`;
            
            // éšè—å¼¹çª—
            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('levelCompleteModal').style.display = 'none';
            
            // æ›´æ–°UI
            updateUI();
        }

        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            event.target.textContent = `éŸ³æ•ˆ: ${gameState.soundEnabled ? 'å¼€' : 'å…³'}`;
        }

        // ========== å¯åŠ¨æ¸¸æˆ ==========
        window.onload = initGame;
    </script>
</body>
</html>
